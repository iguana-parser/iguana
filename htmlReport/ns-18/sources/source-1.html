


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > IggyParseTreeToGrammarVisitor</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.iguana.iggy</a>
</div>

<h1>Coverage Summary for Class: IggyParseTreeToGrammarVisitor (org.iguana.iggy)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">IggyParseTreeToGrammarVisitor</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    86.4%
  </span>
  <span class="absValue">
    (89/103)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    84.9%
  </span>
  <span class="absValue">
    (310/365)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package org.iguana.iggy;
&nbsp;
&nbsp;import org.iguana.datadependent.ast.AST;
&nbsp;import org.iguana.datadependent.ast.Expression;
&nbsp;import org.iguana.datadependent.ast.Statement;
&nbsp;import org.iguana.grammar.Grammar;
&nbsp;import org.iguana.grammar.condition.DataDependentCondition;
&nbsp;import org.iguana.grammar.condition.PositionalCondition;
&nbsp;import org.iguana.grammar.condition.RegularExpressionCondition;
&nbsp;import org.iguana.grammar.slot.NonterminalNodeType;
&nbsp;import org.iguana.grammar.slot.TerminalNodeType;
&nbsp;import org.iguana.grammar.symbol.AbstractSymbol;
&nbsp;import org.iguana.grammar.symbol.Align;
&nbsp;import org.iguana.grammar.symbol.Alt;
&nbsp;import org.iguana.grammar.symbol.Alternative;
&nbsp;import org.iguana.grammar.symbol.Associativity;
&nbsp;import org.iguana.grammar.symbol.Code;
&nbsp;import org.iguana.grammar.symbol.Error;
&nbsp;import org.iguana.grammar.symbol.Group;
&nbsp;import org.iguana.grammar.symbol.Identifier;
&nbsp;import org.iguana.grammar.symbol.IfThenElse;
&nbsp;import org.iguana.grammar.symbol.Ignore;
&nbsp;import org.iguana.grammar.symbol.LayoutStrategy;
&nbsp;import org.iguana.grammar.symbol.Nonterminal;
&nbsp;import org.iguana.grammar.symbol.Offside;
&nbsp;import org.iguana.grammar.symbol.Opt;
&nbsp;import org.iguana.grammar.symbol.Plus;
&nbsp;import org.iguana.grammar.symbol.PriorityLevel;
&nbsp;import org.iguana.grammar.symbol.Return;
&nbsp;import org.iguana.grammar.symbol.Rule;
&nbsp;import org.iguana.grammar.symbol.Sequence;
&nbsp;import org.iguana.grammar.symbol.Star;
&nbsp;import org.iguana.grammar.symbol.Start;
&nbsp;import org.iguana.grammar.symbol.Symbol;
&nbsp;import org.iguana.grammar.symbol.SymbolBuilder;
&nbsp;import org.iguana.grammar.symbol.Terminal;
&nbsp;import org.iguana.iggy.gen.IggyParseTree;
&nbsp;import org.iguana.iggy.gen.IggyParseTree.RegexRule;
&nbsp;import org.iguana.iggy.gen.IggyParseTreeVisitor;
&nbsp;import org.iguana.parsetree.ParseTreeNode;
&nbsp;import org.iguana.regex.Char;
&nbsp;import org.iguana.regex.CharRange;
&nbsp;import org.iguana.regex.RegularExpression;
&nbsp;import org.iguana.regex.Seq;
&nbsp;import org.iguana.util.Tuple;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.LinkedHashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Optional;
&nbsp;import java.util.function.Function;
&nbsp;import java.util.stream.Collectors;
&nbsp;
&nbsp;import static org.iguana.utils.collections.CollectionsUtil.flatten;
&nbsp;
<b class="fc">&nbsp;public class IggyParseTreeToGrammarVisitor implements IggyParseTreeVisitor&lt;Object&gt; {</b>
&nbsp;
&nbsp;    // A map from the name of the regular expressions (as they are defined in the grammar) to the regular expression.
<b class="fc">&nbsp;    private final Map&lt;String, RegularExpression&gt; regularExpressionDefinitions = new LinkedHashMap&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;    private final Map&lt;String, RegularExpression&gt; literals = new LinkedHashMap&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;    private final List&lt;String&gt; startSymbols = new ArrayList&lt;&gt;();</b>
&nbsp;    private Identifier layout;
&nbsp;
&nbsp;    @Override
&nbsp;    public Grammar visitGrammar(IggyParseTree.Grammar node) {
<b class="fc">&nbsp;        Optional&lt;Identifier&gt; name = visit(node.name());</b>
<b class="fc">&nbsp;        Grammar.Builder builder = new Grammar.Builder();</b>
<b class="fc">&nbsp;        List&lt;Object&gt; defs = visit(node.defs());</b>
&nbsp;
<b class="fc">&nbsp;        final Map&lt;String, Expression&gt; globals = new HashMap&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;        for (Object def : defs) {</b>
<b class="fc">&nbsp;            if (def instanceof Rule) {</b>
<b class="fc">&nbsp;                builder.addRule((Rule) def);</b>
&nbsp;            } else { // Tuple&lt;String, Expression)
<b class="fc">&nbsp;                Tuple&lt;String, Expression&gt; var = (Tuple&lt;String, Expression&gt;) def;</b>
<b class="fc">&nbsp;                globals.put(var.getFirst(), var.getSecond());</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        for (Map.Entry&lt;String, RegularExpression&gt; entry : regularExpressionDefinitions.entrySet()) {</b>
<b class="fc">&nbsp;            builder.addRegularExpression(entry.getKey(), entry.getValue());</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        for (Map.Entry&lt;String, Expression&gt; entry : globals.entrySet()) {</b>
<b class="fc">&nbsp;            builder.addGlobal(entry.getKey(), entry.getValue());</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        for (Map.Entry&lt;String, RegularExpression&gt; entry : literals.entrySet()) {</b>
<b class="fc">&nbsp;            builder.addLiteral(entry.getKey(), entry.getValue());</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        for (String start : startSymbols) {</b>
<b class="fc">&nbsp;            builder.addStartSymbol(Start.from(start));</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        builder.setLayout(layout);</b>
<b class="fc">&nbsp;        name.ifPresent(identifier -&gt; builder.setName(identifier.getName()));</b>
<b class="fc">&nbsp;        return builder.build();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Tuple&lt;String, Expression&gt; visitTopLevelVar(IggyParseTree.TopLevelVar node) {
<b class="fc">&nbsp;        String key = node.id().getText();</b>
<b class="fc">&nbsp;        Expression value = (Expression) node.exp().accept(this);</b>
<b class="fc">&nbsp;        return Tuple.of(key, value);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Rule visitContextFreeRule(IggyParseTree.ContextFreeRule node) {
<b class="fc">&nbsp;        Identifier nonterminalName = (Identifier) node.name().accept(this);</b>
<b class="fc">&nbsp;        Optional&lt;List&lt;Identifier&gt;&gt; parameters = visit(node.params());</b>
<b class="fc">&nbsp;        List&lt;PriorityLevel&gt; priorityLevels = visit(node.body());</b>
&nbsp;
<b class="fc">&nbsp;        LayoutStrategy layoutStrategy = LayoutStrategy.INHERITED;</b>
<b class="fc">&nbsp;        if (node.modifier().hasChildren()) { // start symbol</b>
<b class="fc">&nbsp;            String text = node.modifier().getText();</b>
<b class="fc">&nbsp;            if (text.equals(&quot;start&quot;)) {</b>
<b class="fc">&nbsp;                startSymbols.add(nonterminalName.getName());</b>
<b class="fc">&nbsp;            } else if (text.equals(&quot;lexical&quot;)) {</b>
<b class="fc">&nbsp;                layoutStrategy = LayoutStrategy.NO_LAYOUT;</b>
&nbsp;            } else { // &quot;layout&quot;
<b class="fc">&nbsp;                layout = nonterminalName;</b>
<b class="fc">&nbsp;                layoutStrategy = LayoutStrategy.NO_LAYOUT;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        NonterminalNodeType nonterminalNodeType;
<b class="fc">&nbsp;        if (layout == null) {</b>
<b class="fc">&nbsp;            nonterminalNodeType = NonterminalNodeType.Basic;</b>
&nbsp;        } else {
<b class="fc">&nbsp;            if (layout.getName().equals(nonterminalName.getName())) {</b>
<b class="fc">&nbsp;                nonterminalNodeType = NonterminalNodeType.Layout;</b>
&nbsp;            } else {
<b class="fc">&nbsp;                nonterminalNodeType = NonterminalNodeType.Basic;</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        Nonterminal nonterminal = new Nonterminal.Builder(nonterminalName.getName())</b>
<b class="fc">&nbsp;            .addParameters(parameters.map(identifiers -&gt; identifiers.stream().map(AbstractSymbol::toString)</b>
<b class="fc">&nbsp;                .collect(Collectors.toList())).orElse(Collections.emptyList()))</b>
<b class="fc">&nbsp;            .setNodeType(nonterminalNodeType)</b>
<b class="fc">&nbsp;            .build();</b>
&nbsp;
<b class="fc">&nbsp;        return new Rule.Builder(nonterminal)</b>
<b class="fc">&nbsp;            .addPriorityLevels(priorityLevels)</b>
<b class="fc">&nbsp;            .setLayoutStrategy(layoutStrategy)</b>
<b class="fc">&nbsp;            .build();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Void visitRegexRule(RegexRule node) {
<b class="fc">&nbsp;        List&lt;List&lt;RegularExpression&gt;&gt; alts = visit(node.body());</b>
<b class="fc">&nbsp;        Identifier identifier = (Identifier) node.name().accept(this);</b>
<b class="fc">&nbsp;        regularExpressionDefinitions.put(identifier.getName(), getRegex(alts));</b>
&nbsp;
<b class="fc">&nbsp;        if (node.modifier().hasChildren()) {</b>
<b class="fc">&nbsp;            layout = identifier;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public List&lt;Identifier&gt; visitParameters(IggyParseTree.Parameters node) {
<b class="fc">&nbsp;        return visitChildren(node);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Object visitRegexBody(IggyParseTree.RegexBody node) {
<b class="fc">&nbsp;        return visitChildren(node);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Object visitBody(IggyParseTree.Body node) {
<b class="fc">&nbsp;        return visitChildren(node);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public PriorityLevel visitPriorityLevels(IggyParseTree.PriorityLevels node) {
<b class="fc">&nbsp;        PriorityLevel.Builder builder = new PriorityLevel.Builder();</b>
<b class="fc">&nbsp;        builder.addAlternatives(visitChildren(node));</b>
<b class="fc">&nbsp;        return builder.build();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Alternative visitSequenceAlternative(IggyParseTree.SequenceAlternative node) {
<b class="fc">&nbsp;        Alternative.Builder builder = new Alternative.Builder();</b>
<b class="fc">&nbsp;        builder.addSequence((Sequence) node.seq().accept(this));</b>
<b class="fc">&nbsp;        return builder.build();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Alternative visitAssociativityAlternative(IggyParseTree.AssociativityAlternative node) {
<b class="fc">&nbsp;        Associativity associativity = getAssociativity(node.assoc());</b>
<b class="fc">&nbsp;        List&lt;Sequence&gt; seqs = visit(node.seqs());</b>
<b class="fc">&nbsp;        return new Alternative.Builder(seqs, associativity).build();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Sequence visitMoreThanOneElemSequence(IggyParseTree.MoreThanOneElemSequence node) {
<b class="fc">&nbsp;        Sequence.Builder builder = new Sequence.Builder();</b>
&nbsp;
<b class="fc">&nbsp;        if (node.assoc().hasChildren()) {</b>
<b class="fc">&nbsp;            builder.setAssociativity(getAssociativity(node.assoc()));</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        Optional&lt;List&lt;Expression&gt;&gt; expressions = visit(node.cond());</b>
<b class="fc">&nbsp;        List&lt;Symbol&gt; symbols = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;        Symbol symbol = (Symbol) node.first().accept(this);</b>
<b class="fc">&nbsp;        SymbolBuilder&lt;? extends Symbol&gt; symbolBuilder = symbol.copy();</b>
<b class="fc">&nbsp;        if (expressions.isPresent()) {</b>
<b class="fc">&nbsp;            for (Expression expression : expressions.get()) {</b>
<b class="fc">&nbsp;                symbolBuilder.addPreCondition(DataDependentCondition.predicate(expression));</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        }
<b class="fc">&nbsp;        symbols.add(symbolBuilder.build());</b>
<b class="fc">&nbsp;        symbols.addAll(visit(node.rest()));</b>
<b class="fc">&nbsp;        builder.addSymbols(symbols);</b>
<b class="fc">&nbsp;        Optional&lt;Expression&gt; returnExpression = visit(node.ret());</b>
<b class="fc">&nbsp;        if (returnExpression.isPresent()) {</b>
<b class="fc">&nbsp;            builder.addSymbol(Return.ret(returnExpression.get()));</b>
&nbsp;        }
<b class="fc">&nbsp;        Optional&lt;String&gt; label = visit(node.label());</b>
<b class="fc">&nbsp;        if (label.isPresent()) {</b>
<b class="fc">&nbsp;            builder.setLabel(label.get());</b>
&nbsp;        }
<b class="fc">&nbsp;        return builder.build();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Sequence visitSingleElemSequence(IggyParseTree.SingleElemSequence node) {
<b class="fc">&nbsp;        Sequence.Builder builder = new Sequence.Builder();</b>
<b class="fc">&nbsp;        Optional&lt;List&lt;Expression&gt;&gt; expressions = visit(node.cond());</b>
<b class="fc">&nbsp;        Symbol symbol = (Symbol) node.sym().accept(this);</b>
<b class="fc">&nbsp;        SymbolBuilder&lt;? extends Symbol&gt; symbolBuilder = symbol.copy();</b>
<b class="fc">&nbsp;        if (expressions.isPresent()) {</b>
<b class="nc">&nbsp;            for (Expression expression : expressions.get()) {</b>
<b class="nc">&nbsp;                symbolBuilder.addPreCondition(DataDependentCondition.predicate(expression));</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="fc">&nbsp;        Optional&lt;Expression&gt; returnExpression = visit(node.ret());</b>
<b class="fc">&nbsp;        if (returnExpression.isPresent()) {</b>
<b class="nc">&nbsp;            builder.addSymbol(Return.ret(returnExpression.get()));</b>
&nbsp;        }
<b class="fc">&nbsp;        builder.addSymbol(symbolBuilder.build());</b>
<b class="fc">&nbsp;        Optional&lt;String&gt; label = visit(node.label());</b>
<b class="fc">&nbsp;        if (label.isPresent()) {</b>
<b class="fc">&nbsp;            builder.setLabel(label.get());</b>
&nbsp;        }
<b class="fc">&nbsp;        return builder.build();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Sequence visitEmptySequence(IggyParseTree.EmptySequence node) {
<b class="fc">&nbsp;        Optional&lt;String&gt; label = visit(node.label());</b>
<b class="fc">&nbsp;        return new Sequence.Builder().setLabel(label.orElse(null)).build();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Object visitCondition(IggyParseTree.Condition node) {
<b class="fc">&nbsp;        return visitChildren(node);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Nonterminal visitCallSymbol(IggyParseTree.CallSymbol node) {
<b class="fc">&nbsp;        Expression[] expressions = ((List&lt;Expression&gt;) node.args().accept(this)).toArray(new Expression[]{});</b>
<b class="fc">&nbsp;        Identifier id = (Identifier) node.id().accept(this);</b>
<b class="fc">&nbsp;        return new Nonterminal.Builder(id.getName()).apply(expressions).build();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Offside visitOffsideSymbol(IggyParseTree.OffsideSymbol node) {
<b class="fc">&nbsp;        return Offside.offside((Symbol) node.sym().accept(this));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Star visitStarSymbol(IggyParseTree.StarSymbol node) {
<b class="fc">&nbsp;        return Star.from((Symbol) node.sym().accept(this));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Plus visitPlusSymbol(IggyParseTree.PlusSymbol node) {
<b class="fc">&nbsp;        return Plus.from((Symbol) node.sym().accept(this));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Opt visitOptionSymbol(IggyParseTree.OptionSymbol node) {
<b class="fc">&nbsp;        return Opt.from((Symbol) node.sym().accept(this));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Group visitSequenceSymbol(IggyParseTree.SequenceSymbol node) {
<b class="fc">&nbsp;        List&lt;Symbol&gt; symbols = visit(node.syms());</b>
<b class="fc">&nbsp;        return Group.from(symbols);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Alt visitAlternationSymbol(IggyParseTree.AlternationSymbol node) {
<b class="fc">&nbsp;        List&lt;Symbol&gt; symbols = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;        List&lt;Symbol&gt; first = visit(node.first());</b>
<b class="fc">&nbsp;        List&lt;List&lt;Symbol&gt;&gt; second = visit(node.rest());</b>
<b class="fc">&nbsp;        if (first.size() == 1) {</b>
<b class="fc">&nbsp;            symbols.add(first.get(0));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            symbols.add(Group.from(first));</b>
&nbsp;        }
<b class="fc">&nbsp;        for (List&lt;Symbol&gt; list : second) {</b>
<b class="fc">&nbsp;            if (list.size() == 1) {</b>
<b class="fc">&nbsp;                symbols.add(list.get(0));</b>
&nbsp;            } else {
<b class="fc">&nbsp;                symbols.add(Group.from(list));</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return Alt.from(symbols);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Align visitAlignSymbol(IggyParseTree.AlignSymbol node) {
<b class="fc">&nbsp;        return Align.align((Symbol) node.sym().accept(this));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Ignore visitIgnoreSymbol(IggyParseTree.IgnoreSymbol node) {
<b class="fc">&nbsp;        return Ignore.ignore((Symbol) node.sym().accept(this));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Symbol visitLabeledSymbol(IggyParseTree.LabeledSymbol node) {
<b class="fc">&nbsp;        Symbol symbol = (Symbol) node.sym().accept(this);</b>
<b class="fc">&nbsp;        Identifier id = (Identifier) node.id().accept(this);</b>
<b class="fc">&nbsp;        return symbol.copy().setLabel(id.getName()).build();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Symbol visitStatementSymbol(IggyParseTree.StatementSymbol node) {
<b class="fc">&nbsp;        Symbol symbol = (Symbol) node.sym().accept(this);</b>
<b class="fc">&nbsp;        List&lt;List&lt;Statement&gt;&gt; statements = visit(node.stmts());</b>
<b class="fc">&nbsp;        return Code.code(symbol, flatten(statements).toArray(new Statement[0]));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Symbol visitPostConditionSymbol(IggyParseTree.PostConditionSymbol node) {
<b class="fc">&nbsp;        Symbol symbol = (Symbol) node.sym().accept(this);</b>
<b class="fc">&nbsp;        List&lt;Expression&gt; expressions = visit(node.cond());</b>
<b class="fc">&nbsp;        SymbolBuilder&lt;? extends Symbol&gt; builder = symbol.copy();</b>
<b class="fc">&nbsp;        for (Expression expression : expressions) {</b>
<b class="fc">&nbsp;            builder.addPostCondition(DataDependentCondition.predicate(expression));</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return builder.build();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Symbol visitPrecedeSymbol(IggyParseTree.PrecedeSymbol node) {
<b class="nc">&nbsp;        Symbol symbol = (Symbol) node.sym().accept(this);</b>
<b class="nc">&nbsp;        RegularExpression regex = (RegularExpression) node.reg().accept(this);</b>
<b class="nc">&nbsp;        return symbol.copy().addPreCondition(RegularExpressionCondition.precede(regex)).build();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Symbol visitNotPrecedeSymbol(IggyParseTree.NotPrecedeSymbol node) {
<b class="fc">&nbsp;        Symbol symbol = (Symbol) node.sym().accept(this);</b>
<b class="fc">&nbsp;        RegularExpression regex = (RegularExpression) node.reg().accept(this);</b>
<b class="fc">&nbsp;        return symbol.copy().addPreCondition(RegularExpressionCondition.notPrecede(regex)).build();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Symbol visitStartOfLineSymbol(IggyParseTree.StartOfLineSymbol node) {
<b class="nc">&nbsp;        Symbol symbol = (Symbol) node.sym().accept(this);</b>
<b class="nc">&nbsp;        return symbol.copy().addPreCondition(PositionalCondition.startOfLineCondition()).build();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Symbol visitFollowSymbol(IggyParseTree.FollowSymbol node) {
<b class="nc">&nbsp;        Symbol symbol = (Symbol) node.sym().accept(this);</b>
<b class="nc">&nbsp;        RegularExpression regex = (RegularExpression) node.reg().accept(this);</b>
<b class="nc">&nbsp;        return symbol.copy().addPostCondition(RegularExpressionCondition.follow(regex)).build();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Symbol visitNotFollowSymbol(IggyParseTree.NotFollowSymbol node) {
<b class="fc">&nbsp;        Symbol symbol = (Symbol) node.sym().accept(this);</b>
<b class="fc">&nbsp;        RegularExpression regex = (RegularExpression) node.reg().accept(this);</b>
<b class="fc">&nbsp;        return symbol.copy().addPostCondition(RegularExpressionCondition.notFollow(regex)).build();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Symbol visitExcludeSymbol(IggyParseTree.ExcludeSymbol node) {
<b class="fc">&nbsp;        Symbol symbol = (Symbol) node.sym().accept(this);</b>
<b class="fc">&nbsp;        RegularExpression regex = (RegularExpression) node.reg().accept(this);</b>
<b class="fc">&nbsp;        return symbol.copy().addPostCondition(RegularExpressionCondition.notMatch(regex)).build();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Symbol visitExceptSymbol(IggyParseTree.ExceptSymbol node) {
<b class="fc">&nbsp;        Symbol symbol = (Symbol) node.sym().accept(this);</b>
<b class="fc">&nbsp;        Identifier id = (Identifier) node.id().accept(this);</b>
<b class="fc">&nbsp;        if (symbol instanceof Identifier) {</b>
<b class="fc">&nbsp;            return ((Identifier) symbol).copy().addExcept(id.getName()).build();</b>
&nbsp;        } else {
&nbsp;            // TODO: I think nonterminal calls are also allowed here, handle it.
<b class="nc">&nbsp;            throw new RuntimeException(&quot;Unexpected symbol&quot;);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Symbol visitEndOfLineSymbol(IggyParseTree.EndOfLineSymbol node) {
<b class="fc">&nbsp;        Symbol symbol = (Symbol) node.sym().accept(this);</b>
<b class="fc">&nbsp;        return symbol.copy().addPostCondition(PositionalCondition.endOfLineCondition()).build();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Symbol visitEndOfFileSymbol(IggyParseTree.EndOfFileSymbol node) {
<b class="nc">&nbsp;        Symbol symbol = (Symbol) node.sym().accept(this);</b>
<b class="nc">&nbsp;        return symbol.copy().addPostCondition(PositionalCondition.endOfFileCondition()).build();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Symbol visitIfThenElseSymbol(IggyParseTree.IfThenElseSymbol node) {
<b class="fc">&nbsp;        return IfThenElse.ifThenElse(</b>
<b class="fc">&nbsp;            (Expression) node.exp().accept(this),</b>
<b class="fc">&nbsp;            (Symbol) node.thenPart().accept(this),</b>
<b class="fc">&nbsp;            (Symbol) node.elsePart().accept(this)</b>
&nbsp;        );
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Identifier visitIdentifierSymbol(IggyParseTree.IdentifierSymbol node) {
<b class="fc">&nbsp;        return (Identifier) node.id().accept(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Terminal visitStringSymbol(IggyParseTree.StringSymbol node) {
<b class="fc">&nbsp;        String text = stripQuotes(node);</b>
<b class="fc">&nbsp;        RegularExpression regex = getCharsRegex(text);</b>
<b class="fc">&nbsp;        literals.put(text, regex);</b>
<b class="fc">&nbsp;        return new Terminal.Builder(regex)</b>
<b class="fc">&nbsp;            .setNodeType(TerminalNodeType.Literal)</b>
<b class="fc">&nbsp;            .build();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Terminal visitCharClassSymbol(IggyParseTree.CharClassSymbol node) {
<b class="fc">&nbsp;        RegularExpression regex = (RegularExpression) node.charClass().accept(this);</b>
<b class="fc">&nbsp;        return new Terminal.Builder(regex)</b>
<b class="fc">&nbsp;            .setNodeType(TerminalNodeType.Regex)</b>
<b class="fc">&nbsp;            .build();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Star visitStarSepSymbol(IggyParseTree.StarSepSymbol node) {
<b class="fc">&nbsp;        Symbol symbol = (Symbol) node.sym().accept(this);</b>
<b class="fc">&nbsp;        List&lt;Symbol&gt; seps = visit(node.sep());</b>
<b class="fc">&nbsp;        return new Star.Builder(symbol).addSeparators(seps).build();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Plus visitPlusSepSymbol(IggyParseTree.PlusSepSymbol node) {
<b class="fc">&nbsp;        Symbol symbol = (Symbol) node.sym().accept(this);</b>
<b class="fc">&nbsp;        List&lt;Symbol&gt; seps = visit(node.sep());</b>
<b class="fc">&nbsp;        return new Plus.Builder(symbol).addSeparators(seps).build();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Object visitErrorSymbol(IggyParseTree.ErrorSymbol node) {
<b class="fc">&nbsp;        return Error.getInstance();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public List&lt;Expression&gt; visitArguments(IggyParseTree.Arguments node) {
<b class="fc">&nbsp;        return visitChildren(node);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Object visitCallStatement(IggyParseTree.CallStatement node) {
<b class="fc">&nbsp;        Function&lt;Expression[], Expression.Call&gt; fun = (Function&lt;Expression[], Expression.Call&gt;) node.fun().accept(this);</b>
<b class="fc">&nbsp;        Expression[] arguments = ((List&lt;Expression&gt;) node.args().accept(this)).toArray(new Expression[]{});</b>
<b class="fc">&nbsp;        return Collections.singletonList(AST.stat(fun.apply(arguments)));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public List&lt;Statement&gt; visitBindingStatement(IggyParseTree.BindingStatement node) {
<b class="fc">&nbsp;        return visit(node.bindings());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public List&lt;Statement&gt; visitAssignBinding(IggyParseTree.AssignBinding node) {
<b class="fc">&nbsp;        List&lt;Statement&gt; statements = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;        Identifier id = (Identifier) node.varName().accept(this);</b>
<b class="fc">&nbsp;        statements.add(AST.stat(AST.assign(id.getName(), (Expression) node.exp().accept(this))));</b>
<b class="fc">&nbsp;        return statements;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public List&lt;Statement&gt; visitDeclareBinding(IggyParseTree.DeclareBinding node) {
<b class="fc">&nbsp;        List&lt;Statement&gt; statements = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;        List&lt;Object&gt; elems = visit(node.decls());</b>
<b class="fc">&nbsp;        int i = 0;</b>
<b class="fc">&nbsp;        while (i &lt; elems.size()) {</b>
<b class="fc">&nbsp;            statements.add(AST.varDeclStat(((Identifier) elems.get(i)).getName(), (Expression) elems.get(i + 1)));</b>
<b class="fc">&nbsp;            i += 2;</b>
&nbsp;        }
<b class="fc">&nbsp;        return statements;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public org.iguana.regex.Star visitStarRegex(IggyParseTree.StarRegex node) {
<b class="fc">&nbsp;        return org.iguana.regex.Star.from((RegularExpression) node.reg().accept(this));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public org.iguana.regex.Plus visitPlusRegex(IggyParseTree.PlusRegex node) {
<b class="fc">&nbsp;        return org.iguana.regex.Plus.from((RegularExpression) node.reg().accept(this));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public org.iguana.regex.Opt visitOptionRegex(IggyParseTree.OptionRegex node) {
<b class="fc">&nbsp;        return org.iguana.regex.Opt.from((RegularExpression) node.reg().accept(this));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public RegularExpression visitBracketRegex(IggyParseTree.BracketRegex node) {
<b class="nc">&nbsp;        return (RegularExpression) node.reg().accept(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public org.iguana.regex.Seq&lt;?&gt; visitSequenceRegex(IggyParseTree.SequenceRegex node) {
<b class="nc">&nbsp;        List&lt;RegularExpression&gt; list = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        list.add((RegularExpression) node.first().accept(this));</b>
<b class="nc">&nbsp;        list.addAll(visit(node.rest()));</b>
<b class="nc">&nbsp;        return org.iguana.regex.Seq.from(list);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public org.iguana.regex.Alt&lt;?&gt; visitAlternationRegex(IggyParseTree.AlternationRegex node) {
<b class="fc">&nbsp;        List&lt;RegularExpression&gt; first = visit(node.first());</b>
<b class="fc">&nbsp;        List&lt;List&lt;RegularExpression&gt;&gt; rest = visit(node.rest());</b>
<b class="fc">&nbsp;        List&lt;RegularExpression&gt; res = new ArrayList&lt;&gt;(first);</b>
<b class="fc">&nbsp;        res.addAll(rest.stream().map(l -&gt; {</b>
<b class="fc">&nbsp;            if (l.size() == 1) return l.get(0);</b>
<b class="nc">&nbsp;            else return Seq.from(l);</b>
<b class="fc">&nbsp;        }).collect(Collectors.toList()));</b>
<b class="fc">&nbsp;        return org.iguana.regex.Alt.from(res);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public org.iguana.regex.Reference visitNontRegex(IggyParseTree.NontRegex node) {
<b class="fc">&nbsp;        Identifier id = (Identifier) node.name().accept(this);</b>
<b class="fc">&nbsp;        return org.iguana.regex.Reference.from(id.getName());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public org.iguana.regex.Alt&lt;RegularExpression&gt; visitCharClassRegex(IggyParseTree.CharClassRegex node) {
<b class="fc">&nbsp;        return visit(node.charClass());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public RegularExpression visitStringRegex(IggyParseTree.StringRegex node) {
<b class="fc">&nbsp;        return getCharsRegex(stripQuotes(node));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public org.iguana.regex.Alt&lt;?&gt; visitCharsCharClass(IggyParseTree.CharsCharClass node) {
<b class="fc">&nbsp;        return org.iguana.regex.Alt.from((List&lt;RegularExpression&gt;) node.ranges().accept(this));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public org.iguana.regex.Alt&lt;?&gt; visitNotCharsCharClass(IggyParseTree.NotCharsCharClass node) {
<b class="fc">&nbsp;        return org.iguana.regex.Alt.not((List&lt;RegularExpression&gt;) node.ranges().accept(this));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public CharRange visitRangeRange(IggyParseTree.RangeRange node) {
<b class="fc">&nbsp;        int start = getRangeChar(node.first().getText());</b>
<b class="fc">&nbsp;        int end = getRangeChar(node.second().getText());</b>
<b class="fc">&nbsp;        return CharRange.in(start, end);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Char visitCharacterRange(IggyParseTree.CharacterRange node) {
<b class="fc">&nbsp;        int c = getRangeChar(node.range().getText());</b>
<b class="fc">&nbsp;        return Char.from(c);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Expression.Call visitCallExpression(IggyParseTree.CallExpression node) {
<b class="fc">&nbsp;        Function&lt;Expression[], Expression.Call&gt; fun = (Function&lt;Expression[], Expression.Call&gt;) node.fun().accept(this);</b>
<b class="fc">&nbsp;        Expression[] arguments = ((List&lt;Expression&gt;) node.args().accept(this)).toArray(new Expression[]{});</b>
<b class="fc">&nbsp;        return fun.apply(arguments);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Expression.Not visitNotExpression(IggyParseTree.NotExpression node) {
<b class="fc">&nbsp;        Expression exp = visit(node.exp());</b>
<b class="fc">&nbsp;        return AST.not(exp);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Expression.Multiply visitMultiplicationExpression(IggyParseTree.MultiplicationExpression node) {
<b class="nc">&nbsp;        Expression lhs = visit(node.lhs());</b>
<b class="nc">&nbsp;        Expression rhs = visit(node.rhs());</b>
<b class="nc">&nbsp;        return AST.multiply(lhs, rhs);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Expression.Divide visitDivisionExpression(IggyParseTree.DivisionExpression node) {
<b class="nc">&nbsp;        Expression lhs = visit(node.lhs());</b>
<b class="nc">&nbsp;        Expression rhs = visit(node.rhs());</b>
<b class="nc">&nbsp;        return AST.divide(lhs, rhs);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Expression.Add visitAdditionExpression(IggyParseTree.AdditionExpression node) {
<b class="fc">&nbsp;        Expression lhs = visit(node.lhs());</b>
<b class="fc">&nbsp;        Expression rhs = visit(node.rhs());</b>
<b class="fc">&nbsp;        return AST.add(lhs, rhs);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Expression.Subtract visitSubtractionExpression(IggyParseTree.SubtractionExpression node) {
<b class="nc">&nbsp;        Expression lhs = visit(node.lhs());</b>
<b class="nc">&nbsp;        Expression rhs = visit(node.rhs());</b>
<b class="nc">&nbsp;        return AST.subtract(lhs, rhs);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Expression.GreaterThanEqual visitGreaterEqExpression(IggyParseTree.GreaterEqExpression node) {
<b class="fc">&nbsp;        Expression lhs = visit(node.lhs());</b>
<b class="fc">&nbsp;        Expression rhs = visit(node.rhs());</b>
<b class="fc">&nbsp;        return AST.greaterEq(lhs, rhs);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Expression.LessThanEqual visitLessEqExpression(IggyParseTree.LessEqExpression node) {
<b class="nc">&nbsp;        Expression lhs = visit(node.lhs());</b>
<b class="nc">&nbsp;        Expression rhs = visit(node.rhs());</b>
<b class="nc">&nbsp;        return AST.lessEq(lhs, rhs);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Expression.Greater visitGreaterExpression(IggyParseTree.GreaterExpression node) {
<b class="fc">&nbsp;        Expression lhs = visit(node.lhs());</b>
<b class="fc">&nbsp;        Expression rhs = visit(node.rhs());</b>
<b class="fc">&nbsp;        return AST.greater(lhs, rhs);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Expression.Less visitLessExpression(IggyParseTree.LessExpression node) {
<b class="nc">&nbsp;        Expression lhs = visit(node.lhs());</b>
<b class="nc">&nbsp;        Expression rhs = visit(node.rhs());</b>
<b class="nc">&nbsp;        return AST.less(lhs, rhs);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Expression.Equal visitEqualExpression(IggyParseTree.EqualExpression node) {
<b class="fc">&nbsp;        Expression lhs = visit(node.lhs());</b>
<b class="fc">&nbsp;        Expression rhs = visit(node.rhs());</b>
<b class="fc">&nbsp;        return AST.equal(lhs, rhs);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Expression.NotEqual visitNotEqualExpression(IggyParseTree.NotEqualExpression node) {
<b class="nc">&nbsp;        Expression lhs = visit(node.lhs());</b>
<b class="nc">&nbsp;        Expression rhs = visit(node.rhs());</b>
<b class="nc">&nbsp;        return AST.notEqual(lhs, rhs);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Expression.And visitAndExpression(IggyParseTree.AndExpression node) {
<b class="fc">&nbsp;        Expression lhs = visit(node.lhs());</b>
<b class="fc">&nbsp;        Expression rhs = visit(node.rhs());</b>
<b class="fc">&nbsp;        return AST.and(lhs, rhs);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Expression.Or visitOrExpression(IggyParseTree.OrExpression node) {
<b class="fc">&nbsp;        Expression lhs = visit(node.lhs());</b>
<b class="fc">&nbsp;        Expression rhs = visit(node.rhs());</b>
<b class="fc">&nbsp;        return AST.or(lhs, rhs);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Expression.LeftExtent visitLExtentExpression(IggyParseTree.LExtentExpression node) {
<b class="fc">&nbsp;        String l = node.id().getText();</b>
<b class="fc">&nbsp;        return AST.lExt(l);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Expression.RightExtent visitRExtentExpression(IggyParseTree.RExtentExpression node) {
<b class="fc">&nbsp;        String r = node.id().getText();</b>
<b class="fc">&nbsp;        return AST.rExt(r);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Expression.Yield visitYieldExpression(IggyParseTree.YieldExpression node) {
<b class="fc">&nbsp;        String yield = node.id().getText();</b>
<b class="fc">&nbsp;        return AST.yield(yield);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Expression.Val visitValExpression(IggyParseTree.ValExpression node) {
<b class="fc">&nbsp;        String val = node.id().getText();</b>
<b class="fc">&nbsp;        return AST.val(val);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Expression.Name visitNameExpression(IggyParseTree.NameExpression node) {
<b class="fc">&nbsp;        return AST.var((node.varName().getText()));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Expression.Integer visitNumberExpression(IggyParseTree.NumberExpression node) {
<b class="fc">&nbsp;        return AST.integer(Integer.parseInt(node.number().getText()));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Expression visitBracketExpression(IggyParseTree.BracketExpression node) {
<b class="fc">&nbsp;        return (Expression) node.exp().accept(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Expression visitReturnExpression(IggyParseTree.ReturnExpression node) {
<b class="fc">&nbsp;        return (Expression) node.exp().accept(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Identifier visitVarName(IggyParseTree.VarName node) {
<b class="fc">&nbsp;        return (Identifier) node.id().accept(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String visitLabel(IggyParseTree.Label node) {
<b class="fc">&nbsp;        Identifier id = (Identifier) node.id().accept(this);</b>
<b class="fc">&nbsp;        return id.getName();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Object visitLayout(IggyParseTree.Layout node) {
<b class="nc">&nbsp;        throw new RuntimeException(&quot;Layout is handled in ContextFreeRule, this method should not be called&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Identifier visitName(IggyParseTree.Name node) {
<b class="fc">&nbsp;        return (Identifier) node.id().accept(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Function&lt;Expression[], Expression.Call&gt; visitPrintlnFunName(IggyParseTree.PrintlnFunName node) {
<b class="nc">&nbsp;        return AST::println;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Function&lt;Expression[], Expression.Call&gt; visitIndentFunName(IggyParseTree.IndentFunName node) {
<b class="fc">&nbsp;        return AST::indent;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Function&lt;Expression[], Expression.Call&gt; visitAssertFunName(IggyParseTree.AssertFunName node) {
<b class="fc">&nbsp;        return AST::assertion;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Function&lt;Expression[], Expression.Call&gt; visitSetFunName(IggyParseTree.SetFunName node) {
<b class="fc">&nbsp;        return AST::set;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Function&lt;Expression[], Expression.Call&gt; visitContainsFunName(IggyParseTree.ContainsFunName node) {
<b class="fc">&nbsp;        return AST::contains;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Function&lt;Expression[], Expression.Call&gt; visitPutFunName(IggyParseTree.PutFunName node) {
<b class="fc">&nbsp;        return AST::put;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Identifier visitIdentifier(IggyParseTree.Identifier node) {
<b class="fc">&nbsp;        return Identifier.fromName(node.getText());</b>
&nbsp;    }
&nbsp;
&nbsp;    private &lt;T&gt; T visit(ParseTreeNode node) {
<b class="fc">&nbsp;        return (T) node.accept(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    private static RegularExpression getRegex(List&lt;List&lt;RegularExpression&gt;&gt; listOfList) {
<b class="fc">&nbsp;        if (listOfList.size() == 1) {</b>
<b class="fc">&nbsp;            return getRegexOfList(listOfList.get(0));</b>
&nbsp;        }
<b class="fc">&nbsp;        org.iguana.regex.Alt.Builder&lt;RegularExpression&gt; builder = new org.iguana.regex.Alt.Builder&lt;&gt;();</b>
<b class="fc">&nbsp;        for (List&lt;RegularExpression&gt; list : listOfList) {</b>
<b class="fc">&nbsp;            builder.add(getRegexOfList(list));</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return builder.build();</b>
&nbsp;    }
&nbsp;
&nbsp;    private static RegularExpression getRegexOfList(List&lt;RegularExpression&gt; list) {
<b class="fc">&nbsp;        if (list.size() == 1) {</b>
<b class="fc">&nbsp;            return list.get(0);</b>
&nbsp;        }
<b class="fc">&nbsp;        return org.iguana.regex.Seq.from(list);</b>
&nbsp;    }
&nbsp;
&nbsp;    private static Associativity getAssociativity(ParseTreeNode node) {
<b class="fc">&nbsp;        switch (node.getText()) {</b>
&nbsp;            case &quot;left&quot;:
<b class="fc">&nbsp;                return Associativity.LEFT;</b>
&nbsp;            case &quot;right&quot;:
<b class="fc">&nbsp;                return Associativity.RIGHT;</b>
&nbsp;            case &quot;non-assoc&quot;:
<b class="fc">&nbsp;                return Associativity.NON_ASSOC;</b>
&nbsp;            default:
<b class="nc">&nbsp;                return Associativity.UNDEFINED;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static String stripQuotes(ParseTreeNode node) {
<b class="fc">&nbsp;        return node.getText().substring(1, node.getText().length() - 1);</b>
&nbsp;    }
&nbsp;
&nbsp;    private static int[] getChars(String s) {
<b class="fc">&nbsp;        int i = 0;</b>
<b class="fc">&nbsp;        int j = 0;</b>
<b class="fc">&nbsp;        int[] chars = new int[s.length()];</b>
<b class="fc">&nbsp;        while (i &lt; s.length()) {</b>
<b class="fc">&nbsp;            if (s.charAt(i) == &#39;\\&#39;) {</b>
<b class="fc">&nbsp;                switch (s.charAt(i + 1)) {</b>
&nbsp;                    case &#39;n&#39;:
<b class="nc">&nbsp;                        chars[j++] = &#39;\n&#39;;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case &#39;r&#39;:
<b class="nc">&nbsp;                        chars[j++] = &#39;\r&#39;;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case &#39;t&#39;:
<b class="nc">&nbsp;                        chars[j++] = &#39;\t&#39;;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case &#39;f&#39;:
<b class="nc">&nbsp;                        chars[j++] = &#39;\f&#39;;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case &#39; &#39;:
<b class="nc">&nbsp;                        chars[j++] = &#39; &#39;;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case &#39;\\&#39;:
<b class="fc">&nbsp;                        chars[j++] = &#39;\\&#39;;</b>
<b class="fc">&nbsp;                        break;</b>
&nbsp;                    case &#39;\&#39;&#39;:
<b class="fc">&nbsp;                        chars[j++] = &#39;\&#39;&#39;;</b>
<b class="fc">&nbsp;                        break;</b>
&nbsp;                    case &#39;&quot;&#39;:
<b class="fc">&nbsp;                        chars[j++] = &#39;&quot;&#39;;</b>
&nbsp;                        break;
&nbsp;                }
<b class="fc">&nbsp;                i += 2;</b>
&nbsp;            } else {
<b class="fc">&nbsp;                chars[j++] = s.charAt(i++);</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        return Arrays.copyOf(chars, j);</b>
&nbsp;    }
&nbsp;
&nbsp;    private static RegularExpression getCharsRegex(String s) {
<b class="fc">&nbsp;        int[] chars = getChars(s);</b>
<b class="fc">&nbsp;        if (chars.length == 1) {</b>
<b class="fc">&nbsp;            return Char.from(chars[0]);</b>
&nbsp;        }
<b class="fc">&nbsp;        return Seq.from(chars);</b>
&nbsp;    }
&nbsp;
&nbsp;    private static int getRangeChar(String s) {
<b class="fc">&nbsp;        switch (s) {</b>
&nbsp;            case &quot;\\n&quot;:
<b class="fc">&nbsp;                return &#39;\n&#39;;</b>
&nbsp;            case &quot;\\r&quot;:
<b class="fc">&nbsp;                return &#39;\r&#39;;</b>
&nbsp;            case &quot;\\t&quot;:
<b class="fc">&nbsp;                return &#39;\t&#39;;</b>
&nbsp;            case &quot;\\f&quot;:
<b class="fc">&nbsp;                return &#39;\f&#39;;</b>
&nbsp;            case &quot;\\&#39;&quot;:
<b class="nc">&nbsp;                return &#39;\&#39;&#39;;</b>
&nbsp;            case &quot;\\\&quot;&quot;:
<b class="nc">&nbsp;                return &#39;\&quot;&#39;;</b>
&nbsp;            case &quot;\\ &quot;:
<b class="fc">&nbsp;                return &#39; &#39;;</b>
&nbsp;            case &quot;\\[&quot;:
<b class="fc">&nbsp;                return &#39;[&#39;;</b>
&nbsp;            case &quot;\\]&quot;:
<b class="fc">&nbsp;                return &#39;]&#39;;</b>
&nbsp;            case &quot;\\-&quot;:
<b class="fc">&nbsp;                return &#39;-&#39;;</b>
&nbsp;        }
<b class="fc">&nbsp;        return s.charAt(0);</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 17:08</div>
</div>
</body>
</html>
