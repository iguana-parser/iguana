


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > DesugarAlignAndOffside</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.iguana.grammar.transformation</a>
</div>

<h1>Coverage Summary for Class: DesugarAlignAndOffside (org.iguana.grammar.transformation)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">DesugarAlignAndOffside</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (38/38)
  </span>
</td>
</tr>
  <tr>
    <td class="name">DesugarAlignAndOffside$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DesugarAlignAndOffside$DesugarAlignAndOffsideVisitor</td>
<td class="coverageStat">
  <span class="percent">
    76.9%
  </span>
  <span class="absValue">
    (20/26)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    67.5%
  </span>
  <span class="absValue">
    (162/240)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DesugarAlignAndOffside$FindOffsidesVisitor</td>
<td class="coverageStat">
  <span class="percent">
    45.5%
  </span>
  <span class="absValue">
    (10/22)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    41.9%
  </span>
  <span class="absValue">
    (18/43)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    64.8%
  </span>
  <span class="absValue">
    (35/54)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    67.7%
  </span>
  <span class="absValue">
    (218/322)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright (c) 2015, Ali Afroozeh and Anastasia Izmaylova, Centrum Wiskunde &amp; Informatica (CWI)
&nbsp; * All rights reserved.
&nbsp; *
&nbsp; * Redistribution and use in source and binary forms, with or without
&nbsp; * modification, are permitted provided that the following conditions are met:
&nbsp; *
&nbsp; * 1. Redistributions of source code must retain the above copyright notice, this
&nbsp; *    list of conditions and the following disclaimer.
&nbsp; *
&nbsp; * 2. Redistributions in binary form must reproduce the above copyright notice, this
&nbsp; *    list of conditions and the following disclaimer in the documentation and/or
&nbsp; *    other materials provided with the distribution.
&nbsp; *
&nbsp; * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
&nbsp; * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
&nbsp; * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
&nbsp; * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
&nbsp; * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
&nbsp; * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
&nbsp; * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
&nbsp; * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
&nbsp; * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
&nbsp; * OF SUCH DAMAGE.
&nbsp; *
&nbsp; */
&nbsp;
&nbsp;package org.iguana.grammar.transformation;
&nbsp;
&nbsp;import org.iguana.datadependent.ast.Expression;
&nbsp;import org.iguana.grammar.condition.Condition;
&nbsp;import org.iguana.grammar.operations.ReachabilityGraph;
&nbsp;import org.iguana.grammar.runtime.RuntimeGrammar;
&nbsp;import org.iguana.grammar.runtime.RuntimeRule;
&nbsp;import org.iguana.grammar.symbol.Align;
&nbsp;import org.iguana.grammar.symbol.Alt;
&nbsp;import org.iguana.grammar.symbol.Block;
&nbsp;import org.iguana.grammar.symbol.Code;
&nbsp;import org.iguana.grammar.symbol.Conditional;
&nbsp;import org.iguana.grammar.symbol.Error;
&nbsp;import org.iguana.grammar.symbol.Group;
&nbsp;import org.iguana.grammar.symbol.IfThen;
&nbsp;import org.iguana.grammar.symbol.IfThenElse;
&nbsp;import org.iguana.grammar.symbol.Ignore;
&nbsp;import org.iguana.grammar.symbol.Nonterminal;
&nbsp;import org.iguana.grammar.symbol.Offside;
&nbsp;import org.iguana.grammar.symbol.Opt;
&nbsp;import org.iguana.grammar.symbol.Plus;
&nbsp;import org.iguana.grammar.symbol.Return;
&nbsp;import org.iguana.grammar.symbol.Star;
&nbsp;import org.iguana.grammar.symbol.Start;
&nbsp;import org.iguana.grammar.symbol.Symbol;
&nbsp;import org.iguana.grammar.symbol.Terminal;
&nbsp;import org.iguana.grammar.symbol.While;
&nbsp;import org.iguana.traversal.ISymbolVisitor;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.LinkedHashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;
&nbsp;import static org.iguana.datadependent.ast.AST.andIndent;
&nbsp;import static org.iguana.datadependent.ast.AST.equal;
&nbsp;import static org.iguana.datadependent.ast.AST.indent;
&nbsp;import static org.iguana.datadependent.ast.AST.integer;
&nbsp;import static org.iguana.datadependent.ast.AST.lExt;
&nbsp;import static org.iguana.datadependent.ast.AST.orIndent;
&nbsp;import static org.iguana.datadependent.ast.AST.var;
&nbsp;import static org.iguana.grammar.condition.DataDependentCondition.predicate;
&nbsp;
<b class="fc">&nbsp;public class DesugarAlignAndOffside implements GrammarTransformation {</b>
&nbsp;
&nbsp;    private Map&lt;Nonterminal, Set&lt;Nonterminal&gt;&gt; reachabilityGraph;
&nbsp;
&nbsp;    private Set&lt;String&gt; offsided;
&nbsp;
<b class="fc">&nbsp;    private boolean doAlign = true;</b>
&nbsp;
&nbsp;    public void doAlign() {
<b class="fc">&nbsp;        this.doAlign = true;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void doOffside() {
<b class="fc">&nbsp;        this.doAlign = false;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public RuntimeGrammar transform(RuntimeGrammar grammar) {
&nbsp;
<b class="fc">&nbsp;        if (doAlign) {</b>
<b class="fc">&nbsp;            DesugarAlignAndOffsideVisitor desugarAligns = new DesugarAlignAndOffsideVisitor(new HashSet&lt;&gt;());</b>
<b class="fc">&nbsp;            desugarAligns.doAlign(doAlign);</b>
&nbsp;
<b class="fc">&nbsp;            Set&lt;RuntimeRule&gt; rules = new LinkedHashSet&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;            for (RuntimeRule rule : grammar.getRules())</b>
<b class="fc">&nbsp;                rules.add(desugarAligns.transform(rule, grammar.getLayout()));</b>
&nbsp;
<b class="fc">&nbsp;            return RuntimeGrammar.builder().addRules(rules)</b>
<b class="fc">&nbsp;                .setLayout(grammar.getLayout())</b>
<b class="fc">&nbsp;                .setStartSymbols(grammar.getStartSymbols())</b>
<b class="fc">&nbsp;                .setEbnfLefts(grammar.getEBNFLefts())</b>
<b class="fc">&nbsp;                .setEbnfRights(grammar.getEBNFRights())</b>
<b class="fc">&nbsp;                .setGlobals(grammar.getGlobals())</b>
<b class="fc">&nbsp;                .setRegularExpressionDefinitions(grammar.getRegularExpressionDefinitions())</b>
<b class="fc">&nbsp;                .build();</b>
&nbsp;        }
&nbsp;
&nbsp;        // After EBNF translation
<b class="fc">&nbsp;        reachabilityGraph = new ReachabilityGraph(grammar).getReachabilityGraph();</b>
&nbsp;
<b class="fc">&nbsp;        FindOffsidesVisitor findOffsides = new FindOffsidesVisitor();</b>
<b class="fc">&nbsp;        findOffsides.find(grammar);</b>
<b class="fc">&nbsp;        offsided = findOffsides.getOffsides();</b>
&nbsp;
<b class="fc">&nbsp;        reachabilityGraph.entrySet().forEach(e -&gt; {</b>
<b class="fc">&nbsp;            if (offsided.contains(e.getKey().getName())) {</b>
<b class="fc">&nbsp;                e.getValue().forEach(n -&gt; offsided.add(n.getName()));</b>
&nbsp;            }
&nbsp;        });
&nbsp;
<b class="fc">&nbsp;        DesugarAlignAndOffsideVisitor desugarOffsides = new DesugarAlignAndOffsideVisitor(offsided);</b>
<b class="fc">&nbsp;        desugarOffsides.doAlign(doAlign);</b>
&nbsp;
<b class="fc">&nbsp;        Set&lt;RuntimeRule&gt; rules = new LinkedHashSet&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;        for (RuntimeRule rule : grammar.getRules())</b>
<b class="fc">&nbsp;            rules.add(desugarOffsides.transform(rule, grammar.getLayout()));</b>
&nbsp;
<b class="fc">&nbsp;        return RuntimeGrammar.builder().addRules(rules)</b>
<b class="fc">&nbsp;            .setLayout(grammar.getLayout())</b>
<b class="fc">&nbsp;            .setStartSymbols(grammar.getStartSymbols())</b>
<b class="fc">&nbsp;            .setGlobals(grammar.getGlobals())</b>
<b class="fc">&nbsp;            .setEbnfLefts(grammar.getEBNFLefts())</b>
<b class="fc">&nbsp;            .setEbnfRights(grammar.getEBNFRights())</b>
<b class="fc">&nbsp;            .setRegularExpressionDefinitions(grammar.getRegularExpressionDefinitions())</b>
<b class="fc">&nbsp;            .build();</b>
&nbsp;    }
&nbsp;
&nbsp;    private static class DesugarAlignAndOffsideVisitor implements ISymbolVisitor&lt;Symbol&gt; {
&nbsp;
&nbsp;        private static final String ind = &quot;ind&quot;;
&nbsp;        private static final String first = &quot;fst&quot;;
&nbsp;        private static final String index = &quot;i&quot;;
&nbsp;
<b class="fc">&nbsp;        private static final Expression ind_exp = var(ind);</b>
<b class="fc">&nbsp;        private static final Expression first_exp = var(first);</b>
<b class="fc">&nbsp;        private static final Expression index_exp = var(index);</b>
&nbsp;
&nbsp;        private static final String l_align = &quot;a&quot;;
&nbsp;        private static final String l_offside = &quot;o&quot;;
&nbsp;
&nbsp;        private boolean doAlign;
&nbsp;
&nbsp;        private final Set&lt;String&gt; offsided;
&nbsp;
&nbsp;        private RuntimeRule rule;
&nbsp;        private Symbol layout;
&nbsp;
&nbsp;        private boolean isOffsided;
&nbsp;
&nbsp;        private int i;
&nbsp;
<b class="fc">&nbsp;        DesugarAlignAndOffsideVisitor(Set&lt;String&gt; offsided) {</b>
<b class="fc">&nbsp;            this.offsided = offsided;</b>
&nbsp;        }
&nbsp;
&nbsp;        public void doAlign(boolean doAlign) {
<b class="fc">&nbsp;            this.doAlign = doAlign;</b>
&nbsp;        }
&nbsp;
&nbsp;        public RuntimeRule transform(RuntimeRule rule, Symbol layout) {
<b class="fc">&nbsp;            this.rule = rule;</b>
<b class="fc">&nbsp;            this.layout = layout;</b>
<b class="fc">&nbsp;            this.isOffsided = false;</b>
<b class="fc">&nbsp;            i = 0;</b>
&nbsp;
<b class="fc">&nbsp;            if (doAlign) {</b>
<b class="fc">&nbsp;                List&lt;Symbol&gt; symbols = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;                RuntimeRule.Builder builder = rule.copy();</b>
&nbsp;
<b class="fc">&nbsp;                if (this.rule.getBody() != null) {</b>
&nbsp;
<b class="fc">&nbsp;                    builder = builder.setSymbols(symbols);</b>
&nbsp;
<b class="fc">&nbsp;                    for (Symbol symbol : this.rule.getBody()) {</b>
&nbsp;//                        if (symbol instanceof Align) {
&nbsp;//                            Symbol sym = ((Align) symbol).getSymbol();
&nbsp;//                            if (sym instanceof Plus || sym instanceof Star || sym instanceof Sequence) {
&nbsp;//                                Symbol s = symbol.accept(this);
&nbsp;//                                String l3 = l_align + i++;
&nbsp;//                                Nonterminal longest = getLayout().copyBuilder().setLabel(l3)
&nbsp;//                                                        .addPostCondition(predicate(or(endOfFile(rExt(l3)),
&nbsp;//                                                        lessEq(indent(rExt(l3)), indent(lExt(s.getLabel()))))))
&nbsp;//                                                        .build();
&nbsp;//                                symbols.add(s);
&nbsp;//                                symbols.add(longest);
&nbsp;//                                continue;
&nbsp;//                            }
&nbsp;//                        }
<b class="fc">&nbsp;                        symbols.add(symbol.accept(this));</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                return builder.build();</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            isOffsided = offsided.contains(this.rule.getHead().getName());</b>
&nbsp;
&nbsp;            RuntimeRule.Builder builder;
&nbsp;
<b class="fc">&nbsp;            if (isOffsided)</b>
<b class="fc">&nbsp;                builder = rule.copyBuilderButWithHead(rule.getHead().copy().addParameters(index, ind, first).build());</b>
&nbsp;            else
<b class="fc">&nbsp;                builder = rule.copy();</b>
&nbsp;
<b class="fc">&nbsp;            List&lt;Symbol&gt; symbols = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;            if (this.rule.getBody() != null) {</b>
&nbsp;
<b class="fc">&nbsp;                builder = builder.setSymbols(symbols);</b>
&nbsp;
<b class="fc">&nbsp;                for (Symbol symbol : this.rule.getBody()) {</b>
<b class="fc">&nbsp;                    symbols.add(symbol.accept(this));</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            return builder.build();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Symbol visit(Align symbol) {
&nbsp;
<b class="fc">&nbsp;            if (doAlign) {</b>
<b class="fc">&nbsp;                Symbol sym = symbol.getSymbol().accept(this);</b>
&nbsp;
<b class="fc">&nbsp;                if (sym instanceof Plus) {</b>
<b class="fc">&nbsp;                    String l1 = getLabel(symbol, sym);</b>
&nbsp;
<b class="fc">&nbsp;                    Plus plus = (Plus) sym;</b>
&nbsp;
<b class="fc">&nbsp;                    Symbol s = plus.getSymbol();</b>
<b class="fc">&nbsp;                    String l2 = s.getLabel() != null ? s.getLabel() : l_align + i++; // TODO: conflicting labels</b>
&nbsp;
<b class="fc">&nbsp;                    s = getSymbol(s, predicate(equal(indent(lExt(l2)), indent(lExt(l1)))), l2);</b>
&nbsp;
<b class="fc">&nbsp;                    return new Plus.Builder(s).addSeparators(plus.getSeparators()).setLabel(l1).addConditions(plus)</b>
<b class="fc">&nbsp;                        .addConditions(symbol).build();</b>
&nbsp;
<b class="fc">&nbsp;                } else if (sym instanceof Star) {</b>
<b class="fc">&nbsp;                    String l1 = getLabel(symbol, sym);</b>
&nbsp;
<b class="fc">&nbsp;                    Star star = (Star) sym;</b>
&nbsp;
<b class="fc">&nbsp;                    Symbol s = star.getSymbol();</b>
<b class="fc">&nbsp;                    String l2 = s.getLabel() != null ? s.getLabel() : l_align + i++; // TODO: conflicting labels</b>
&nbsp;
<b class="fc">&nbsp;                    s = getSymbol(s, predicate(equal(indent(lExt(l2)), indent(lExt(l1)))), l2);</b>
&nbsp;
<b class="fc">&nbsp;                    return new Star.Builder(s).addSeparators(star.getSeparators()).setLabel(l1).addConditions(star)</b>
<b class="fc">&nbsp;                        .addConditions(symbol).build();</b>
<b class="nc">&nbsp;                } else if (sym instanceof Group) {</b>
<b class="nc">&nbsp;                    String l1 = getLabel(symbol, sym);</b>
&nbsp;
&nbsp;                    @SuppressWarnings(&quot;unchecked&quot;)
<b class="nc">&nbsp;                    Group seq = (Group) sym;</b>
&nbsp;
<b class="nc">&nbsp;                    List&lt;Symbol&gt; symbols = seq.getSymbols();</b>
<b class="nc">&nbsp;                    List&lt;Symbol&gt; syms = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;                    for (Symbol s : symbols) {</b>
<b class="nc">&nbsp;                        String l2 = s.getLabel() != null ? s.getLabel() : l_align + i++; // TODO: conflicting labels</b>
<b class="nc">&nbsp;                        syms.add(getSymbol(s, predicate(equal(indent(lExt(l2)), indent(lExt(l1)))), l2));</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;
<b class="nc">&nbsp;                    return new Group.Builder(syms).setLabel(l1)</b>
<b class="nc">&nbsp;                        .addConditions(seq).addConditions(symbol).build();</b>
&nbsp;                } else
<b class="nc">&nbsp;                    return sym;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            Symbol sym = symbol.getSymbol().accept(this);</b>
&nbsp;
<b class="nc">&nbsp;            return sym == symbol.getSymbol() ? symbol</b>
<b class="nc">&nbsp;                : new Align.Builder(sym).setLabel(symbol.getLabel()).addConditions(symbol).build();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Symbol visit(Block symbol) {
<b class="nc">&nbsp;            List&lt;Symbol&gt; symbols = symbol.getSymbols();</b>
<b class="nc">&nbsp;            Symbol[] syms = new Symbol[symbols.size()];</b>
&nbsp;
<b class="nc">&nbsp;            int j = 0;</b>
<b class="nc">&nbsp;            boolean modified = false;</b>
<b class="nc">&nbsp;            for (Symbol sym : symbols) {</b>
&nbsp;
<b class="nc">&nbsp;                syms[j] = sym.accept(this);</b>
<b class="nc">&nbsp;                if (sym != syms[j])</b>
<b class="nc">&nbsp;                    modified |= true;</b>
<b class="nc">&nbsp;                j++;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            return modified ? new Block.Builder(syms).setLabel(symbol.getLabel()).addConditions(symbol).build()</b>
<b class="nc">&nbsp;                : symbol;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Symbol visit(Code symbol) {
<b class="fc">&nbsp;            Symbol sym = symbol.getSymbol().accept(this);</b>
<b class="fc">&nbsp;            if (sym == symbol.getSymbol())</b>
<b class="fc">&nbsp;                return symbol;</b>
&nbsp;
<b class="nc">&nbsp;            return new Code.Builder(sym, symbol.getStatements()).setLabel(symbol.getLabel()).addConditions(symbol)</b>
<b class="nc">&nbsp;                .build();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Symbol visit(Error error) {
<b class="fc">&nbsp;            return error;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Symbol visit(Conditional symbol) {
<b class="nc">&nbsp;            Symbol sym = symbol.getSymbol().accept(this);</b>
<b class="nc">&nbsp;            if (sym == symbol.getSymbol())</b>
<b class="nc">&nbsp;                return symbol;</b>
&nbsp;
<b class="nc">&nbsp;            return new Conditional.Builder(sym, symbol.getExpression()).setLabel(symbol.getLabel())</b>
<b class="nc">&nbsp;                .addConditions(symbol).build();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Symbol visit(IfThen symbol) {
<b class="nc">&nbsp;            Symbol sym = symbol.getThenPart().accept(this);</b>
<b class="nc">&nbsp;            if (sym == symbol.getThenPart())</b>
<b class="nc">&nbsp;                return symbol;</b>
&nbsp;
<b class="nc">&nbsp;            return new IfThen.Builder(symbol.getExpression(), sym).setLabel(symbol.getLabel()).addConditions(symbol)</b>
<b class="nc">&nbsp;                .build();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Symbol visit(IfThenElse symbol) {
<b class="fc">&nbsp;            Symbol thenPart = symbol.getThenPart().accept(this);</b>
<b class="fc">&nbsp;            Symbol elsePart = symbol.getElsePart().accept(this);</b>
<b class="fc">&nbsp;            if (thenPart == symbol.getThenPart()</b>
<b class="fc">&nbsp;                &amp;&amp; elsePart == symbol.getElsePart())</b>
<b class="fc">&nbsp;                return symbol;</b>
&nbsp;
<b class="nc">&nbsp;            return new IfThenElse.Builder(symbol.getExpression(), thenPart, elsePart).setLabel(symbol.getLabel())</b>
<b class="nc">&nbsp;                .addConditions(symbol).build();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Symbol visit(Nonterminal symbol) {
&nbsp;            // The rule has a parameter for indentation, and therefore, also all reachable nonterminals
<b class="fc">&nbsp;            if (isOffsided &amp;&amp; offsided.contains(symbol.getName())) {</b>
<b class="fc">&nbsp;                String l = symbol.getLabel() != null ? symbol.getLabel() : l_offside + i++;</b>
<b class="fc">&nbsp;                return symbol.copy().apply(// (fst &amp; (lExt - index == 0)) == 1? index : 0 or fst == 1? index : 0</b>
&nbsp;                                           //     after non-nullable (0 as only indentation will be needed)
<b class="fc">&nbsp;                                           andIndent(index_exp, first_exp, lExt(l), true),</b>
&nbsp;                                           ind_exp,
&nbsp;                                           // fst &amp; (lExt - index == 0) or 0 after non-nullable
<b class="fc">&nbsp;                                           andIndent(index_exp, first_exp, lExt(l)))</b>
<b class="fc">&nbsp;                    .setLabel(l).build();</b>
<b class="fc">&nbsp;            } else if (offsided.contains(symbol.getName())) // A ::= offside B; B ::= D; C ::= B or C ::= D</b>
<b class="fc">&nbsp;                return symbol.copy().apply(integer(0), integer(0), integer(0)).build();</b>
&nbsp;            else
<b class="fc">&nbsp;                return symbol;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Symbol visit(Ignore symbol) {
<b class="fc">&nbsp;            if (doAlign) {</b>
<b class="fc">&nbsp;                Symbol sym = symbol.getSymbol().accept(this);</b>
&nbsp;
<b class="fc">&nbsp;                return sym == symbol.getSymbol() ? symbol</b>
<b class="nc">&nbsp;                    : new Ignore.Builder(sym).setLabel(symbol.getLabel()).addConditions(symbol).build();</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            Symbol sym = symbol.getSymbol();</b>
&nbsp;
<b class="fc">&nbsp;            if (sym instanceof Nonterminal) {</b>
<b class="nc">&nbsp;                Nonterminal s = (Nonterminal) sym;</b>
&nbsp;
<b class="nc">&nbsp;                if (offsided.contains(s.getName())) { // TODO: too general</b>
<b class="nc">&nbsp;                    return s.copy()</b>
<b class="nc">&nbsp;                        .apply(integer(0), integer(0), integer(0))</b>
<b class="nc">&nbsp;                        .addConditions(symbol)</b>
<b class="nc">&nbsp;                        .addConditions(sym)</b>
<b class="nc">&nbsp;                        .build();</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // Otherwise, ignore &#39;ignore&#39;
<b class="fc">&nbsp;            sym = sym.accept(this);</b>
<b class="fc">&nbsp;            return sym.copy().addConditions(symbol).build();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Symbol visit(Offside symbol) {
&nbsp;
<b class="fc">&nbsp;            if (doAlign) {</b>
<b class="fc">&nbsp;                Symbol sym = symbol.getSymbol().accept(this);</b>
&nbsp;
<b class="fc">&nbsp;                return sym == symbol.getSymbol() ? symbol</b>
<b class="nc">&nbsp;                    : new Offside.Builder(sym).setLabel(symbol.getLabel()).addConditions(symbol).build();</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            Symbol sym = symbol.getSymbol();</b>
&nbsp;
<b class="fc">&nbsp;            if (sym instanceof Nonterminal) {</b>
<b class="fc">&nbsp;                Nonterminal s = (Nonterminal) sym;</b>
&nbsp;
<b class="fc">&nbsp;                String l = symbol.getLabel();</b>
<b class="fc">&nbsp;                if (l != null &amp;&amp; s.getLabel() != null) {</b>
<b class="nc">&nbsp;                    if (!l.equals(s.getLabel()))</b>
<b class="nc">&nbsp;                        throw new RuntimeException(&quot;Conflicting labels: &quot; + symbol);</b>
<b class="fc">&nbsp;                } else if (s.getLabel() != null)</b>
<b class="fc">&nbsp;                    l = s.getLabel();</b>
<b class="fc">&nbsp;                else if (l == null &amp;&amp; s.getLabel() == null)</b>
<b class="fc">&nbsp;                    l = l_offside + i++;</b>
&nbsp;
<b class="fc">&nbsp;                if (isOffsided) { // Offside inside a rule that has a parameter for indentation</b>
<b class="fc">&nbsp;                    return s.copy()</b>
<b class="fc">&nbsp;                        .apply(lExt(l), indent(lExt(l)), integer(1))</b>
<b class="fc">&nbsp;                        .setLabel(l)</b>
<b class="fc">&nbsp;                        .addConditions(symbol)</b>
<b class="fc">&nbsp;                        .addConditions(sym)</b>
&nbsp;                        // [ ind == 0 || (first &amp;&amp; l.lExt - index == 0) || indent(l.lExt) &gt; ind]
<b class="fc">&nbsp;                        .addPreCondition(predicate(orIndent(index_exp, ind_exp, first_exp, lExt(l))))</b>
<b class="fc">&nbsp;                        .build();</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    return s.copy()</b>
<b class="fc">&nbsp;                        .apply(lExt(l), indent(lExt(l)), integer(1))</b>
<b class="fc">&nbsp;                        .setLabel(l)</b>
<b class="fc">&nbsp;                        .addConditions(symbol)</b>
<b class="fc">&nbsp;                        .addConditions(sym)</b>
<b class="fc">&nbsp;                        .build();</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // Otherwise, ignore offside
<b class="nc">&nbsp;            sym = sym.accept(this);</b>
<b class="nc">&nbsp;            return sym.copy().addConditions(symbol).build();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Symbol visit(Terminal symbol) {
<b class="fc">&nbsp;            if (isOffsided) {</b>
<b class="fc">&nbsp;                String l = symbol.getLabel() != null ? symbol.getLabel() : l_offside + i++;</b>
<b class="fc">&nbsp;                return symbol.copy()</b>
<b class="fc">&nbsp;                    .setLabel(l)</b>
<b class="fc">&nbsp;                    .addConditions(symbol)</b>
<b class="fc">&nbsp;                    .addPreCondition(predicate(orIndent(index_exp, ind_exp, first_exp, lExt(l))))</b>
<b class="fc">&nbsp;                    .build();</b>
&nbsp;            }
<b class="fc">&nbsp;            return symbol;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Symbol visit(While symbol) {
<b class="nc">&nbsp;            Symbol body = symbol.getBody().accept(this);</b>
<b class="nc">&nbsp;            if (body == symbol.getBody())</b>
<b class="nc">&nbsp;                return symbol;</b>
&nbsp;
<b class="nc">&nbsp;            return new While.Builder(symbol.getExpression(), body).setLabel(symbol.getLabel()).addConditions(symbol)</b>
<b class="nc">&nbsp;                .build();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Symbol visit(Return symbol) {
<b class="fc">&nbsp;            return symbol;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Symbol visit(Alt symbol) {
&nbsp;
<b class="fc">&nbsp;            List&lt;? extends Symbol&gt; symbols = symbol.getSymbols();</b>
<b class="fc">&nbsp;            List&lt;Symbol&gt; syms = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;            boolean modified = false;</b>
<b class="fc">&nbsp;            for (Symbol sym : symbols) {</b>
<b class="fc">&nbsp;                Symbol s = sym.accept(this);</b>
<b class="fc">&nbsp;                syms.add(s);</b>
<b class="fc">&nbsp;                if (sym != s)</b>
<b class="nc">&nbsp;                    modified |= true;</b>
<b class="fc">&nbsp;            }</b>
&nbsp;
<b class="fc">&nbsp;            return modified ? new Alt.Builder(syms).setLabel(symbol.getLabel()).addConditions(symbol).build()</b>
<b class="fc">&nbsp;                : symbol;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Symbol visit(Opt symbol) {
<b class="fc">&nbsp;            Symbol sym = symbol.getSymbol().accept(this);</b>
<b class="fc">&nbsp;            if (sym == symbol.getSymbol())</b>
<b class="fc">&nbsp;                return symbol;</b>
<b class="nc">&nbsp;            return new Opt.Builder(sym).setLabel(symbol.getLabel()).addConditions(symbol).build();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Symbol visit(Plus symbol) {
&nbsp;
<b class="fc">&nbsp;            Symbol sym = symbol.getSymbol().accept(this);</b>
<b class="fc">&nbsp;            List&lt;Symbol&gt; separators = symbol.getSeparators();</b>
&nbsp;
<b class="fc">&nbsp;            boolean modified = sym != symbol.getSymbol();</b>
&nbsp;
<b class="fc">&nbsp;            List&lt;Symbol&gt; seps = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;            for (Symbol sep : separators) {</b>
<b class="fc">&nbsp;                Symbol s = sep.accept(this);</b>
<b class="fc">&nbsp;                seps.add(s);</b>
<b class="fc">&nbsp;                if (s != sep)</b>
<b class="nc">&nbsp;                    modified |= true;</b>
<b class="fc">&nbsp;            }</b>
&nbsp;
<b class="fc">&nbsp;            return modified ? new Plus.Builder(sym).addSeparators(seps).setLabel(symbol.getLabel())</b>
<b class="nc">&nbsp;                .addConditions(symbol).build()</b>
<b class="fc">&nbsp;                : symbol;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Symbol visit(Group symbol) {
&nbsp;
<b class="fc">&nbsp;            List&lt;? extends Symbol&gt; symbols = symbol.getSymbols();</b>
<b class="fc">&nbsp;            List&lt;Symbol&gt; syms = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;            boolean modified = false;</b>
<b class="fc">&nbsp;            for (Symbol sym : symbols) {</b>
<b class="fc">&nbsp;                Symbol s = sym.accept(this);</b>
<b class="fc">&nbsp;                syms.add(s);</b>
<b class="fc">&nbsp;                if (sym != s)</b>
<b class="nc">&nbsp;                    modified |= true;</b>
<b class="fc">&nbsp;            }</b>
&nbsp;
<b class="fc">&nbsp;            return modified ? new Group.Builder(syms).setLabel(symbol.getLabel()).addConditions(symbol).build()</b>
<b class="fc">&nbsp;                : symbol;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Symbol visit(Star symbol) {
<b class="fc">&nbsp;            Symbol sym = symbol.getSymbol().accept(this);</b>
<b class="fc">&nbsp;            List&lt;Symbol&gt; separators = symbol.getSeparators();</b>
&nbsp;
<b class="fc">&nbsp;            boolean modified = sym != symbol.getSymbol();</b>
&nbsp;
<b class="fc">&nbsp;            List&lt;Symbol&gt; seps = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;            for (Symbol sep : separators) {</b>
<b class="fc">&nbsp;                Symbol s = sep.accept(this);</b>
<b class="fc">&nbsp;                seps.add(s);</b>
<b class="fc">&nbsp;                if (s != sep)</b>
<b class="nc">&nbsp;                    modified |= true;</b>
<b class="fc">&nbsp;            }</b>
&nbsp;
<b class="fc">&nbsp;            return modified ? new Star.Builder(sym).addSeparators(seps).setLabel(symbol.getLabel())</b>
<b class="nc">&nbsp;                .addConditions(symbol).build()</b>
<b class="fc">&nbsp;                : symbol;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Symbol visit(Start start) {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        private String getLabel(Align align, Symbol symbol) {
<b class="fc">&nbsp;            String label = null;</b>
&nbsp;
<b class="fc">&nbsp;            if (align.getLabel() != null &amp;&amp; symbol.getLabel() != null) {</b>
<b class="nc">&nbsp;                if (!align.getLabel().equals(symbol.getLabel()))</b>
<b class="nc">&nbsp;                    throw new RuntimeException(&quot;Two conflicting labels: &quot; + align);</b>
&nbsp;                else
<b class="nc">&nbsp;                    label = align.getLabel();</b>
<b class="fc">&nbsp;            } else if (align.getLabel() != null)</b>
<b class="nc">&nbsp;                label = align.getLabel();</b>
<b class="fc">&nbsp;            else if (symbol.getLabel() != null)</b>
<b class="nc">&nbsp;                label = symbol.getLabel();</b>
&nbsp;
<b class="fc">&nbsp;            return label != null ? label : l_align + i++;</b>
&nbsp;        }
&nbsp;
&nbsp;        private Symbol getSymbol(Symbol symbol, Condition precondition, String label) {
&nbsp;
<b class="fc">&nbsp;            if (symbol instanceof Offside) {</b>
<b class="fc">&nbsp;                Offside sym = (Offside) symbol;</b>
<b class="fc">&nbsp;                return new Offside.Builder(sym.getSymbol().copy().addPreCondition(precondition).setLabel(label).build())</b>
<b class="fc">&nbsp;                    .addConditions(symbol).setLabel(symbol.getLabel()).build();</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            return symbol.copy().addPreCondition(precondition).setLabel(label).build();</b>
&nbsp;        }
&nbsp;
&nbsp;        @SuppressWarnings(&quot;unused&quot;)
&nbsp;        private Symbol getLayout() {
<b class="nc">&nbsp;            switch (rule.getLayoutStrategy()) {</b>
&nbsp;                case NO_LAYOUT:
<b class="nc">&nbsp;                    throw new RuntimeException(&quot;Align should not be part of lexicals.&quot;);</b>
&nbsp;                case INHERITED:
<b class="nc">&nbsp;                    return layout;</b>
&nbsp;                case FIXED:
<b class="nc">&nbsp;                    return rule.getLayout();</b>
&nbsp;            }
<b class="nc">&nbsp;            return layout;</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    private static class FindOffsidesVisitor implements ISymbolVisitor&lt;Void&gt; {
&nbsp;
&nbsp;        private final Set&lt;String&gt; offsided;
&nbsp;
<b class="fc">&nbsp;        FindOffsidesVisitor() {</b>
<b class="fc">&nbsp;            this.offsided = new HashSet&lt;&gt;();</b>
&nbsp;        }
&nbsp;
&nbsp;        public Set&lt;String&gt; getOffsides() {
<b class="fc">&nbsp;            return offsided;</b>
&nbsp;        }
&nbsp;
&nbsp;        public void find(RuntimeGrammar grammar) {
&nbsp;
<b class="fc">&nbsp;            for (RuntimeRule rule : grammar.getRules()) {</b>
<b class="fc">&nbsp;                if (rule.getBody() == null)</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;
<b class="fc">&nbsp;                for (Symbol s : rule.getBody())</b>
<b class="fc">&nbsp;                    s.accept(this);</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Void visit(Offside symbol) {
<b class="fc">&nbsp;            Symbol sym = symbol.getSymbol();</b>
&nbsp;
&nbsp;            // Offside will only be applied to nonterminals
<b class="fc">&nbsp;            if (sym instanceof Nonterminal)</b>
<b class="fc">&nbsp;                offsided.add(((Nonterminal) sym).getName());</b>
&nbsp;
<b class="fc">&nbsp;            return sym.accept(this);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Void visit(Align symbol) {
<b class="nc">&nbsp;            return symbol.getSymbol().accept(this);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Void visit(Block symbol) {
<b class="nc">&nbsp;            for (Symbol sym : symbol.getSymbols())</b>
<b class="nc">&nbsp;                sym.accept(this);</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Void visit(Code symbol) {
<b class="fc">&nbsp;            return symbol.getSymbol().accept(this);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Void visit(Error error) {
<b class="fc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Void visit(Conditional symbol) {
<b class="nc">&nbsp;            return symbol.getSymbol().accept(this);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Void visit(IfThen symbol) {
<b class="nc">&nbsp;            return symbol.getThenPart().accept(this);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Void visit(IfThenElse symbol) {
<b class="nc">&nbsp;            symbol.getThenPart().accept(this);</b>
<b class="nc">&nbsp;            symbol.getElsePart().accept(this);</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Void visit(Ignore symbol) {
<b class="fc">&nbsp;            return symbol.getSymbol().accept(this);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Void visit(Nonterminal symbol) {
<b class="fc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Void visit(Terminal symbol) {
<b class="fc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Void visit(While symbol) {
<b class="nc">&nbsp;            return symbol.getBody().accept(this);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Void visit(Return symbol) {
&nbsp;            // TODO: support for return
<b class="fc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Void visit(Alt symbol) {
<b class="nc">&nbsp;            for (Symbol sym : symbol.getSymbols())</b>
<b class="nc">&nbsp;                sym.accept(this);</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Void visit(Opt symbol) {
<b class="nc">&nbsp;            return symbol.getSymbol().accept(this);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Void visit(Plus symbol) {
<b class="nc">&nbsp;            for (Symbol sym : symbol.getSeparators())</b>
<b class="nc">&nbsp;                sym.accept(this);</b>
<b class="nc">&nbsp;            return symbol.getSymbol().accept(this);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Void visit(Group symbol) {
<b class="nc">&nbsp;            for (Symbol sym : symbol.getSymbols())</b>
<b class="nc">&nbsp;                sym.accept(this);</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Void visit(Star symbol) {
<b class="nc">&nbsp;            for (Symbol sym : symbol.getSeparators())</b>
<b class="nc">&nbsp;                sym.accept(this);</b>
<b class="nc">&nbsp;            return symbol.getSymbol().accept(this);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Void visit(Start start) {
&nbsp;//          start.getNonterminal().accept(this);
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 17:08</div>
</div>
</body>
</html>
