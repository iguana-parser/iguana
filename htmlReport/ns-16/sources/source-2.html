


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > DesugarPrecedenceAndAssociativity</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.iguana.grammar.transformation</a>
</div>

<h1>Coverage Summary for Class: DesugarPrecedenceAndAssociativity (org.iguana.grammar.transformation)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">DesugarPrecedenceAndAssociativity</td>
<td class="coverageStat">
  <span class="percent">
    71.4%
  </span>
  <span class="absValue">
    (5/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    81.7%
  </span>
  <span class="absValue">
    (317/388)
  </span>
</td>
</tr>
  <tr>
    <td class="name">DesugarPrecedenceAndAssociativity$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DesugarPrecedenceAndAssociativity$Configuration</td>
<td class="coverageStat">
  <span class="percent">
    71.4%
  </span>
  <span class="absValue">
    (5/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    63%
  </span>
  <span class="absValue">
    (46/73)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DesugarPrecedenceAndAssociativity$OP</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DesugarPrecedenceAndAssociativity$Visitor</td>
<td class="coverageStat">
  <span class="percent">
    37%
  </span>
  <span class="absValue">
    (10/27)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    41.8%
  </span>
  <span class="absValue">
    (597/1428)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    52.3%
  </span>
  <span class="absValue">
    (23/44)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50.9%
  </span>
  <span class="absValue">
    (964/1893)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright (c) 2015, Ali Afroozeh and Anastasia Izmaylova, Centrum Wiskunde &amp; Informatica (CWI)
&nbsp; * All rights reserved.
&nbsp; *
&nbsp; * Redistribution and use in source and binary forms, with or without
&nbsp; * modification, are permitted provided that the following conditions are met:
&nbsp; *
&nbsp; * 1. Redistributions of source code must retain the above copyright notice, this
&nbsp; *    list of conditions and the following disclaimer.
&nbsp; *
&nbsp; * 2. Redistributions in binary form must reproduce the above copyright notice, this
&nbsp; *    list of conditions and the following disclaimer in the documentation and/or
&nbsp; *    other materials provided with the distribution.
&nbsp; *
&nbsp; * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
&nbsp; * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
&nbsp; * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
&nbsp; * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
&nbsp; * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
&nbsp; * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
&nbsp; * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
&nbsp; * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
&nbsp; * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
&nbsp; * OF SUCH DAMAGE.
&nbsp; *
&nbsp; */
&nbsp;
&nbsp;package org.iguana.grammar.transformation;
&nbsp;
&nbsp;import org.iguana.datadependent.ast.AST;
&nbsp;import org.iguana.datadependent.ast.Expression;
&nbsp;import org.iguana.datadependent.ast.Statement;
&nbsp;import org.iguana.grammar.condition.Condition;
&nbsp;import org.iguana.grammar.condition.DataDependentCondition;
&nbsp;import org.iguana.grammar.runtime.AssociativityGroup;
&nbsp;import org.iguana.grammar.runtime.PrecedenceLevel;
&nbsp;import org.iguana.grammar.runtime.RuntimeGrammar;
&nbsp;import org.iguana.grammar.runtime.RuntimeRule;
&nbsp;import org.iguana.grammar.symbol.Align;
&nbsp;import org.iguana.grammar.symbol.Alt;
&nbsp;import org.iguana.grammar.symbol.Associativity;
&nbsp;import org.iguana.grammar.symbol.Block;
&nbsp;import org.iguana.grammar.symbol.Code;
&nbsp;import org.iguana.grammar.symbol.Conditional;
&nbsp;import org.iguana.grammar.symbol.Error;
&nbsp;import org.iguana.grammar.symbol.Group;
&nbsp;import org.iguana.grammar.symbol.IfThen;
&nbsp;import org.iguana.grammar.symbol.IfThenElse;
&nbsp;import org.iguana.grammar.symbol.Ignore;
&nbsp;import org.iguana.grammar.symbol.Nonterminal;
&nbsp;import org.iguana.grammar.symbol.Offside;
&nbsp;import org.iguana.grammar.symbol.Opt;
&nbsp;import org.iguana.grammar.symbol.Plus;
&nbsp;import org.iguana.grammar.symbol.Return;
&nbsp;import org.iguana.grammar.symbol.Star;
&nbsp;import org.iguana.grammar.symbol.Start;
&nbsp;import org.iguana.grammar.symbol.Symbol;
&nbsp;import org.iguana.grammar.symbol.Terminal;
&nbsp;import org.iguana.grammar.symbol.While;
&nbsp;import org.iguana.traversal.ISymbolVisitor;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.Comparator;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.LinkedHashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;
&nbsp;import static org.iguana.datadependent.ast.AST.TRUE;
&nbsp;import static org.iguana.datadependent.ast.AST.and;
&nbsp;import static org.iguana.datadependent.ast.AST.equal;
&nbsp;import static org.iguana.datadependent.ast.AST.get;
&nbsp;import static org.iguana.datadependent.ast.AST.greater;
&nbsp;import static org.iguana.datadependent.ast.AST.greaterEq;
&nbsp;import static org.iguana.datadependent.ast.AST.ifThenElse;
&nbsp;import static org.iguana.datadependent.ast.AST.integer;
&nbsp;import static org.iguana.datadependent.ast.AST.lShiftANDEqZero;
&nbsp;import static org.iguana.datadependent.ast.AST.lessEq;
&nbsp;import static org.iguana.datadependent.ast.AST.min;
&nbsp;import static org.iguana.datadependent.ast.AST.neg;
&nbsp;import static org.iguana.datadependent.ast.AST.not;
&nbsp;import static org.iguana.datadependent.ast.AST.notEqual;
&nbsp;import static org.iguana.datadependent.ast.AST.or;
&nbsp;import static org.iguana.datadependent.ast.AST.pr1;
&nbsp;import static org.iguana.datadependent.ast.AST.pr2;
&nbsp;import static org.iguana.datadependent.ast.AST.tuple;
&nbsp;import static org.iguana.datadependent.ast.AST.undef;
&nbsp;import static org.iguana.datadependent.ast.AST.var;
&nbsp;import static org.iguana.datadependent.ast.AST.varDeclStat;
&nbsp;import static org.iguana.grammar.condition.DataDependentCondition.predicate;
&nbsp;
&nbsp;/**
&nbsp; * @author Anastasia Izmaylova
&nbsp; */
&nbsp;
<b class="fc">&nbsp;public class DesugarPrecedenceAndAssociativity implements GrammarTransformation {</b>
&nbsp;
&nbsp;    private Set&lt;String&gt; leftOrRightRecursiveNonterminals; // when operator precedence and associativity applies
&nbsp;
&nbsp;    private Map&lt;String, Map&lt;String, Integer&gt;&gt; headsWithLabeledRules; // excepts
&nbsp;
<b class="fc">&nbsp;    private enum OP {</b>
<b class="fc">&nbsp;        _1,</b>
<b class="fc">&nbsp;        _2</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private OP config_op = OP._2;</b>
&nbsp;
<b class="fc">&nbsp;    private class Configuration {</b>
&nbsp;
&nbsp;        private static final String left = &quot;left&quot;;
&nbsp;        private static final String right = &quot;right&quot;;
&nbsp;
&nbsp;        // Of associativity groups, rules that specify an associativity different from the group
<b class="fc">&nbsp;        public Map&lt;Integer, Set&lt;Integer&gt;&gt; left_assoc_rules = new HashMap&lt;&gt;();</b>
<b class="fc">&nbsp;        public Map&lt;Integer, Set&lt;Integer&gt;&gt; right_assoc_rules = new HashMap&lt;&gt;();</b>
<b class="fc">&nbsp;        public Map&lt;Integer, Set&lt;Integer&gt;&gt; non_assoc_rules = new HashMap&lt;&gt;();</b>
&nbsp;
&nbsp;        // Does not include associativity groups inside groups of rules with the same precedence level
<b class="fc">&nbsp;        public Map&lt;Integer, Set&lt;Integer&gt;&gt; binary_rules = new HashMap&lt;&gt;();</b>
<b class="fc">&nbsp;        public Map&lt;Integer, Set&lt;Integer&gt;&gt; prefix_rules = new HashMap&lt;&gt;();</b>
<b class="fc">&nbsp;        public Map&lt;Integer, Set&lt;Integer&gt;&gt; postfix_rules = new HashMap&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;        public Map&lt;Integer, Set&lt;Integer&gt;&gt; ibinary_rules = new HashMap&lt;&gt;();</b>
<b class="fc">&nbsp;        public Map&lt;Integer, Set&lt;Integer&gt;&gt; iprefix_rules = new HashMap&lt;&gt;();</b>
<b class="fc">&nbsp;        public Map&lt;Integer, Set&lt;Integer&gt;&gt; ipostfix_rules = new HashMap&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;        public Map&lt;String, RuntimeRule&gt; right_rec_rules = new HashMap&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;        public Set&lt;String&gt; leftEnds = new HashSet&lt;&gt;(); // left ends (transitive)</b>
<b class="fc">&nbsp;        public Set&lt;String&gt; rightEnds = new HashSet&lt;&gt;(); // right ends (transitive)</b>
&nbsp;
<b class="fc">&nbsp;        public Set&lt;String&gt; pleftEnds = new HashSet&lt;&gt;(); // from the left ends but where precedence applies</b>
<b class="fc">&nbsp;        public Set&lt;String&gt; prightEnds = new HashSet&lt;&gt;(); // from the right ends but where precedence applies</b>
&nbsp;
<b class="fc">&nbsp;        public List&lt;String&gt; pends = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;        public Set&lt;String&gt; rightEndsPrefixBelow = new HashSet&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;        public Set&lt;String&gt; directLeftEnds = new HashSet&lt;&gt;(); // not transitive</b>
<b class="fc">&nbsp;        public Set&lt;String&gt; directRightEnds = new HashSet&lt;&gt;(); // not transitive</b>
<b class="fc">&nbsp;        public Set&lt;String&gt; rightEndsThatCanLeadToPostfix = new HashSet&lt;&gt;();</b>
&nbsp;
&nbsp;        // Encoding: 2 is 2 &amp; 1; 3 is 1 &amp; 2; 4 is 2 &amp; 2 (l-value &amp; p-arg)
<b class="fc">&nbsp;        public Map&lt;Integer, Integer&gt; groups = new HashMap&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;        private int prefixBelow = -1;</b>
<b class="fc">&nbsp;        private int postfixBelow = -1;</b>
&nbsp;
<b class="fc">&nbsp;        private int larity = 1;</b>
<b class="fc">&nbsp;        private int parity = 1;</b>
&nbsp;
&nbsp;        public void arity() {
<b class="fc">&nbsp;            Collection&lt;Integer&gt; values = groups.values();</b>
<b class="fc">&nbsp;            if (values.contains(2) || values.contains(4))</b>
<b class="fc">&nbsp;                larity = 2;</b>
<b class="fc">&nbsp;            if (values.contains(3) || values.contains(4))</b>
<b class="fc">&nbsp;                parity = 2;</b>
&nbsp;        }
&nbsp;
&nbsp;        boolean hasPrefix(int lhs) {
&nbsp;
<b class="fc">&nbsp;            if (prefix_rules.containsKey(lhs) &amp;&amp; !prefix_rules.get(lhs).isEmpty())</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;
<b class="fc">&nbsp;            if (iprefix_rules.containsKey(lhs) &amp;&amp; !iprefix_rules.get(lhs).isEmpty())</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        boolean hasPostfix(int lhs) {
&nbsp;
<b class="fc">&nbsp;            if (postfix_rules.containsKey(lhs) &amp;&amp; !postfix_rules.get(lhs).isEmpty())</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;
<b class="fc">&nbsp;            if (ipostfix_rules.containsKey(lhs) &amp;&amp; !ipostfix_rules.get(lhs).isEmpty())</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        boolean hasPrefixBelow(int lhs) {
<b class="fc">&nbsp;            if (prefixBelow == -1) {</b>
<b class="fc">&nbsp;                prefixBelow = prefix_rules.isEmpty() ? 0 : prefix_rules.keySet().stream().min(Comparator.naturalOrder())</b>
<b class="fc">&nbsp;                                                                       .get();</b>
<b class="fc">&nbsp;                if (!iprefix_rules.isEmpty()) {</b>
<b class="nc">&nbsp;                    int other = iprefix_rules.keySet().stream().min(Comparator.naturalOrder()).get();</b>
<b class="nc">&nbsp;                    prefixBelow = Integer.min(prefixBelow, other);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (prefixBelow == 0)</b>
<b class="fc">&nbsp;                return false;</b>
&nbsp;
<b class="fc">&nbsp;            if (lhs &gt; prefixBelow)</b>
<b class="fc">&nbsp;                return true;</b>
<b class="fc">&nbsp;            if (lhs &lt;= prefixBelow)</b>
<b class="fc">&nbsp;                return false;</b>
&nbsp;
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        @SuppressWarnings(&quot;unused&quot;)
&nbsp;        boolean hasPostfixBelow(int lhs) {
<b class="nc">&nbsp;            if (postfixBelow == -1) {</b>
<b class="nc">&nbsp;                postfixBelow = postfix_rules.isEmpty() ? 0 : postfix_rules.keySet().stream().min(</b>
<b class="nc">&nbsp;                        Comparator.naturalOrder()).get();</b>
<b class="nc">&nbsp;                if (!ipostfix_rules.isEmpty()) {</b>
<b class="nc">&nbsp;                    int other = ipostfix_rules.keySet().stream().min(Comparator.naturalOrder()).get();</b>
<b class="nc">&nbsp;                    postfixBelow = Integer.max(postfixBelow, other);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (postfixBelow == 0)</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;
<b class="nc">&nbsp;            if (lhs &gt; postfixBelow)</b>
<b class="nc">&nbsp;                return true;</b>
<b class="nc">&nbsp;            if (lhs &lt;= postfixBelow)</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        @SuppressWarnings(&quot;unused&quot;)
&nbsp;        boolean can_be_reached_via(String nt, String via, String from) {
&nbsp;
<b class="nc">&nbsp;            if (from != left || from != right)</b>
<b class="nc">&nbsp;                throw new RuntimeException(&quot;Unexpected argument!&quot;);</b>
&nbsp;
<b class="nc">&nbsp;            if (from == left &amp;&amp; this.leftEnds.contains(via) &amp;&amp; configs.get(via).pleftEnds.contains(nt))</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;
<b class="nc">&nbsp;            if (from == right &amp;&amp; this.rightEnds.contains(via) &amp;&amp; configs.get(via).prightEnds.contains(nt))</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    private Map&lt;String, Configuration&gt; configs;
&nbsp;
&nbsp;    public void setOP1() {
<b class="nc">&nbsp;        config_op = OP._1;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setOP2() {
<b class="fc">&nbsp;        config_op = OP._2;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static boolean canBePrefix(String nt, String leftEnd, Map&lt;String, Configuration&gt; configs) {
&nbsp;
<b class="nc">&nbsp;        if (leftEnd.startsWith(&quot;$&quot;))</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;
<b class="nc">&nbsp;        Set&lt;String&gt; ends = new HashSet&lt;&gt;(Arrays.asList(leftEnd));</b>
<b class="nc">&nbsp;        Set&lt;String&gt; jobs = ends;</b>
<b class="nc">&nbsp;        boolean changed = true;</b>
<b class="nc">&nbsp;        while (changed) {</b>
<b class="nc">&nbsp;            changed = false;</b>
<b class="nc">&nbsp;            Set&lt;String&gt; delta = new HashSet&lt;&gt;();</b>
<b class="nc">&nbsp;            for (String end : jobs) {</b>
<b class="nc">&nbsp;                int size = ends.size();</b>
<b class="nc">&nbsp;                Set&lt;String&gt; lefts = configs.get(end).directLeftEnds;</b>
<b class="nc">&nbsp;                if (lefts != null) {</b>
<b class="nc">&nbsp;                    for (String left : lefts) {</b>
<b class="nc">&nbsp;                        if (!left.equals(nt)) {</b>
<b class="nc">&nbsp;                            if (left.startsWith(&quot;$&quot;) || !configs.get(left).leftEnds.contains(nt))</b>
<b class="nc">&nbsp;                                return true;</b>
&nbsp;                            else
<b class="nc">&nbsp;                                delta.add(left);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
<b class="nc">&nbsp;                ends.addAll(delta);</b>
<b class="nc">&nbsp;                jobs = delta;</b>
<b class="nc">&nbsp;                if (size != ends.size())</b>
<b class="nc">&nbsp;                    changed = true;</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static boolean canBePostfix(
&nbsp;            String nt,
&nbsp;            String rightEnd,
&nbsp;            Map&lt;String, Configuration&gt; configs,
&nbsp;            boolean compute) {
&nbsp;
<b class="fc">&nbsp;        Configuration config = configs.get(nt);</b>
&nbsp;
<b class="fc">&nbsp;        boolean can = false;</b>
&nbsp;
<b class="fc">&nbsp;        if (rightEnd.startsWith(&quot;$&quot;)) // nothing to compute</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;
<b class="fc">&nbsp;        Set&lt;String&gt; ends = new HashSet&lt;&gt;(Arrays.asList(rightEnd));</b>
<b class="fc">&nbsp;        Set&lt;String&gt; jobs = ends;</b>
<b class="fc">&nbsp;        boolean changed = true;</b>
<b class="fc">&nbsp;        while (changed) {</b>
<b class="fc">&nbsp;            changed = false;</b>
<b class="fc">&nbsp;            Set&lt;String&gt; delta = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;            for (String end : jobs) {</b>
<b class="fc">&nbsp;                int size = ends.size();</b>
<b class="fc">&nbsp;                Set&lt;String&gt; rights = configs.get(end).directRightEnds;</b>
<b class="fc">&nbsp;                if (rights != null) {</b>
<b class="fc">&nbsp;                    for (String right : rights) {</b>
<b class="fc">&nbsp;                        if (!right.equals(nt)) {</b>
<b class="fc">&nbsp;                            if (right.startsWith(&quot;$&quot;) || !configs.get(right).rightEnds.contains(nt)) {</b>
<b class="fc">&nbsp;                                if (!compute)</b>
<b class="fc">&nbsp;                                    return true;</b>
&nbsp;                                else
<b class="fc">&nbsp;                                    can = true;</b>
&nbsp;                            } else
<b class="fc">&nbsp;                                delta.add(right);</b>
&nbsp;                        }
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
<b class="fc">&nbsp;                ends.addAll(delta);</b>
<b class="fc">&nbsp;                jobs = delta;</b>
<b class="fc">&nbsp;                if (size != ends.size())</b>
<b class="fc">&nbsp;                    changed = true;</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        if (compute &amp;&amp; can)</b>
<b class="fc">&nbsp;            config.rightEndsThatCanLeadToPostfix.addAll(ends);</b>
&nbsp;
<b class="fc">&nbsp;        return can;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public RuntimeGrammar transform(RuntimeGrammar grammar) {
&nbsp;
<b class="fc">&nbsp;        leftOrRightRecursiveNonterminals = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;        headsWithLabeledRules = new HashMap&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;        FindLabelsUsedInExcepts usedLabels = new FindLabelsUsedInExcepts();</b>
<b class="fc">&nbsp;        usedLabels.compute(grammar);</b>
&nbsp;
<b class="fc">&nbsp;        configs = new HashMap&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;        for (RuntimeRule rule : grammar.getRules()) {</b>
&nbsp;
<b class="fc">&nbsp;            Configuration config = configs.get(rule.getHead().getName());</b>
&nbsp;
<b class="fc">&nbsp;            if (config == null) {</b>
<b class="fc">&nbsp;                config = new Configuration();</b>
<b class="fc">&nbsp;                configs.put(rule.getHead().getName(), config);</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (!rule.getLeftEnd().isEmpty())</b>
<b class="fc">&nbsp;                config.directRightEnds.add(rule.getRightEnd());</b>
&nbsp;
<b class="fc">&nbsp;            if (!rule.getRightEnd().isEmpty())</b>
<b class="fc">&nbsp;                config.directRightEnds.add(rule.getRightEnd());</b>
&nbsp;
<b class="fc">&nbsp;            config.leftEnds = rule.getLeftEnds();</b>
<b class="fc">&nbsp;            config.rightEnds = rule.getRightEnds();</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        for (RuntimeRule rule : grammar.getRules()) {</b>
&nbsp;
<b class="fc">&nbsp;            Nonterminal head = rule.getHead();</b>
&nbsp;
&nbsp;            // 1. Excepts
<b class="fc">&nbsp;            if (rule.getLabel() != null &amp;&amp; usedLabels.getLables().containsKey(rule.getHead().getName())</b>
<b class="fc">&nbsp;                &amp;&amp; usedLabels.getLables().get(rule.getHead().getName()).contains(rule.getLabel())) {</b>
&nbsp;
<b class="fc">&nbsp;                Map&lt;String, Integer&gt; labels = headsWithLabeledRules.get(head.getName());</b>
<b class="fc">&nbsp;                Configuration config = configs.get(head.getName());</b>
&nbsp;
<b class="fc">&nbsp;                if (rule.isRightRecursive() || rule.isIRightRecursive()) {</b>
<b class="fc">&nbsp;                    if (rule.isIRightRecursive()) {</b>
<b class="fc">&nbsp;                        boolean canBePostfix = canBePostfix(head.getName(), rule.getRightEnd(), configs, false);</b>
<b class="fc">&nbsp;                        if (!canBePostfix)</b>
<b class="fc">&nbsp;                            config.right_rec_rules.put(rule.getLabel(), rule);</b>
<b class="fc">&nbsp;                    } else</b>
<b class="fc">&nbsp;                        config.right_rec_rules.put(rule.getLabel(), rule);</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (labels != null) {</b>
<b class="fc">&nbsp;                    if (!labels.containsKey(rule.getLabel()))</b>
<b class="fc">&nbsp;                        labels.put(rule.getLabel(), labels.size());</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    labels = new HashMap&lt;&gt;();</b>
<b class="fc">&nbsp;                    labels.put(rule.getLabel(), labels.size());</b>
<b class="fc">&nbsp;                    headsWithLabeledRules.put(head.getName(), labels);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // 2. Precedence
<b class="fc">&nbsp;            if (rule.getPrecedenceLevel().getRhs() != 1</b>
<b class="fc">&nbsp;                || (rule.getPrecedence() == 1 &amp;&amp; rule.getAssociativity() != Associativity.UNDEFINED)) {</b>
<b class="fc">&nbsp;                leftOrRightRecursiveNonterminals.add(head.getName());</b>
&nbsp;            }
&nbsp;            // else: all the rules have a precedence -1 (non-recursive), or 1 and
&nbsp;            // undefined associativity; therefore, precedence does not apply
&nbsp;
<b class="fc">&nbsp;            if (rule.getPrecedence() == -1)</b>
<b class="fc">&nbsp;                continue;</b>
&nbsp;
&nbsp;            // Decision of the arity of a p-argument and l-value (only for the alternative scheme)
<b class="fc">&nbsp;            Configuration config = configs.get(head.getName());</b>
<b class="fc">&nbsp;            AssociativityGroup assoc_group = rule.getAssociativityGroup();</b>
<b class="fc">&nbsp;            PrecedenceLevel prec_level = rule.getPrecedenceLevel();</b>
&nbsp;
<b class="fc">&nbsp;            boolean isBinary = rule.isLeftRecursive() &amp;&amp; rule.isRightRecursive();</b>
<b class="fc">&nbsp;            boolean isPrefix = !(rule.isLeftRecursive() || rule.isILeftRecursive()) &amp;&amp; rule.isRightRecursive();</b>
<b class="fc">&nbsp;            boolean isPostfix = rule.isLeftRecursive() &amp;&amp; !(rule.isRightRecursive() || rule.isIRightRecursive());</b>
&nbsp;
<b class="fc">&nbsp;            boolean canBeBinary = ((rule.isLeftRecursive() || rule.isILeftRecursive()) &amp;&amp; rule.isIRightRecursive())</b>
<b class="fc">&nbsp;                                  || (rule.isILeftRecursive() &amp;&amp; (rule.isRightRecursive() || rule.isIRightRecursive()));</b>
&nbsp;
<b class="fc">&nbsp;            boolean canBePrefix = false;</b>
<b class="fc">&nbsp;            boolean canBePostfix = false;</b>
&nbsp;
<b class="fc">&nbsp;            if (rule.isLeftRecursive() &amp;&amp; rule.isIRightRecursive())</b>
<b class="fc">&nbsp;                canBePostfix = canBePostfix(rule.getHead().getName(), rule.getRightEnd(), configs, true);</b>
&nbsp;
<b class="fc">&nbsp;            if (rule.isILeftRecursive() &amp;&amp; rule.isRightRecursive())</b>
<b class="nc">&nbsp;                canBePrefix = canBePrefix(rule.getHead().getName(), rule.getLeftEnd(), configs);</b>
&nbsp;
<b class="fc">&nbsp;            if (rule.isILeftRecursive() &amp;&amp; !rule.isRightRecursive() &amp;&amp; !rule.isIRightRecursive())</b>
<b class="fc">&nbsp;                canBePostfix = true;</b>
&nbsp;
<b class="fc">&nbsp;            if (!rule.isLeftRecursive() &amp;&amp; !rule.isILeftRecursive() &amp;&amp; rule.isIRightRecursive())</b>
<b class="fc">&nbsp;                canBePrefix = true;</b>
&nbsp;
<b class="fc">&nbsp;            if (rule.isILeftRecursive() &amp;&amp; rule.isIRightRecursive()) {</b>
<b class="nc">&nbsp;                canBePrefix = canBePrefix(rule.getHead().getName(), rule.getLeftEnd(), configs);</b>
<b class="nc">&nbsp;                canBePostfix = canBePostfix(rule.getHead().getName(), rule.getRightEnd(), configs, true);</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (isBinary) {</b>
<b class="fc">&nbsp;                Set&lt;Integer&gt; rules = config.binary_rules.get(prec_level.getLhs());</b>
<b class="fc">&nbsp;                if (rules == null) {</b>
<b class="fc">&nbsp;                    rules = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;                    config.binary_rules.put(prec_level.getLhs(), rules);</b>
&nbsp;                }
<b class="fc">&nbsp;                rules.add(rule.getPrecedence());</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (isPrefix) {</b>
<b class="fc">&nbsp;                Set&lt;Integer&gt; rules = config.prefix_rules.get(prec_level.getLhs());</b>
<b class="fc">&nbsp;                if (rules == null) {</b>
<b class="fc">&nbsp;                    rules = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;                    config.prefix_rules.put(prec_level.getLhs(), rules);</b>
&nbsp;                }
<b class="fc">&nbsp;                rules.add(rule.getPrecedence());</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (isPostfix) {</b>
<b class="fc">&nbsp;                Set&lt;Integer&gt; rules = config.postfix_rules.get(prec_level.getLhs());</b>
<b class="fc">&nbsp;                if (rules == null) {</b>
<b class="fc">&nbsp;                    rules = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;                    config.postfix_rules.put(prec_level.getLhs(), rules);</b>
&nbsp;                }
<b class="fc">&nbsp;                rules.add(rule.getPrecedence());</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (canBeBinary) {</b>
<b class="fc">&nbsp;                Set&lt;Integer&gt; rules = config.ibinary_rules.get(prec_level.getLhs());</b>
<b class="fc">&nbsp;                if (rules == null) {</b>
<b class="fc">&nbsp;                    rules = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;                    config.ibinary_rules.put(prec_level.getLhs(), rules);</b>
&nbsp;                }
<b class="fc">&nbsp;                rules.add(rule.getPrecedence());</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (canBePrefix) {</b>
<b class="fc">&nbsp;                Set&lt;Integer&gt; rules = config.iprefix_rules.get(prec_level.getLhs());</b>
<b class="fc">&nbsp;                if (rules == null) {</b>
<b class="fc">&nbsp;                    rules = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;                    config.prefix_rules.put(prec_level.getLhs(), rules);</b>
&nbsp;                }
<b class="fc">&nbsp;                rules.add(rule.getPrecedence());</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (canBePostfix) {</b>
<b class="fc">&nbsp;                Set&lt;Integer&gt; rules = config.ipostfix_rules.get(prec_level.getLhs());</b>
<b class="fc">&nbsp;                if (rules == null) {</b>
<b class="fc">&nbsp;                    rules = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;                    config.postfix_rules.put(prec_level.getLhs(), rules);</b>
&nbsp;                }
<b class="fc">&nbsp;                rules.add(rule.getPrecedence());</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (assoc_group != null) {</b>
&nbsp;                // Inside an associativity group
&nbsp;
<b class="fc">&nbsp;                Associativity assoc = rule.getAssociativity();</b>
&nbsp;
<b class="fc">&nbsp;                if (assoc != assoc_group.getAssociativity() || assoc != Associativity.UNDEFINED) {</b>
&nbsp;                    // Rules in an associativity group that override the associativity
<b class="fc">&nbsp;                    Set&lt;Integer&gt; rules = null;</b>
&nbsp;
<b class="fc">&nbsp;                    switch (assoc) {</b>
&nbsp;                        case LEFT:
<b class="fc">&nbsp;                            rules = config.left_assoc_rules.get(assoc_group.getLhs());</b>
<b class="fc">&nbsp;                            if (rules == null) {</b>
<b class="fc">&nbsp;                                rules = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;                                config.left_assoc_rules.put(assoc_group.getLhs(), rules);</b>
&nbsp;                            }
<b class="fc">&nbsp;                            rules.add(rule.getPrecedence());</b>
<b class="fc">&nbsp;                            break;</b>
&nbsp;                        case RIGHT:
<b class="fc">&nbsp;                            rules = config.right_assoc_rules.get(assoc_group.getLhs());</b>
<b class="fc">&nbsp;                            if (rules == null) {</b>
<b class="fc">&nbsp;                                rules = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;                                config.right_assoc_rules.put(assoc_group.getLhs(), rules);</b>
&nbsp;                            }
<b class="fc">&nbsp;                            rules.add(rule.getPrecedence());</b>
<b class="fc">&nbsp;                            break;</b>
&nbsp;                        case NON_ASSOC:
<b class="fc">&nbsp;                            rules = config.non_assoc_rules.get(assoc_group.getLhs());</b>
<b class="fc">&nbsp;                            if (rules == null) {</b>
<b class="fc">&nbsp;                                rules = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;                                config.non_assoc_rules.put(assoc_group.getLhs(), rules);</b>
&nbsp;                            }
<b class="fc">&nbsp;                            rules.add(rule.getPrecedence());</b>
<b class="fc">&nbsp;                            break;</b>
&nbsp;                        default:
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                boolean climbing =</b>
<b class="fc">&nbsp;                        prec_level.getLhs() == assoc_group.getLhs() &amp;&amp; prec_level.getRhs() == assoc_group.getRhs();</b>
&nbsp;
<b class="fc">&nbsp;                if (climbing) {</b>
<b class="fc">&nbsp;                    if (isBinary &amp;&amp; rule.getPrecedence() != assoc_group.getPrecedence())</b>
<b class="fc">&nbsp;                        config.groups.put(assoc_group.getLhs(), 4);</b>
<b class="fc">&nbsp;                    if (canBeBinary &amp;&amp; rule.getPrecedence() != assoc_group.getPrecedence())</b>
<b class="nc">&nbsp;                        config.groups.put(assoc_group.getLhs(), 4);</b>
&nbsp;                } else
<b class="nc">&nbsp;                    config.groups.put(prec_level.getLhs(), 4);</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (assoc_group == null) {</b>
<b class="fc">&nbsp;                if (prec_level.getLhs() != prec_level.getRhs() &amp;&amp; (canBeBinary || canBePrefix || canBePostfix)</b>
<b class="nc">&nbsp;                    &amp;&amp; rule.getAssociativity() != Associativity.UNDEFINED)</b>
<b class="nc">&nbsp;                    config.groups.put(prec_level.getLhs(), 4);</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        if (config_op == OP._2) {</b>
<b class="fc">&nbsp;            Set&lt;String&gt; nonterminals = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;            nonterminals.addAll(leftOrRightRecursiveNonterminals);</b>
&nbsp;
<b class="fc">&nbsp;            boolean changed = true;</b>
<b class="fc">&nbsp;            while (changed) {</b>
<b class="fc">&nbsp;                changed = false;</b>
<b class="fc">&nbsp;                int size = nonterminals.size();</b>
<b class="fc">&nbsp;                Set&lt;String&gt; delta = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;                for (String nt : nonterminals) {</b>
<b class="fc">&nbsp;                    Configuration config = configs.get(nt);</b>
<b class="fc">&nbsp;                    if (config != null) {</b>
<b class="fc">&nbsp;                        delta.addAll(config.leftEnds);</b>
<b class="fc">&nbsp;                        delta.addAll(config.rightEnds);</b>
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                nonterminals.addAll(delta);</b>
<b class="fc">&nbsp;                if (nonterminals.size() != size)</b>
<b class="fc">&nbsp;                    changed = true;</b>
<b class="fc">&nbsp;            }</b>
&nbsp;
<b class="fc">&nbsp;            for (String head : configs.keySet()) {</b>
<b class="fc">&nbsp;                if (!nonterminals.contains(head)) {</b>
<b class="fc">&nbsp;                    Configuration config = configs.get(head);</b>
<b class="fc">&nbsp;                    config.leftEnds = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;                    config.rightEnds = new HashSet&lt;&gt;();</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        for (RuntimeRule rule : grammar.getRules()) {</b>
&nbsp;
<b class="fc">&nbsp;            if (config_op == OP._1) break;</b>
&nbsp;
<b class="fc">&nbsp;            if (rule.getPrecedence() == -1)</b>
<b class="fc">&nbsp;                continue;</b>
&nbsp;
<b class="fc">&nbsp;            Configuration config = configs.get(rule.getHead().getName());</b>
<b class="fc">&nbsp;            AssociativityGroup assoc_group = rule.getAssociativityGroup();</b>
<b class="fc">&nbsp;            PrecedenceLevel prec_level = rule.getPrecedenceLevel();</b>
&nbsp;
<b class="fc">&nbsp;            Integer arity = config.groups.get(prec_level.getLhs());</b>
&nbsp;
<b class="fc">&nbsp;            if (assoc_group != null) {</b>
&nbsp;
<b class="fc">&nbsp;                boolean climbing =</b>
<b class="fc">&nbsp;                        prec_level.getLhs() == assoc_group.getLhs() &amp;&amp; prec_level.getRhs() == assoc_group.getRhs();</b>
&nbsp;
<b class="fc">&nbsp;                if (climbing) {</b>
&nbsp;
<b class="fc">&nbsp;                    if (arity == null || arity != 4) {</b>
&nbsp;
<b class="fc">&nbsp;                        boolean hasBinary = config.binary_rules.get(prec_level.getLhs()) != null;</b>
<b class="fc">&nbsp;                        boolean hasPrefix = config.prefix_rules.get(prec_level.getLhs()) != null;</b>
<b class="fc">&nbsp;                        boolean hasPostfix = config.postfix_rules.get(prec_level.getLhs()) != null;</b>
&nbsp;
<b class="fc">&nbsp;                        boolean canHaveBinary = config.ibinary_rules.get(prec_level.getLhs()) != null;</b>
<b class="fc">&nbsp;                        boolean canHavePrefix = config.iprefix_rules.get(prec_level.getLhs()) != null;</b>
<b class="fc">&nbsp;                        boolean canHavePostfix = config.ipostfix_rules.get(prec_level.getLhs()) != null;</b>
&nbsp;
<b class="fc">&nbsp;                        if (((hasBinary || canHaveBinary)</b>
&nbsp;                             &amp;&amp; (hasPrefix || hasPostfix || canHavePrefix || canHavePostfix))
&nbsp;                            || ((hasPrefix || canHavePrefix) &amp;&amp; (hasPostfix || canHavePostfix))) {
<b class="fc">&nbsp;                            Associativity assoc = assoc_group.getAssociativity();</b>
&nbsp;
<b class="fc">&nbsp;                            if ((assoc == Associativity.LEFT || assoc == Associativity.NON_ASSOC)</b>
&nbsp;                                &amp;&amp; (hasPostfix || canHavePostfix)) {
<b class="fc">&nbsp;                                for (int group : config.binary_rules.keySet()) {</b>
<b class="fc">&nbsp;                                    if (group &gt; rule.getPrecedence()) {</b>
<b class="fc">&nbsp;                                        if (arity == null || arity == 3)</b>
<b class="fc">&nbsp;                                            config.groups.put(prec_level.getLhs(), 3);</b>
&nbsp;                                        else
<b class="fc">&nbsp;                                            config.groups.put(prec_level.getLhs(), 4);</b>
&nbsp;                                    }
<b class="fc">&nbsp;                                }</b>
<b class="fc">&nbsp;                                for (int group : config.postfix_rules.keySet()) {</b>
<b class="fc">&nbsp;                                    if (group &gt; rule.getPrecedence()) {</b>
<b class="nc">&nbsp;                                        if (arity == null || arity == 3)</b>
<b class="nc">&nbsp;                                            config.groups.put(prec_level.getLhs(), 3);</b>
&nbsp;                                        else
<b class="nc">&nbsp;                                            config.groups.put(prec_level.getLhs(), 4);</b>
&nbsp;                                    }
<b class="fc">&nbsp;                                }</b>
&nbsp;
<b class="fc">&nbsp;                                for (int group : config.ibinary_rules.keySet()) {</b>
<b class="fc">&nbsp;                                    if (group &gt; rule.getPrecedence()) {</b>
<b class="nc">&nbsp;                                        if (arity == null || arity == 3)</b>
<b class="nc">&nbsp;                                            config.groups.put(prec_level.getLhs(), 3);</b>
&nbsp;                                        else
<b class="nc">&nbsp;                                            config.groups.put(prec_level.getLhs(), 4);</b>
&nbsp;                                    }
<b class="fc">&nbsp;                                }</b>
<b class="fc">&nbsp;                                for (int group : config.ipostfix_rules.keySet()) {</b>
<b class="nc">&nbsp;                                    if (group &gt; rule.getPrecedence()) {</b>
<b class="nc">&nbsp;                                        if (arity == null || arity == 3)</b>
<b class="nc">&nbsp;                                            config.groups.put(prec_level.getLhs(), 3);</b>
&nbsp;                                        else
<b class="nc">&nbsp;                                            config.groups.put(prec_level.getLhs(), 4);</b>
&nbsp;                                    }
<b class="nc">&nbsp;                                }</b>
&nbsp;                            }
<b class="fc">&nbsp;                            if ((assoc == Associativity.RIGHT || assoc == Associativity.NON_ASSOC)</b>
&nbsp;                                &amp;&amp; (hasPrefix || canHavePostfix)) {
<b class="fc">&nbsp;                                for (int group : config.binary_rules.keySet()) {</b>
<b class="fc">&nbsp;                                    if (group &gt; rule.getPrecedence()) {</b>
<b class="fc">&nbsp;                                        if (arity == null || arity == 2)</b>
<b class="fc">&nbsp;                                            config.groups.put(prec_level.getLhs(), 2);</b>
&nbsp;                                        else
<b class="nc">&nbsp;                                            config.groups.put(prec_level.getLhs(), 4);</b>
&nbsp;                                    }
<b class="fc">&nbsp;                                }</b>
<b class="fc">&nbsp;                                for (int group : config.postfix_rules.keySet()) {</b>
<b class="fc">&nbsp;                                    if (group &gt; rule.getPrecedence()) {</b>
<b class="nc">&nbsp;                                        if (arity == null || arity == 2)</b>
<b class="nc">&nbsp;                                            config.groups.put(prec_level.getLhs(), 2);</b>
&nbsp;                                        else
<b class="nc">&nbsp;                                            config.groups.put(prec_level.getLhs(), 4);</b>
&nbsp;                                    }
<b class="fc">&nbsp;                                }</b>
&nbsp;
<b class="fc">&nbsp;                                for (int group : config.ibinary_rules.keySet()) {</b>
<b class="fc">&nbsp;                                    if (group &gt; rule.getPrecedence()) {</b>
<b class="nc">&nbsp;                                        if (arity == null || arity == 2)</b>
<b class="nc">&nbsp;                                            config.groups.put(prec_level.getLhs(), 2);</b>
&nbsp;                                        else
<b class="nc">&nbsp;                                            config.groups.put(prec_level.getLhs(), 4);</b>
&nbsp;                                    }
<b class="fc">&nbsp;                                }</b>
<b class="fc">&nbsp;                                for (int group : config.ipostfix_rules.keySet()) {</b>
<b class="nc">&nbsp;                                    if (group &gt; rule.getPrecedence()) {</b>
<b class="nc">&nbsp;                                        if (arity == null || arity == 2)</b>
<b class="nc">&nbsp;                                            config.groups.put(prec_level.getLhs(), 2);</b>
&nbsp;                                        else
<b class="nc">&nbsp;                                            config.groups.put(prec_level.getLhs(), 4);</b>
&nbsp;                                    }
<b class="nc">&nbsp;                                }</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;            } else {</b>
&nbsp;
<b class="fc">&nbsp;                if (arity == null || arity != 4) {</b>
&nbsp;
<b class="fc">&nbsp;                    boolean isBinary = rule.isLeftRecursive() &amp;&amp; rule.isRightRecursive();</b>
<b class="fc">&nbsp;                    boolean canBeBinary =</b>
<b class="fc">&nbsp;                            ((rule.isLeftRecursive() || rule.isILeftRecursive()) &amp;&amp; rule.isIRightRecursive())</b>
<b class="fc">&nbsp;                            || (rule.isILeftRecursive() &amp;&amp; (rule.isRightRecursive() || rule.isIRightRecursive()));</b>
&nbsp;
<b class="fc">&nbsp;                    Set&lt;Integer&gt; binary_rules = config.binary_rules.get(prec_level.getLhs());</b>
<b class="fc">&nbsp;                    Set&lt;Integer&gt; prefix_rules = config.prefix_rules.get(prec_level.getLhs());</b>
<b class="fc">&nbsp;                    Set&lt;Integer&gt; postfix_rules = config.postfix_rules.get(prec_level.getLhs());</b>
&nbsp;
<b class="fc">&nbsp;                    Set&lt;Integer&gt; ibinary_rules = config.ibinary_rules.get(prec_level.getLhs());</b>
<b class="fc">&nbsp;                    Set&lt;Integer&gt; iprefix_rules = config.iprefix_rules.get(prec_level.getLhs());</b>
<b class="fc">&nbsp;                    Set&lt;Integer&gt; ipostfix_rules = config.ipostfix_rules.get(prec_level.getLhs());</b>
&nbsp;
<b class="fc">&nbsp;                    int left_rec = (binary_rules == null ? 0 : binary_rules.size())</b>
<b class="fc">&nbsp;                                   + (postfix_rules == null ? 0 : postfix_rules.size());</b>
&nbsp;
<b class="fc">&nbsp;                    int right_rec = (binary_rules == null ? 0 : binary_rules.size())</b>
<b class="fc">&nbsp;                                    + (prefix_rules == null ? 0 : prefix_rules.size());</b>
&nbsp;
<b class="fc">&nbsp;                    int ileft_rec = (ibinary_rules == null ? 0 : ibinary_rules.size())</b>
<b class="fc">&nbsp;                                    + (ipostfix_rules == null ? 0 : ipostfix_rules.size());</b>
&nbsp;
<b class="fc">&nbsp;                    int iright_rec = (ibinary_rules == null ? 0 : ibinary_rules.size())</b>
<b class="fc">&nbsp;                                     + (iprefix_rules == null ? 0 : iprefix_rules.size());</b>
&nbsp;
<b class="fc">&nbsp;                    if (rule.getAssociativity() != Associativity.UNDEFINED) {</b>
&nbsp;
<b class="fc">&nbsp;                        if (isBinary &amp;&amp; (rule.getAssociativity() == Associativity.LEFT</b>
<b class="fc">&nbsp;                                         || rule.getAssociativity() == Associativity.NON_ASSOC)) {</b>
&nbsp;                            // As associatvity is defined, rule.getPrecedence() is unique;
&nbsp;                            // therefore, maintaining &lt;_&gt;_rules as precedence sets, for each precedence level
&nbsp;                            // should sufficient
<b class="fc">&nbsp;                            if (left_rec + ileft_rec &gt;= 2) {</b>
<b class="fc">&nbsp;                                Integer n = config.groups.get(prec_level.getLhs());</b>
<b class="fc">&nbsp;                                if (n == null)</b>
<b class="fc">&nbsp;                                    config.groups.put(prec_level.getLhs(), 3);</b>
<b class="nc">&nbsp;                                else if (n != 3)</b>
<b class="nc">&nbsp;                                    config.groups.put(prec_level.getLhs(), 4);</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;
<b class="fc">&nbsp;                        if (isBinary &amp;&amp; (rule.getAssociativity() == Associativity.RIGHT</b>
<b class="fc">&nbsp;                                         || rule.getAssociativity() == Associativity.NON_ASSOC)) {</b>
<b class="fc">&nbsp;                            if (right_rec + iright_rec &gt;= 2) {</b>
<b class="nc">&nbsp;                                Integer n = config.groups.get(prec_level.getLhs());</b>
<b class="nc">&nbsp;                                if (n == null)</b>
<b class="nc">&nbsp;                                    config.groups.put(prec_level.getLhs(), 2);</b>
<b class="nc">&nbsp;                                else if (n != 2)</b>
<b class="nc">&nbsp;                                    config.groups.put(prec_level.getLhs(), 4);</b>
&nbsp;                            }
&nbsp;
&nbsp;                        }
&nbsp;
<b class="fc">&nbsp;                        if (!(isBinary || canBeBinary) &amp;&amp; rule.isRightRecursive()</b>
<b class="nc">&nbsp;                            &amp;&amp; rule.getAssociativity() == Associativity.NON_ASSOC) {</b>
<b class="nc">&nbsp;                            if (left_rec + ileft_rec &gt;= 1) {</b>
<b class="nc">&nbsp;                                Integer n = config.groups.get(prec_level.getLhs());</b>
<b class="nc">&nbsp;                                if (n == null)</b>
<b class="nc">&nbsp;                                    config.groups.put(prec_level.getLhs(), 3);</b>
<b class="nc">&nbsp;                                else if (n != 3)</b>
<b class="nc">&nbsp;                                    config.groups.put(prec_level.getLhs(), 4);</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        if (config_op == OP._2) {</b>
<b class="fc">&nbsp;            for (String head : configs.keySet()) {</b>
&nbsp;
<b class="fc">&nbsp;                Configuration config = configs.get(head);</b>
&nbsp;
<b class="fc">&nbsp;                config.arity();</b>
&nbsp;
<b class="fc">&nbsp;                for (String end : config.leftEnds) {</b>
<b class="fc">&nbsp;                    if (leftOrRightRecursiveNonterminals.contains(end)) {</b>
<b class="fc">&nbsp;                        config.pleftEnds.add(end);</b>
<b class="fc">&nbsp;                        config.pends.add(end);</b>
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                for (String end : config.rightEnds) {</b>
<b class="fc">&nbsp;                    if (leftOrRightRecursiveNonterminals.contains(end)) {</b>
<b class="fc">&nbsp;                        config.prightEnds.add(end);</b>
<b class="fc">&nbsp;                        if (!config.pends.contains(end))</b>
<b class="fc">&nbsp;                            config.pends.add(end);</b>
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;            }</b>
&nbsp;
<b class="fc">&nbsp;            for (RuntimeRule rule : grammar.getRules()) {</b>
&nbsp;
<b class="fc">&nbsp;                if (rule.getPrecedence() == -1 || !rule.isIRightRecursive())</b>
<b class="fc">&nbsp;                    continue;</b>
&nbsp;
<b class="fc">&nbsp;                Configuration config = configs.get(rule.getHead().getName());</b>
<b class="fc">&nbsp;                boolean has = config.hasPrefixBelow(rule.getPrecedenceLevel().getLhs());</b>
<b class="fc">&nbsp;                if (has &amp;&amp; !rule.getRightEnd().startsWith(&quot;$&quot;)) {</b>
<b class="fc">&nbsp;                    config.rightEndsPrefixBelow.add(rule.getRightEnd());</b>
<b class="fc">&nbsp;                    boolean changed = true;</b>
<b class="fc">&nbsp;                    while (changed) {</b>
<b class="fc">&nbsp;                        changed = false;</b>
<b class="fc">&nbsp;                        int size = config.rightEndsPrefixBelow.size();</b>
&nbsp;
<b class="fc">&nbsp;                        Set&lt;String&gt; delta = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;                        for (String end : config.rightEndsPrefixBelow) {</b>
<b class="fc">&nbsp;                            if (configs.get(end) != null) {</b>
<b class="fc">&nbsp;                                for (String right : configs.get(end).directRightEnds) {</b>
<b class="fc">&nbsp;                                    if (configs.get(right) != null</b>
<b class="fc">&nbsp;                                        &amp;&amp; configs.get(right).prightEnds.contains(rule.getHead().getName()))</b>
<b class="fc">&nbsp;                                        delta.add(right);</b>
<b class="fc">&nbsp;                                }</b>
&nbsp;                            }
<b class="fc">&nbsp;                        }</b>
&nbsp;
<b class="fc">&nbsp;                        config.rightEndsPrefixBelow.addAll(delta);</b>
<b class="fc">&nbsp;                        if (size != config.rightEndsPrefixBelow.size())</b>
<b class="fc">&nbsp;                            changed = true;</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        Set&lt;RuntimeRule&gt; rules = new LinkedHashSet&lt;&gt;();</b>
<b class="fc">&nbsp;        for (RuntimeRule rule : grammar.getRules())</b>
<b class="fc">&nbsp;            rules.add(transform(rule));</b>
&nbsp;
<b class="fc">&nbsp;        return RuntimeGrammar.builder().addRules(rules).setLayout(grammar.getLayout())</b>
<b class="fc">&nbsp;                             .setStartSymbols(grammar.getStartSymbols())</b>
<b class="fc">&nbsp;                             .setEbnfLefts(grammar.getEBNFLefts())</b>
<b class="fc">&nbsp;                             .setEbnfRights(grammar.getEBNFRights())</b>
<b class="fc">&nbsp;                             .setGlobals(grammar.getGlobals())</b>
<b class="fc">&nbsp;                             .setRegularExpressionDefinitions(grammar.getRegularExpressionDefinitions())</b>
<b class="fc">&nbsp;                             .build();</b>
&nbsp;    }
&nbsp;
&nbsp;    public RuntimeRule transform(RuntimeRule rule) {
<b class="fc">&nbsp;        return new Visitor(rule, leftOrRightRecursiveNonterminals, headsWithLabeledRules, configs,</b>
<b class="fc">&nbsp;                           config_op).transform();</b>
&nbsp;    }
&nbsp;
&nbsp;    private static class Visitor implements ISymbolVisitor&lt;Symbol&gt; {
&nbsp;
&nbsp;        private final RuntimeRule rule;
&nbsp;
&nbsp;        private final Set&lt;String&gt; leftOrRightRecursiveNonterminals;
&nbsp;
&nbsp;        private final Map&lt;String, Map&lt;String, Integer&gt;&gt; headsWithLabeledRules;
&nbsp;
&nbsp;        private Expression l1;
&nbsp;        private Expression r2;
&nbsp;
&nbsp;        private Expression l2;
&nbsp;        private Expression r1;
&nbsp;
&nbsp;        private Set&lt;Condition&gt; preconditions;
&nbsp;
&nbsp;        private boolean isFirst;
&nbsp;        private boolean isLast;
&nbsp;
&nbsp;        private final OP config_op;
&nbsp;
&nbsp;        /*
&nbsp;         *  Variables of the alternative scheme
&nbsp;         */
&nbsp;
&nbsp;        // Priority and associativity related:
&nbsp;        private final Map&lt;String, Configuration&gt; configs;
&nbsp;        private final Configuration config;
<b class="fc">&nbsp;        private int larity = 1;</b>
<b class="fc">&nbsp;        private int parity = 1;</b>
&nbsp;
<b class="fc">&nbsp;        private Expression larg = null;</b>
<b class="fc">&nbsp;        private Expression rarg = null;</b>
&nbsp;
<b class="fc">&nbsp;        private Expression lcond = null;</b>
<b class="fc">&nbsp;        private Expression rcond = null;</b>
<b class="fc">&nbsp;        private Expression ret = null;</b>
&nbsp;
&nbsp;        // ! related:
<b class="fc">&nbsp;        private Expression xlcond = null;</b>
<b class="fc">&nbsp;        private Expression xrcond = null;</b>
<b class="fc">&nbsp;        private Expression xret = null;</b>
&nbsp;
&nbsp;        private Expression[] lret;
&nbsp;        private Expression[] rret;
&nbsp;
&nbsp;        Visitor(
&nbsp;                RuntimeRule rule,
&nbsp;                Set&lt;String&gt; leftOrRightRecursiveNonterminals,
&nbsp;                Map&lt;String, Map&lt;String, Integer&gt;&gt; headsWithLabeledRules,
&nbsp;                Map&lt;String, Configuration&gt; configs,
<b class="fc">&nbsp;                OP config_op) {</b>
<b class="fc">&nbsp;            this.rule = rule;</b>
<b class="fc">&nbsp;            this.leftOrRightRecursiveNonterminals = leftOrRightRecursiveNonterminals;</b>
<b class="fc">&nbsp;            this.headsWithLabeledRules = headsWithLabeledRules;</b>
<b class="fc">&nbsp;            this.configs = configs;</b>
<b class="fc">&nbsp;            this.config = configs.get(rule.getHead().getName());</b>
<b class="fc">&nbsp;            this.larity = config.larity;</b>
<b class="fc">&nbsp;            this.parity = config.parity;</b>
&nbsp;
<b class="fc">&nbsp;            int n = config.pends.size();</b>
<b class="fc">&nbsp;            lret = new Expression[n];</b>
<b class="fc">&nbsp;            rret = new Expression[n];</b>
&nbsp;
<b class="fc">&nbsp;            for (int i = 0; i &lt; n; i++) {</b>
&nbsp;
<b class="fc">&nbsp;                String end = config.pends.get(i);</b>
&nbsp;
<b class="fc">&nbsp;                Configuration config = configs.get(end);</b>
&nbsp;
<b class="fc">&nbsp;                boolean canBeFromLeft = config.leftEnds.contains(rule.getHead().getName());</b>
<b class="fc">&nbsp;                boolean canBeFromRight = config.rightEnds.contains(rule.getHead().getName());</b>
<b class="fc">&nbsp;                boolean hasPrefixBelow = config.rightEndsPrefixBelow.contains(rule.getHead().getName());</b>
<b class="fc">&nbsp;                boolean canBecomePostfix = config.rightEndsThatCanLeadToPostfix.contains(rule.getHead().getName());</b>
&nbsp;
<b class="fc">&nbsp;                if (canBeFromLeft &amp;&amp; canBeFromRight) {</b>
<b class="nc">&nbsp;                    lret[i] = undef();</b>
<b class="nc">&nbsp;                    if (hasPrefixBelow || canBecomePostfix)</b>
<b class="nc">&nbsp;                        rret[i] = undef();</b>
&nbsp;                    else
<b class="nc">&nbsp;                        rret[i] = null;</b>
<b class="fc">&nbsp;                } else if (canBeFromLeft) {</b>
<b class="nc">&nbsp;                    lret[i] = undef();</b>
<b class="nc">&nbsp;                    rret[i] = null;</b>
<b class="fc">&nbsp;                } else if (canBeFromRight) {</b>
<b class="fc">&nbsp;                    lret[i] = null;</b>
<b class="fc">&nbsp;                    if (hasPrefixBelow || canBecomePostfix)</b>
<b class="fc">&nbsp;                        rret[i] = undef();</b>
&nbsp;                    else
<b class="fc">&nbsp;                        rret[i] = null;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            this.config_op = config_op;</b>
<b class="fc">&nbsp;            switch (config_op) {</b>
&nbsp;                case _1:
<b class="nc">&nbsp;                    excepts1();</b>
<b class="nc">&nbsp;                    precedence1();</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case _2:
<b class="fc">&nbsp;                    excepts2();</b>
<b class="fc">&nbsp;                    precedence2();</b>
&nbsp;                    break;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        private void excepts1() {
<b class="nc">&nbsp;            if (rule.getLabel() != null) {</b>
<b class="nc">&nbsp;                Map&lt;String, Integer&gt; labels = headsWithLabeledRules.get(rule.getHead().getName());</b>
<b class="nc">&nbsp;                if (labels != null &amp;&amp; labels.containsKey(rule.getLabel())) {</b>
<b class="nc">&nbsp;                    preconditions = new LinkedHashSet&lt;&gt;();</b>
<b class="nc">&nbsp;                    int l = labels.get(rule.getLabel());</b>
<b class="nc">&nbsp;                    preconditions.add(predicate(lShiftANDEqZero(var(&quot;_not&quot;), integer(l))));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        private void excepts2() {
<b class="fc">&nbsp;            Map&lt;String, Integer&gt; labels = headsWithLabeledRules.get(rule.getHead().getName());</b>
&nbsp;
<b class="fc">&nbsp;            if (labels == null) return;</b>
&nbsp;
<b class="fc">&nbsp;            if (rule.getLabel() != null &amp;&amp; labels.containsKey(rule.getLabel())) {</b>
<b class="fc">&nbsp;                int l = labels.get(rule.getLabel());</b>
<b class="fc">&nbsp;                xrcond = lShiftANDEqZero(var(&quot;_not&quot;), integer(l));</b>
<b class="fc">&nbsp;                xret = integer(l);</b>
<b class="fc">&nbsp;            } else</b>
<b class="fc">&nbsp;                xret = integer(-1);</b>
&nbsp;
<b class="fc">&nbsp;            if (rule.isLeftRecursive()) {</b>
<b class="fc">&nbsp;                Nonterminal nonterminal = (Nonterminal) rule.getBody().get(0);</b>
<b class="fc">&nbsp;                if (nonterminal.getExcepts() != null) {</b>
<b class="fc">&nbsp;                    int n = 0;</b>
<b class="fc">&nbsp;                    for (String except : nonterminal.getExcepts()) {</b>
<b class="fc">&nbsp;                        Integer i = labels.get(except);</b>
&nbsp;
<b class="fc">&nbsp;                        if (i == null)</b>
<b class="nc">&nbsp;                            throw new RuntimeException(&quot;Undeclared label: &quot; + except);</b>
&nbsp;
<b class="fc">&nbsp;                        n += 1 &lt;&lt; i;</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;
<b class="fc">&nbsp;                    if (!leftOrRightRecursiveNonterminals.contains(rule.getHead().getName()))</b>
<b class="fc">&nbsp;                        xlcond = or(equal(var(&quot;l&quot;), integer(-1)), lShiftANDEqZero(integer(n), var(&quot;l&quot;)));</b>
<b class="fc">&nbsp;                    else xlcond = or(equal(get(var(&quot;l&quot;), 1), integer(-1)),</b>
<b class="fc">&nbsp;                                     lShiftANDEqZero(integer(n), get(var(&quot;l&quot;), 1)));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        private void precedence1() { // Priority and associativity
<b class="nc">&nbsp;            if (rule.getPrecedence() == -1)</b>
&nbsp;                return; // Precedence does not apply
&nbsp;
<b class="nc">&nbsp;            if (!leftOrRightRecursiveNonterminals.contains(rule.getHead().getName()))</b>
&nbsp;                return; // Precedence does not apply
&nbsp;
<b class="nc">&nbsp;            if (preconditions == null)</b>
<b class="nc">&nbsp;                preconditions = new HashSet&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;            AssociativityGroup associativityGroup = rule.getAssociativityGroup();</b>
<b class="nc">&nbsp;            PrecedenceLevel precedenceLevel = rule.getPrecedenceLevel();</b>
&nbsp;
<b class="nc">&nbsp;            int precedence = rule.getPrecedence();</b>
<b class="nc">&nbsp;            Associativity associativity = rule.getAssociativity();</b>
&nbsp;
<b class="nc">&nbsp;            boolean nUseMin = false;</b>
&nbsp;
&nbsp;            // 1. Expressions for the left and/or right recursive uses
&nbsp;
<b class="nc">&nbsp;            if (associativityGroup != null</b>
<b class="nc">&nbsp;                &amp;&amp; precedenceLevel.getLhs() == associativityGroup.getLhs()</b>
<b class="nc">&nbsp;                &amp;&amp; precedenceLevel.getRhs() == associativityGroup.getRhs()) {</b>
&nbsp;
<b class="nc">&nbsp;                if (precedence == associativityGroup.getPrecedence()) { // Can use precedence climbing</b>
<b class="nc">&nbsp;                    boolean first = precedenceLevel.getUndefined() == 0;</b>
<b class="nc">&nbsp;                    switch (associativityGroup.getAssociativity()) {</b>
&nbsp;                        case LEFT:
<b class="nc">&nbsp;                            l1 = integer(first ? 0 : precedence);</b>
<b class="nc">&nbsp;                            r2 = integer(precedenceLevel.getRhs() + 1);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case RIGHT:
<b class="nc">&nbsp;                            l1 = integer(precedenceLevel.getRhs() + 1);</b>
<b class="nc">&nbsp;                            r2 = integer(first ? 0 : precedence);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case NON_ASSOC:
<b class="nc">&nbsp;                            l1 = integer(precedenceLevel.getRhs() + 1);</b>
<b class="nc">&nbsp;                            r2 = integer(precedenceLevel.getRhs() + 1);</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        default:
<b class="nc">&nbsp;                            throw new RuntimeException(</b>
<b class="nc">&nbsp;                                    &quot;Unexpected associativity: &quot; + associativityGroup.getAssociativity());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    // Rule for propagation of a precedence level
<b class="nc">&nbsp;                    if (precedenceLevel.hasPostfixUnaryBelow())</b>
<b class="nc">&nbsp;                        r1 = nUseMin ? var(&quot;r&quot;) : pr(precedence, precedenceLevel.postfixUnaryBelow, false);</b>
<b class="nc">&nbsp;                    else if (precedenceLevel.hasPostfixUnary())</b>
<b class="nc">&nbsp;                        r1 = integer(first ? 0 : precedence);</b>
&nbsp;                    else
<b class="nc">&nbsp;                        r1 = l1;</b>
&nbsp;
<b class="nc">&nbsp;                    if (precedenceLevel.hasPrefixUnaryBelow())</b>
<b class="nc">&nbsp;                        l2 = nUseMin ? var(&quot;l&quot;) : pr(precedence, precedenceLevel.prefixUnaryBelow, true);</b>
<b class="nc">&nbsp;                    else if (precedenceLevel.hasPrefixUnary())</b>
<b class="nc">&nbsp;                        l2 = integer(first ? 0 : precedence);</b>
&nbsp;                    else
<b class="nc">&nbsp;                        l2 = r2;</b>
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    l1 = integer(precedence);</b>
<b class="nc">&nbsp;                    r2 = integer(precedence);</b>
&nbsp;
&nbsp;                    // Rule for propagation of a precedence level
<b class="nc">&nbsp;                    l2 = nUseMin ? var(&quot;l&quot;) : precedenceLevel.hasPrefixUnaryBelow()</b>
<b class="nc">&nbsp;                            ? pr(precedence, precedenceLevel.prefixUnaryBelow, true) : integer(0);</b>
<b class="nc">&nbsp;                    r1 = nUseMin ? var(&quot;r&quot;) : precedenceLevel.hasPostfixUnaryBelow()</b>
<b class="nc">&nbsp;                            ? pr(precedence, precedenceLevel.postfixUnaryBelow, false) : integer(0);</b>
&nbsp;                }
&nbsp;                // Can use precedence climbing
<b class="nc">&nbsp;            } else if (associativityGroup == null &amp;&amp; precedenceLevel.getLhs() == precedenceLevel.getRhs()) {</b>
<b class="nc">&nbsp;                boolean first = precedenceLevel.getUndefined() == 0;</b>
<b class="nc">&nbsp;                int il1 = -1;</b>
<b class="nc">&nbsp;                int ir2 = -1;</b>
<b class="nc">&nbsp;                switch (associativity) {</b>
&nbsp;                    case LEFT:
<b class="nc">&nbsp;                        il1 = first ? 0 : precedence;</b>
<b class="nc">&nbsp;                        l1 = integer(il1);</b>
<b class="nc">&nbsp;                        ir2 = precedence + 1;</b>
<b class="nc">&nbsp;                        r2 = integer(ir2);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case RIGHT:
<b class="nc">&nbsp;                        il1 = precedence + 1;</b>
<b class="nc">&nbsp;                        l1 = integer(il1);</b>
<b class="nc">&nbsp;                        ir2 = first ? 0 : precedence;</b>
<b class="nc">&nbsp;                        r2 = integer(ir2);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case NON_ASSOC:
<b class="nc">&nbsp;                        il1 = precedence + 1;</b>
<b class="nc">&nbsp;                        l1 = integer(il1);</b>
<b class="nc">&nbsp;                        ir2 = precedence + 1;</b>
<b class="nc">&nbsp;                        r2 = integer(ir2);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case UNDEFINED:
<b class="nc">&nbsp;                        il1 = first ? 0 : precedence;</b>
<b class="nc">&nbsp;                        l1 = integer(il1);</b>
<b class="nc">&nbsp;                        ir2 = first ? 0 : precedence;</b>
<b class="nc">&nbsp;                        r2 = integer(ir2);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    default:
<b class="nc">&nbsp;                        throw new RuntimeException(&quot;Unexpected associativity: &quot; + associativity);</b>
&nbsp;                }
&nbsp;
&nbsp;                // Rule for propagation of a precedence level
<b class="nc">&nbsp;                if (precedenceLevel.hasPostfixUnaryBelow())</b>
<b class="nc">&nbsp;                    r1 = nUseMin ? var(&quot;r&quot;) : pr(precedenceLevel.hasPostfixUnary() ? precedence : il1,</b>
&nbsp;                                                 precedenceLevel.postfixUnaryBelow, false);
<b class="nc">&nbsp;                else if (precedenceLevel.hasPostfixUnary())</b>
<b class="nc">&nbsp;                    r1 = integer(first ? 0 : precedence);</b>
&nbsp;                else
<b class="nc">&nbsp;                    r1 = l1;</b>
&nbsp;
<b class="nc">&nbsp;                if (precedenceLevel.hasPrefixUnaryBelow())</b>
<b class="nc">&nbsp;                    l2 = nUseMin ? var(&quot;l&quot;) : pr(precedenceLevel.hasPrefixUnary() ? precedence : ir2,</b>
&nbsp;                                                 precedenceLevel.prefixUnaryBelow, true);
<b class="nc">&nbsp;                else if (precedenceLevel.hasPrefixUnary())</b>
<b class="nc">&nbsp;                    l2 = integer(first ? 0 : precedence);</b>
&nbsp;                else
<b class="nc">&nbsp;                    l2 = r2;</b>
<b class="nc">&nbsp;            } else { // No precedence climbing</b>
<b class="nc">&nbsp;                int undefined = precedenceLevel.getUndefined();</b>
<b class="nc">&nbsp;                boolean useUndefined = (associativityGroup == null</b>
<b class="nc">&nbsp;                                        || (associativityGroup.getPrecedence() == precedence))</b>
&nbsp;                                       &amp;&amp; undefined != -1;
&nbsp;
<b class="nc">&nbsp;                switch ((associativityGroup != null &amp;&amp; associativity == Associativity.UNDEFINED)</b>
<b class="nc">&nbsp;                        ? associativityGroup.getAssociativity() : associativity) {</b>
&nbsp;                    case LEFT:
<b class="nc">&nbsp;                        l1 = integer(useUndefined ? undefined : precedence);</b>
<b class="nc">&nbsp;                        r2 = integer(precedence);</b>
&nbsp;                        // Rule for propagation of a precedence level
<b class="nc">&nbsp;                        l2 = nUseMin ? var(&quot;l&quot;) : precedenceLevel.hasPrefixUnaryBelow()</b>
<b class="nc">&nbsp;                                ? pr(precedence, precedenceLevel.prefixUnaryBelow, true) : integer(0);</b>
<b class="nc">&nbsp;                        r1 = nUseMin ? var(&quot;r&quot;) : precedenceLevel.hasPostfixUnaryBelow()</b>
<b class="nc">&nbsp;                                ? pr(precedence, precedenceLevel.postfixUnaryBelow, false)</b>
<b class="nc">&nbsp;                                : integer(useUndefined ? undefined : 0);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case RIGHT:
<b class="nc">&nbsp;                        l1 = integer(precedence);</b>
<b class="nc">&nbsp;                        r2 = integer(useUndefined ? undefined : precedence);</b>
&nbsp;                        // Rule for propagation of a precedence level
<b class="nc">&nbsp;                        l2 = nUseMin ? var(&quot;l&quot;) : precedenceLevel.hasPrefixUnaryBelow()</b>
<b class="nc">&nbsp;                                ? pr(precedence, precedenceLevel.prefixUnaryBelow, true)</b>
<b class="nc">&nbsp;                                : integer(useUndefined ? undefined : 0);</b>
<b class="nc">&nbsp;                        r1 = nUseMin ? var(&quot;r&quot;) : precedenceLevel.hasPostfixUnaryBelow()</b>
<b class="nc">&nbsp;                                ? pr(precedence, precedenceLevel.postfixUnaryBelow, false)</b>
<b class="nc">&nbsp;                                : integer(0);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case NON_ASSOC:
<b class="nc">&nbsp;                        l1 = integer(precedence);</b>
<b class="nc">&nbsp;                        r2 = integer(precedence);</b>
&nbsp;                        // Rule for propagation of a precedence level
<b class="nc">&nbsp;                        l2 = nUseMin ? var(&quot;l&quot;) : precedenceLevel.hasPrefixUnaryBelow()</b>
<b class="nc">&nbsp;                                ? pr(precedence, precedenceLevel.prefixUnaryBelow, true)</b>
<b class="nc">&nbsp;                                : integer(0);</b>
<b class="nc">&nbsp;                        r1 = nUseMin ? var(&quot;r&quot;) : precedenceLevel.hasPostfixUnaryBelow()</b>
<b class="nc">&nbsp;                                ? pr(precedence, precedenceLevel.postfixUnaryBelow, false)</b>
<b class="nc">&nbsp;                                : integer(0);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case UNDEFINED: // Not in the associativity group
<b class="nc">&nbsp;                        l1 = integer(undefined);</b>
<b class="nc">&nbsp;                        r2 = integer(undefined);</b>
&nbsp;                        // Rule for propagation of a precedence level
<b class="nc">&nbsp;                        l2 = nUseMin ? var(&quot;l&quot;) : precedenceLevel.hasPrefixUnaryBelow()</b>
<b class="nc">&nbsp;                                ? pr(precedence, precedenceLevel.prefixUnaryBelow, true)</b>
<b class="nc">&nbsp;                                : integer(undefined);</b>
<b class="nc">&nbsp;                        r1 = nUseMin ? var(&quot;r&quot;) : precedenceLevel.hasPostfixUnaryBelow()</b>
<b class="nc">&nbsp;                                ? pr(precedence, precedenceLevel.postfixUnaryBelow, false)</b>
<b class="nc">&nbsp;                                : integer(undefined);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    default:
<b class="nc">&nbsp;                        throw new RuntimeException(&quot;Unexpected associativity: &quot; + associativity);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // 2. Constraints (preconditions) for the grammar rule
&nbsp;
<b class="nc">&nbsp;            if (rule.isLeftRecursive())</b>
<b class="nc">&nbsp;                preconditions.add(predicate(greaterEq(integer(precedenceLevel.getRhs()), var(&quot;r&quot;))));</b>
&nbsp;
<b class="nc">&nbsp;            if (rule.isRightRecursive())</b>
<b class="nc">&nbsp;                preconditions.add(predicate(greaterEq(integer(precedenceLevel.getRhs()), var(&quot;l&quot;))));</b>
&nbsp;
<b class="nc">&nbsp;            if (precedenceLevel.getLhs() != precedenceLevel.getRhs()) {</b>
&nbsp;
<b class="nc">&nbsp;                if (associativityGroup != null) {</b>
&nbsp;
<b class="nc">&nbsp;                    boolean climbing = associativityGroup.getLhs() == precedenceLevel.getLhs()</b>
<b class="nc">&nbsp;                                       &amp;&amp; associativityGroup.getRhs() == precedenceLevel.getRhs();</b>
&nbsp;
<b class="nc">&nbsp;                    switch (associativityGroup.getAssociativity()) {</b>
&nbsp;                        case LEFT:
<b class="nc">&nbsp;                            if (rule.isLeftRecursive()) {</b>
<b class="nc">&nbsp;                                if (!climbing)</b>
<b class="nc">&nbsp;                                    preconditions.add(</b>
<b class="nc">&nbsp;                                            predicate(notEqual(integer(associativityGroup.getPrecedence()), var(&quot;r&quot;))));</b>
&nbsp;
<b class="nc">&nbsp;                                if (!associativityGroup.getAssocMap().isEmpty())</b>
<b class="nc">&nbsp;                                    for (Map.Entry&lt;Integer, Associativity&gt; entry : associativityGroup.getAssocMap()</b>
<b class="nc">&nbsp;                                                                                                     .entrySet())</b>
<b class="nc">&nbsp;                                        if (precedence != entry.getKey())</b>
<b class="nc">&nbsp;                                            preconditions.add(predicate(notEqual(integer(entry.getKey()), var(&quot;r&quot;))));</b>
&nbsp;                            }
&nbsp;                            break;
&nbsp;                        case RIGHT:
<b class="nc">&nbsp;                            if (rule.isRightRecursive()) {</b>
<b class="nc">&nbsp;                                if (!climbing)</b>
<b class="nc">&nbsp;                                    preconditions.add(</b>
<b class="nc">&nbsp;                                            predicate(notEqual(integer(associativityGroup.getPrecedence()), var(&quot;l&quot;))));</b>
&nbsp;
<b class="nc">&nbsp;                                if (!associativityGroup.getAssocMap().isEmpty())</b>
<b class="nc">&nbsp;                                    for (Map.Entry&lt;Integer, Associativity&gt; entry : associativityGroup.getAssocMap()</b>
<b class="nc">&nbsp;                                                                                                     .entrySet())</b>
<b class="nc">&nbsp;                                        if (precedence != entry.getKey()</b>
<b class="nc">&nbsp;                                            &amp;&amp; !(climbing &amp;&amp; entry.getKey() == associativityGroup.getPrecedence()))</b>
<b class="nc">&nbsp;                                            preconditions.add(predicate(notEqual(integer(entry.getKey()), var(&quot;l&quot;))));</b>
&nbsp;                            }
&nbsp;                            break;
&nbsp;                        case NON_ASSOC:
<b class="nc">&nbsp;                            if (!climbing)</b>
<b class="nc">&nbsp;                                preconditions.add(</b>
<b class="nc">&nbsp;                                        predicate(notEqual(integer(associativityGroup.getPrecedence()), var(&quot;r&quot;))));</b>
<b class="nc">&nbsp;                            if (!climbing)</b>
<b class="nc">&nbsp;                                preconditions.add(</b>
<b class="nc">&nbsp;                                        predicate(notEqual(integer(associativityGroup.getPrecedence()), var(&quot;l&quot;))));</b>
&nbsp;
<b class="nc">&nbsp;                            if (!associativityGroup.getAssocMap().isEmpty()) {</b>
<b class="nc">&nbsp;                                for (Map.Entry&lt;Integer, Associativity&gt; entry : associativityGroup.getAssocMap()</b>
<b class="nc">&nbsp;                                                                                                 .entrySet()) {</b>
<b class="nc">&nbsp;                                    if (precedence != entry.getKey()</b>
<b class="nc">&nbsp;                                        &amp;&amp; !(climbing &amp;&amp; entry.getKey() == associativityGroup.getPrecedence())) {</b>
<b class="nc">&nbsp;                                        preconditions.add(predicate(notEqual(integer(entry.getKey()), var(&quot;r&quot;))));</b>
<b class="nc">&nbsp;                                        preconditions.add(predicate(notEqual(integer(entry.getKey()), var(&quot;l&quot;))));</b>
&nbsp;                                    }
<b class="nc">&nbsp;                                }</b>
&nbsp;                            }
&nbsp;                            break;
&nbsp;                        default:
<b class="nc">&nbsp;                            throw new RuntimeException(</b>
<b class="nc">&nbsp;                                    &quot;Unexpected associativity: &quot; + associativityGroup.getAssociativity());</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    if (precedence != associativityGroup.getPrecedence()) {</b>
<b class="nc">&nbsp;                        switch (associativity) {</b>
&nbsp;                            case LEFT:
<b class="nc">&nbsp;                                if (rule.isLeftRecursive())</b>
<b class="nc">&nbsp;                                    preconditions.add(predicate(notEqual(integer(precedence), var(&quot;r&quot;))));</b>
&nbsp;                                break;
&nbsp;                            case RIGHT:
<b class="nc">&nbsp;                                if (rule.isRightRecursive())</b>
<b class="nc">&nbsp;                                    preconditions.add(predicate(notEqual(integer(precedence), var(&quot;l&quot;))));</b>
&nbsp;                                break;
&nbsp;                            case NON_ASSOC:
<b class="nc">&nbsp;                                preconditions.add(predicate(notEqual(integer(precedence), var(&quot;l&quot;))));</b>
<b class="nc">&nbsp;                                preconditions.add(predicate(notEqual(integer(precedence), var(&quot;r&quot;))));</b>
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            case UNDEFINED:
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            default:
<b class="nc">&nbsp;                                throw new RuntimeException(&quot;Unexpected associativity: &quot; + associativity);</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    switch (associativity) {</b>
&nbsp;                        case LEFT:
<b class="nc">&nbsp;                            if (rule.isLeftRecursive())</b>
<b class="nc">&nbsp;                                preconditions.add(predicate(notEqual(integer(precedence), var(&quot;r&quot;))));</b>
&nbsp;                            break;
&nbsp;                        case RIGHT:
<b class="nc">&nbsp;                            if (rule.isRightRecursive())</b>
<b class="nc">&nbsp;                                preconditions.add(predicate(notEqual(integer(precedence), var(&quot;l&quot;))));</b>
&nbsp;                            break;
&nbsp;                        case NON_ASSOC:
<b class="nc">&nbsp;                            preconditions.add(predicate(notEqual(integer(precedence), var(&quot;l&quot;))));</b>
<b class="nc">&nbsp;                            preconditions.add(predicate(notEqual(integer(precedence), var(&quot;r&quot;))));</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case UNDEFINED:
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        default:
<b class="nc">&nbsp;                            throw new RuntimeException(&quot;Unexpected associativity: &quot; + associativity);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        private void precedence2() { // Priority and associativity
&nbsp;
<b class="fc">&nbsp;            if (!leftOrRightRecursiveNonterminals.contains(rule.getHead().getName()))</b>
&nbsp;                return; // Precedence does not apply
&nbsp;
<b class="fc">&nbsp;            if (rule.getPrecedence() == -1) {</b>
<b class="fc">&nbsp;                if (this.larity == 1)</b>
<b class="fc">&nbsp;                    ret = integer(0);</b>
&nbsp;                else
<b class="fc">&nbsp;                    ret = tuple(integer(0), integer(0));</b>
&nbsp;                return; // Precedence does not apply
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            PrecedenceLevel prec_level = rule.getPrecedenceLevel();</b>
<b class="fc">&nbsp;            AssociativityGroup assoc_group = rule.getAssociativityGroup();</b>
&nbsp;
<b class="fc">&nbsp;            int prec = rule.getPrecedence();</b>
<b class="fc">&nbsp;            Associativity assoc = rule.getAssociativity();</b>
&nbsp;
<b class="fc">&nbsp;            int undefined = prec_level.getUndefined();</b>
<b class="fc">&nbsp;            boolean first = undefined == 0;</b>
&nbsp;
<b class="fc">&nbsp;            boolean labeled = headsWithLabeledRules.containsKey(rule.getHead().getName());</b>
&nbsp;
&nbsp;            // Either prec or (prec,assoc)
<b class="fc">&nbsp;            Expression lprec = null;</b>
<b class="fc">&nbsp;            Expression lassoc = null;</b>
<b class="fc">&nbsp;            Expression rprec = null;</b>
<b class="fc">&nbsp;            Expression pprec = null;</b>
<b class="fc">&nbsp;            Expression passoc = null;</b>
&nbsp;
<b class="fc">&nbsp;            if (labeled &amp;&amp; larity == 2) {</b>
<b class="nc">&nbsp;                lprec = get(get(var(&quot;l&quot;), 0), 0);  // l.0.0</b>
<b class="nc">&nbsp;                lassoc = get(get(var(&quot;l&quot;), 0), 1); // l.0.1</b>
<b class="nc">&nbsp;                rprec = get(get(var(&quot;r&quot;), 0), 0);  // r.0.0</b>
<b class="fc">&nbsp;            } else if (labeled &amp;&amp; larity != 2) {</b>
<b class="fc">&nbsp;                lprec = get(var(&quot;l&quot;), 0);  // l.0</b>
<b class="fc">&nbsp;                lassoc = get(var(&quot;l&quot;), 0); // l.0</b>
<b class="fc">&nbsp;                rprec = get(var(&quot;r&quot;), 0);  // l.0</b>
<b class="fc">&nbsp;            } else if (!labeled &amp;&amp; larity == 2) {</b>
<b class="fc">&nbsp;                lprec = get(var(&quot;l&quot;), 0);  // l.0</b>
<b class="fc">&nbsp;                lassoc = get(var(&quot;l&quot;), 1); // l.1</b>
<b class="fc">&nbsp;                rprec = get(var(&quot;r&quot;), 0);  // l.0</b>
&nbsp;            } else {
<b class="fc">&nbsp;                lprec = var(&quot;l&quot;);</b>
<b class="fc">&nbsp;                lassoc = var(&quot;l&quot;);</b>
<b class="fc">&nbsp;                rprec = var(&quot;r&quot;);</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (parity == 2) {</b>
<b class="fc">&nbsp;                pprec = get(var(&quot;p&quot;), 0);  // p.0</b>
<b class="fc">&nbsp;                passoc = get(var(&quot;p&quot;), 1); // p.1</b>
&nbsp;            } else {
<b class="fc">&nbsp;                pprec = var(&quot;p&quot;);  // p</b>
<b class="fc">&nbsp;                passoc = var(&quot;p&quot;); // p</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (parity == 2)</b>
<b class="fc">&nbsp;                larg = tuple(pprec, integer(0));</b>
&nbsp;            else
<b class="fc">&nbsp;                larg = pprec;</b>
&nbsp;
<b class="fc">&nbsp;            boolean canBePrefix = false;</b>
<b class="fc">&nbsp;            boolean canBePostfix = false;</b>
&nbsp;
<b class="fc">&nbsp;            if (rule.isLeftRecursive() &amp;&amp; rule.isIRightRecursive())</b>
<b class="fc">&nbsp;                canBePostfix = canBePostfix(rule.getHead().getName(), rule.getRightEnd(), configs, false);</b>
&nbsp;
<b class="fc">&nbsp;            if (rule.isILeftRecursive() &amp;&amp; rule.isRightRecursive())</b>
<b class="nc">&nbsp;                canBePrefix = canBePrefix(rule.getHead().getName(), rule.getLeftEnd(), configs);</b>
&nbsp;
<b class="fc">&nbsp;            if (rule.isILeftRecursive() &amp;&amp; !rule.isRightRecursive() &amp;&amp; !rule.isIRightRecursive())</b>
<b class="nc">&nbsp;                canBePostfix = true;</b>
&nbsp;
<b class="fc">&nbsp;            if (!rule.isLeftRecursive() &amp;&amp; !rule.isILeftRecursive() &amp;&amp; rule.isIRightRecursive())</b>
<b class="nc">&nbsp;                canBePrefix = true;</b>
&nbsp;
<b class="fc">&nbsp;            if (rule.isILeftRecursive() &amp;&amp; rule.isIRightRecursive()) {</b>
<b class="nc">&nbsp;                canBePrefix = canBePrefix(rule.getHead().getName(), rule.getLeftEnd(), configs);</b>
<b class="nc">&nbsp;                canBePostfix = canBePostfix(rule.getHead().getName(), rule.getRightEnd(), configs, false);</b>
&nbsp;            }
&nbsp;
&nbsp;            // 1. Expressions for the left and/or right recursive uses
<b class="fc">&nbsp;            if (assoc_group != null) {</b>
&nbsp;
<b class="fc">&nbsp;                if ((rule.isILeftRecursive()</b>
<b class="fc">&nbsp;                     || rule.isIRightRecursive() &amp;&amp; assoc_group.getAssociativity() != Associativity.NON_ASSOC))</b>
<b class="nc">&nbsp;                    throw new RuntimeException(</b>
&nbsp;                            &quot;Not yet implemented: indirect recursion inside a left or right associativity group&quot;);
&nbsp;
&nbsp;                // Local to an associativity group
<b class="fc">&nbsp;                int arity = config.groups.get(prec_level.getLhs()) == null ? 1 : config.groups.get(prec_level.getLhs());</b>
<b class="fc">&nbsp;                int larity = (arity == 2 || arity == 4) ? 2 : 1;</b>
<b class="fc">&nbsp;                int parity = (arity == 3 || arity == 4) ? 2 : 1;</b>
&nbsp;
<b class="fc">&nbsp;                if (assoc_group.getLhs() == prec_level.getLhs() &amp;&amp; assoc_group.getRhs() == prec_level.getRhs())</b>
<b class="fc">&nbsp;                    undefined = assoc_group.getPrecedence();</b>
&nbsp;
&nbsp;                // ***Climbing condition now: larity == 1 || parity == 1
&nbsp;
<b class="fc">&nbsp;                Expression negative = lessEq(lprec, integer(0));</b>
&nbsp;
<b class="fc">&nbsp;                switch (assoc_group.getAssociativity()) {</b>
&nbsp;
&nbsp;                    case LEFT: // restricts right end
&nbsp;
<b class="fc">&nbsp;                        if (rule.isLeftRecursive())</b>
<b class="fc">&nbsp;                            lcond = or(negative, greaterEq(lprec, integer(prec_level.getLhs())));</b>
&nbsp;
<b class="fc">&nbsp;                        if (rule.isLeftRecursive()) {</b>
&nbsp;
<b class="fc">&nbsp;                            rcond = greaterEq(integer(prec_level.getRhs()), pprec);</b>
&nbsp;
<b class="fc">&nbsp;                            if (parity == 1) {</b>
<b class="fc">&nbsp;                                Set&lt;Integer&gt; prefix_rules = config.prefix_rules.get(prec_level.getLhs());</b>
<b class="fc">&nbsp;                                Set&lt;Integer&gt; non_assoc_rules = config.non_assoc_rules.get(prec_level.getLhs());</b>
&nbsp;
<b class="fc">&nbsp;                                if (prefix_rules != null &amp;&amp; non_assoc_rules != null) {</b>
<b class="nc">&nbsp;                                    for (int p : prefix_rules)</b>
<b class="nc">&nbsp;                                        if (non_assoc_rules.contains(p))</b>
<b class="nc">&nbsp;                                            rcond = and(rcond, not(equal(pprec, integer(p))));</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;
<b class="fc">&nbsp;                            if (parity == 2) {</b>
<b class="fc">&nbsp;                                if (rule.getAssociativity() == Associativity.RIGHT)</b>
<b class="fc">&nbsp;                                    rcond = and(rcond, or(equal(passoc, integer(prec)),</b>
<b class="fc">&nbsp;                                                          not(and(greaterEq(integer(assoc_group.getRhs()), passoc),</b>
<b class="fc">&nbsp;                                                                  greaterEq(passoc, integer(assoc_group.getLhs()))))));</b>
&nbsp;                                else
<b class="fc">&nbsp;                                    rcond = and(rcond, not(and(greaterEq(integer(assoc_group.getRhs()), passoc),</b>
<b class="fc">&nbsp;                                                               greaterEq(passoc, integer(assoc_group.getLhs())))));</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;
<b class="fc">&nbsp;                        if (parity == 2) {</b>
<b class="fc">&nbsp;                            rarg = tuple(integer(prec_level.getRhs()), integer(prec)); // as constrained right end</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            if (this.parity == 2)</b>
<b class="nc">&nbsp;                                rarg = tuple(integer(prec_level.getRhs() + 1), integer(0));</b>
&nbsp;                            else
<b class="fc">&nbsp;                                rarg = integer(prec_level.getRhs() + 1);</b>
&nbsp;                        }
&nbsp;
<b class="fc">&nbsp;                        if (rule.isRightRecursive()) {</b>
<b class="fc">&nbsp;                            if (prec_level.hasPrefixUnaryBelow()) {</b>
<b class="fc">&nbsp;                                if (larity == 2)</b>
&nbsp;                                    // as unconstrained left end
<b class="nc">&nbsp;                                    ret = tuple(minimum(prec_level.getLhs(), rprec), integer(0));</b>
&nbsp;                                else {
<b class="fc">&nbsp;                                    if (this.larity == 2)</b>
&nbsp;                                        // as unconstrained left end
<b class="nc">&nbsp;                                        ret = tuple(minimum(undefined != -1 ? undefined : prec, rprec), integer(0));</b>
&nbsp;                                    else
&nbsp;                                        // as unconstrained left end
<b class="fc">&nbsp;                                        ret = minimum(undefined != -1 ? undefined : prec, rprec);</b>
&nbsp;                                }
&nbsp;                            } else {
<b class="fc">&nbsp;                                if (larity == 2)</b>
<b class="fc">&nbsp;                                    ret = tuple(integer(prec_level.getLhs()), integer(0));</b>
&nbsp;                                else {
<b class="fc">&nbsp;                                    if (this.larity == 2)</b>
<b class="nc">&nbsp;                                        ret = tuple(integer(undefined != -1 ? undefined : prec), integer(0));</b>
&nbsp;                                    else
<b class="fc">&nbsp;                                        ret = integer(undefined != -1 ? undefined : prec);</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;                        } else {
<b class="nc">&nbsp;                            if (this.larity == 2)</b>
<b class="nc">&nbsp;                                ret = tuple(integer(0), integer(0));</b>
&nbsp;                            else
<b class="nc">&nbsp;                                ret = integer(0);</b>
&nbsp;                        }
&nbsp;
<b class="fc">&nbsp;                        if (prec != assoc_group.getPrecedence()) {</b>
&nbsp;
<b class="fc">&nbsp;                            switch (rule.getAssociativity()) {</b>
&nbsp;
&nbsp;                                case NON_ASSOC:
<b class="nc">&nbsp;                                    if (rule.isLeftRecursive() &amp;&amp; rule.isRightRecursive()) {</b>
&nbsp;
<b class="nc">&nbsp;                                        if (larity == 2)</b>
<b class="nc">&nbsp;                                            lcond = and(or(negative, greaterEq(lprec, integer(prec_level.getLhs()))),</b>
<b class="nc">&nbsp;                                                        notEqual(lassoc, integer(prec)));</b>
&nbsp;                                        else
<b class="nc">&nbsp;                                            lcond = or(negative, and(notEqual(lprec, integer(prec)),</b>
<b class="nc">&nbsp;                                                                     greaterEq(lprec, integer(prec_level.getLhs()))));</b>
<b class="nc">&nbsp;                                        if (parity == 2)</b>
<b class="nc">&nbsp;                                            rarg = tuple(integer(prec_level.getRhs()),</b>
&nbsp;                                                         // as constrained right end
<b class="nc">&nbsp;                                                         integer(assoc_group.getPrecedence() != -1</b>
<b class="nc">&nbsp;                                                                         ? assoc_group.getPrecedence() : prec));</b>
&nbsp;
<b class="nc">&nbsp;                                        if (prec_level.hasPrefixUnaryBelow()) {</b>
<b class="nc">&nbsp;                                            if (larity == 2)</b>
<b class="nc">&nbsp;                                                ret = tuple(minimum(prec_level.getLhs(), rprec), integer(prec));</b>
&nbsp;                                            else {
<b class="nc">&nbsp;                                                if (this.larity == 2)</b>
<b class="nc">&nbsp;                                                    ret = tuple(minimum(prec, rprec), integer(0));</b>
&nbsp;                                                else
<b class="nc">&nbsp;                                                    ret = minimum(prec, rprec);</b>
&nbsp;                                            }
&nbsp;                                        } else {
<b class="nc">&nbsp;                                            if (larity == 2)</b>
<b class="nc">&nbsp;                                                ret = tuple(integer(prec_level.getLhs()), integer(prec));</b>
&nbsp;                                            else {
<b class="nc">&nbsp;                                                if (this.larity == 2)</b>
<b class="nc">&nbsp;                                                    ret = tuple(integer(prec), integer(0));</b>
&nbsp;                                                else
<b class="nc">&nbsp;                                                    ret = integer(prec);</b>
&nbsp;                                            }
&nbsp;                                        }
&nbsp;
<b class="nc">&nbsp;                                    } else if (rule.isLeftRecursive()) {</b>
&nbsp;
<b class="nc">&nbsp;                                        if (larity == 2) {</b>
<b class="nc">&nbsp;                                            lcond = and(or(negative, greaterEq(lprec, integer(prec_level.getLhs()))),</b>
<b class="nc">&nbsp;                                                        notEqual(lassoc, neg(integer(prec))));</b>
<b class="nc">&nbsp;                                            ret = tuple(integer(0), neg(integer(prec)));</b>
&nbsp;                                        } else {
<b class="nc">&nbsp;                                            lcond = or(and(negative, notEqual(lprec, neg(integer(prec)))),</b>
<b class="nc">&nbsp;                                                       greaterEq(lprec, integer(prec_level.getLhs())));</b>
<b class="nc">&nbsp;                                            if (this.larity == 2)</b>
<b class="nc">&nbsp;                                                ret = tuple(neg(integer(prec)), integer(0));</b>
&nbsp;                                            else
<b class="nc">&nbsp;                                                ret = neg(integer(prec));</b>
&nbsp;                                        }
&nbsp;
&nbsp;                                    } else {
<b class="nc">&nbsp;                                        if (parity == 1) {</b>
<b class="nc">&nbsp;                                            if (this.parity == 2)</b>
<b class="nc">&nbsp;                                                rarg = tuple(integer(prec), integer(0));</b>
&nbsp;                                            else
<b class="nc">&nbsp;                                                rarg = integer(prec);</b>
&nbsp;                                        }
&nbsp;
<b class="nc">&nbsp;                                        rcond = notEqual(parity == 2 ? passoc : pprec, integer(prec));</b>
&nbsp;                                    }
<b class="nc">&nbsp;                                    break;</b>
&nbsp;                                case RIGHT: // larity == 2
<b class="fc">&nbsp;                                    if (rule.isLeftRecursive() &amp;&amp; rule.isRightRecursive()) {</b>
&nbsp;
<b class="fc">&nbsp;                                        lcond = and(or(negative, greaterEq(lprec, integer(prec_level.getLhs()))),</b>
<b class="fc">&nbsp;                                                    notEqual(lassoc, integer(prec)));</b>
&nbsp;
<b class="fc">&nbsp;                                        if (prec_level.hasPrefixUnaryBelow()) {</b>
<b class="nc">&nbsp;                                            if (larity == 2)</b>
<b class="nc">&nbsp;                                                ret = tuple(minimum(prec_level.getLhs(), rprec), integer(prec));</b>
&nbsp;                                            else {
<b class="nc">&nbsp;                                                if (this.larity == 2)</b>
<b class="nc">&nbsp;                                                    ret = tuple(minimum(prec, rprec), integer(0));</b>
&nbsp;                                                else
<b class="nc">&nbsp;                                                    ret = minimum(prec, rprec);</b>
&nbsp;                                            }
&nbsp;                                        } else {
<b class="fc">&nbsp;                                            if (larity == 2)</b>
<b class="fc">&nbsp;                                                ret = tuple(integer(prec_level.getLhs()), integer(prec));</b>
&nbsp;                                            else {
<b class="nc">&nbsp;                                                if (this.larity == 2)</b>
<b class="nc">&nbsp;                                                    ret = tuple(integer(prec), integer(0));</b>
&nbsp;                                                else
<b class="nc">&nbsp;                                                    ret = integer(prec);</b>
&nbsp;                                            }
&nbsp;                                        }
&nbsp;                                    }
&nbsp;                                    break;
&nbsp;                                default:
<b class="nc">&nbsp;                                    break;</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        break;
&nbsp;
&nbsp;                    case RIGHT: // restricts left end
&nbsp;
<b class="nc">&nbsp;                        if (rule.isLeftRecursive()) {</b>
&nbsp;
<b class="nc">&nbsp;                            if (larity == 2) {</b>
<b class="nc">&nbsp;                                if (rule.getAssociativity() == Associativity.LEFT) {</b>
<b class="nc">&nbsp;                                    lcond = and(or(negative, greaterEq(lprec, integer(prec_level.getLhs()))),</b>
<b class="nc">&nbsp;                                                or(lessEq(lassoc, integer(0)),</b>
<b class="nc">&nbsp;                                                   or(equal(lassoc, integer(prec)),</b>
<b class="nc">&nbsp;                                                      not(and(greaterEq(integer(assoc_group.getRhs()), lassoc),</b>
<b class="nc">&nbsp;                                                              greaterEq(lassoc, integer(assoc_group.getLhs())))))));</b>
&nbsp;                                } else
<b class="nc">&nbsp;                                    lcond = and(or(negative, greaterEq(lprec, integer(prec_level.getLhs()))),</b>
<b class="nc">&nbsp;                                                or(lessEq(lassoc, integer(0)),</b>
<b class="nc">&nbsp;                                                   not(and(greaterEq(integer(assoc_group.getRhs()), lassoc),</b>
<b class="nc">&nbsp;                                                           greaterEq(lassoc, integer(assoc_group.getLhs()))))));</b>
&nbsp;                            } else
<b class="nc">&nbsp;                                lcond = or(negative, greaterEq(lprec, integer(prec_level.getRhs() + 1)));</b>
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        if (rule.isLeftRecursive())</b>
<b class="nc">&nbsp;                            rcond = greaterEq(integer(prec_level.getRhs()), pprec);</b>
&nbsp;
<b class="nc">&nbsp;                        if (parity == 2)</b>
<b class="nc">&nbsp;                            rarg = tuple(integer(prec_level.getRhs()), integer(0)); // as right end is unconstrained</b>
&nbsp;                        else {
<b class="nc">&nbsp;                            if (this.parity == 2)</b>
&nbsp;                                // as right end is unconstrained
<b class="nc">&nbsp;                                rarg = tuple(integer(undefined != -1 ? undefined : prec), integer(0));</b>
&nbsp;                            else
<b class="nc">&nbsp;                                rarg = integer(undefined != -1 ? undefined : prec); // as right end is unconstrained</b>
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        if (rule.isRightRecursive()) {</b>
&nbsp;
<b class="nc">&nbsp;                            if (prec_level.hasPrefixUnaryBelow()) {</b>
<b class="nc">&nbsp;                                if (larity == 2)</b>
&nbsp;                                    // as constrained left end
<b class="nc">&nbsp;                                    ret = tuple(minimum(prec_level.getLhs(), rprec), integer(prec));</b>
&nbsp;                                else {
<b class="nc">&nbsp;                                    if (this.larity == 2)</b>
<b class="nc">&nbsp;                                        ret = tuple(minimum(prec, rprec), integer(0)); // as constrained left end</b>
&nbsp;                                    else
<b class="nc">&nbsp;                                        ret = minimum(prec, rprec); // as constrained left end</b>
&nbsp;                                }
&nbsp;                            } else {
<b class="nc">&nbsp;                                if (larity == 2)</b>
<b class="nc">&nbsp;                                    ret = tuple(integer(prec_level.getLhs()), integer(prec));</b>
&nbsp;                                else {
<b class="nc">&nbsp;                                    if (this.larity == 2)</b>
<b class="nc">&nbsp;                                        ret = tuple(integer(prec), integer(0));</b>
&nbsp;                                    else
<b class="nc">&nbsp;                                        ret = integer(prec);</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                        } else {
<b class="nc">&nbsp;                            if (parity == 2)</b>
<b class="nc">&nbsp;                                ret = tuple(integer(0), integer(0));</b>
&nbsp;                            else
<b class="nc">&nbsp;                                ret = integer(0);</b>
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        if (prec != assoc_group.getPrecedence()) {</b>
&nbsp;
<b class="nc">&nbsp;                            switch (rule.getAssociativity()) {</b>
&nbsp;
&nbsp;                                case NON_ASSOC:
<b class="nc">&nbsp;                                    if (rule.isLeftRecursive() &amp;&amp; rule.isRightRecursive()) {</b>
&nbsp;
<b class="nc">&nbsp;                                        if (parity == 2) {</b>
<b class="nc">&nbsp;                                            rarg = tuple(integer(prec_level.getRhs()), integer(prec));</b>
&nbsp;                                        } else {
<b class="nc">&nbsp;                                            if (this.parity == 2)</b>
<b class="nc">&nbsp;                                                rarg = tuple(integer(prec), integer(0));</b>
&nbsp;                                            else
<b class="nc">&nbsp;                                                rarg = integer(prec);</b>
&nbsp;                                        }
&nbsp;
<b class="nc">&nbsp;                                        rcond = and(greaterEq(integer(prec_level.getRhs()), pprec),</b>
<b class="nc">&nbsp;                                                    not(equal(parity == 2 ? passoc : pprec, integer(prec))));</b>
&nbsp;
&nbsp;                                        int newprec =
<b class="nc">&nbsp;                                                assoc_group.getPrecedence() != -1 ? assoc_group.getPrecedence() : prec;</b>
<b class="nc">&nbsp;                                        if (prec_level.hasPrefixUnaryBelow()) {</b>
<b class="nc">&nbsp;                                            if (larity == 2)</b>
<b class="nc">&nbsp;                                                ret = tuple(minimum(prec_level.getLhs(), rprec), integer(newprec));</b>
&nbsp;                                            else {
<b class="nc">&nbsp;                                                if (this.larity == 2)</b>
<b class="nc">&nbsp;                                                    ret = tuple(minimum(newprec, rprec), integer(0));</b>
&nbsp;                                                else
<b class="nc">&nbsp;                                                    ret = minimum(newprec, rprec);</b>
&nbsp;                                            }
&nbsp;                                        } else {
<b class="nc">&nbsp;                                            if (larity == 2)</b>
<b class="nc">&nbsp;                                                ret = tuple(integer(prec_level.getLhs()), integer(newprec));</b>
&nbsp;                                            else {
<b class="nc">&nbsp;                                                if (this.larity == 2)</b>
<b class="nc">&nbsp;                                                    ret = tuple(integer(newprec), integer(0));</b>
&nbsp;                                                else
<b class="nc">&nbsp;                                                    ret = integer(newprec);</b>
&nbsp;                                            }
&nbsp;                                        }
&nbsp;
<b class="nc">&nbsp;                                    } else if (rule.isLeftRecursive()) {</b>
&nbsp;
<b class="nc">&nbsp;                                        if (larity == 2) {</b>
<b class="nc">&nbsp;                                            lcond = and(or(negative, greaterEq(lprec, integer(prec_level.getLhs()))),</b>
<b class="nc">&nbsp;                                                        or(and(lessEq(lassoc, integer(0)),</b>
<b class="nc">&nbsp;                                                               notEqual(lassoc, neg(integer(prec)))),</b>
<b class="nc">&nbsp;                                                           and(greater(lassoc, integer(0)),</b>
<b class="nc">&nbsp;                                                               not(and(greaterEq(integer(assoc_group.getRhs()), lassoc),</b>
<b class="nc">&nbsp;                                                                       greaterEq(lassoc,</b>
<b class="nc">&nbsp;                                                                                 integer(assoc_group.getLhs())))))));</b>
&nbsp;
<b class="nc">&nbsp;                                            ret = tuple(integer(0), neg(integer(prec)));</b>
&nbsp;                                        } else {
<b class="nc">&nbsp;                                            lcond = or(and(negative, notEqual(lprec, neg(integer(prec)))),</b>
<b class="nc">&nbsp;                                                       greaterEq(lprec, integer(prec_level.getRhs() + 1)));</b>
<b class="nc">&nbsp;                                            if (this.larity == 2)</b>
<b class="nc">&nbsp;                                                ret = tuple(neg(integer(prec)), integer(0));</b>
&nbsp;                                            else
<b class="nc">&nbsp;                                                ret = neg(integer(prec));</b>
&nbsp;                                        }
&nbsp;
&nbsp;                                    } else {
&nbsp;
<b class="nc">&nbsp;                                        if (parity == 2)</b>
<b class="nc">&nbsp;                                            rarg = tuple(integer(prec_level.getRhs()), integer(prec));</b>
&nbsp;                                        else {
<b class="nc">&nbsp;                                            if (this.parity == 2)</b>
<b class="nc">&nbsp;                                                rarg = tuple(integer(prec), integer(0));</b>
&nbsp;                                            else
<b class="nc">&nbsp;                                                rarg = integer(prec);</b>
&nbsp;                                        }
&nbsp;
<b class="nc">&nbsp;                                        rcond = not(equal(parity == 2 ? passoc : pprec, integer(prec)));</b>
&nbsp;
&nbsp;                                        int newprec =
<b class="nc">&nbsp;                                                assoc_group.getPrecedence() != -1 ? assoc_group.getPrecedence() : prec;</b>
<b class="nc">&nbsp;                                        if (prec_level.hasPrefixUnaryBelow()) {</b>
<b class="nc">&nbsp;                                            if (larity == 2)</b>
<b class="nc">&nbsp;                                                ret = tuple(minimum(prec_level.getLhs(), rprec), integer(newprec));</b>
&nbsp;                                            else {
<b class="nc">&nbsp;                                                if (this.larity == 2)</b>
<b class="nc">&nbsp;                                                    ret = tuple(minimum(newprec, rprec), integer(0));</b>
&nbsp;                                                else
<b class="nc">&nbsp;                                                    ret = minimum(newprec, rprec);</b>
&nbsp;                                            }
&nbsp;                                        } else {
<b class="nc">&nbsp;                                            if (larity == 2)</b>
<b class="nc">&nbsp;                                                ret = tuple(integer(prec_level.getLhs()), integer(newprec));</b>
&nbsp;                                            else {
<b class="nc">&nbsp;                                                if (this.larity == 2)</b>
<b class="nc">&nbsp;                                                    ret = tuple(integer(newprec), integer(0));</b>
&nbsp;                                                else
<b class="nc">&nbsp;                                                    ret = integer(newprec);</b>
&nbsp;                                            }
&nbsp;                                        }
&nbsp;                                    }
<b class="nc">&nbsp;                                    break;</b>
&nbsp;                                case LEFT: // parity == 2
<b class="nc">&nbsp;                                    if (rule.isLeftRecursive() &amp;&amp; rule.isRightRecursive()) {</b>
<b class="nc">&nbsp;                                        rarg = tuple(integer(prec_level.getRhs()), integer(prec));</b>
&nbsp;
<b class="nc">&nbsp;                                        rcond = and(greaterEq(integer(prec_level.getRhs()), pprec),</b>
<b class="nc">&nbsp;                                                    not(equal(passoc, integer(prec))));</b>
&nbsp;                                    }
&nbsp;                                    break;
&nbsp;                                default:
<b class="nc">&nbsp;                                    break;</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        break;
&nbsp;                    // restricts both ends (in contrast to other associativity groups applies regardless ends)
&nbsp;                    case NON_ASSOC:
&nbsp;
<b class="fc">&nbsp;                        if (larity == 1 &amp;&amp; parity == 1 &amp;&amp; !config.hasPrefix(prec_level.getLhs())</b>
<b class="fc">&nbsp;                            &amp;&amp; !config.hasPostfix(prec_level.getLhs())) {</b>
&nbsp;
<b class="fc">&nbsp;                            lcond = or(negative, greaterEq(lprec, integer(prec_level.getRhs() + 1)));</b>
&nbsp;
<b class="fc">&nbsp;                            rcond = greaterEq(integer(prec_level.getRhs()), pprec);</b>
&nbsp;
<b class="fc">&nbsp;                            if (this.parity == 2)</b>
<b class="nc">&nbsp;                                rarg = tuple(integer(prec_level.getRhs() + 1), integer(0));</b>
&nbsp;                            else
<b class="fc">&nbsp;                                rarg = integer(prec_level.getRhs() + 1);</b>
&nbsp;
<b class="fc">&nbsp;                            if (prec_level.hasPrefixUnaryBelow()) {</b>
<b class="nc">&nbsp;                                if (this.larity == 2)</b>
<b class="nc">&nbsp;                                    ret = tuple(minimum(prec, rprec), integer(0));</b>
&nbsp;                                else
<b class="nc">&nbsp;                                    ret = minimum(prec, rprec);</b>
&nbsp;                            } else {
<b class="fc">&nbsp;                                if (this.larity == 2)</b>
<b class="nc">&nbsp;                                    ret = tuple(integer(prec), integer(0));</b>
&nbsp;                                else
<b class="fc">&nbsp;                                    ret = integer(prec);</b>
&nbsp;                            }
&nbsp;
&nbsp;                        } else {
&nbsp;
<b class="fc">&nbsp;                            if (rule.isLeftRecursive() || rule.isILeftRecursive()) {</b>
&nbsp;
<b class="fc">&nbsp;                                if (rule.getAssociativity() == Associativity.LEFT) // larity == 2</b>
<b class="nc">&nbsp;                                    lcond = and(or(and(lessEq(lassoc, integer(0)),</b>
<b class="nc">&nbsp;                                                       not(and(greaterEq(neg(integer(assoc_group.getLhs())), lassoc),</b>
<b class="nc">&nbsp;                                                               greaterEq(lassoc, neg(integer(assoc_group.getRhs())))))),</b>
<b class="nc">&nbsp;                                                   and(greater(lassoc, integer(0)),</b>
<b class="nc">&nbsp;                                                       or(equal(lassoc, integer(prec)),</b>
<b class="nc">&nbsp;                                                          not(and(greaterEq(integer(assoc_group.getRhs()), lassoc),</b>
<b class="nc">&nbsp;                                                                  greaterEq(lassoc, integer(assoc_group.getLhs()))))))),</b>
<b class="nc">&nbsp;                                                or(negative, greaterEq(lprec, integer(prec_level.getLhs()))));</b>
&nbsp;                                else
<b class="fc">&nbsp;                                    lcond = and(or(and(lessEq(larity == 2 ? lassoc : lprec, integer(0)),</b>
<b class="fc">&nbsp;                                                       assoc_group.getLhs() == assoc_group.getRhs()</b>
<b class="fc">&nbsp;                                                               ? notEqual(larity == 2 ? lassoc : lprec,</b>
<b class="fc">&nbsp;                                                                        neg(integer(assoc_group.getLhs())))</b>
<b class="nc">&nbsp;                                                               : not(and(greaterEq(neg(integer(assoc_group.getLhs())),</b>
<b class="nc">&nbsp;                                                                                   larity == 2 ? lassoc : lprec),</b>
<b class="nc">&nbsp;                                                                         greaterEq(larity == 2 ? lassoc : lprec,</b>
<b class="nc">&nbsp;                                                                                   neg(integer(</b>
<b class="nc">&nbsp;                                                                                           assoc_group.getRhs())))))),</b>
<b class="fc">&nbsp;                                                   and(greater(larity == 2 ? lassoc : lprec, integer(0)),</b>
<b class="fc">&nbsp;                                                       assoc_group.getLhs() == assoc_group.getRhs()</b>
<b class="fc">&nbsp;                                                               ? notEqual(larity == 2 ? lassoc : lprec,</b>
<b class="fc">&nbsp;                                                                        integer(assoc_group.getLhs()))</b>
<b class="nc">&nbsp;                                                               : not(and(greaterEq(integer(assoc_group.getRhs()),</b>
<b class="nc">&nbsp;                                                                                   larity == 2 ? lassoc : lprec),</b>
<b class="nc">&nbsp;                                                                         greaterEq(larity == 2 ? lassoc : lprec,</b>
<b class="nc">&nbsp;                                                                                   integer(assoc_group.getLhs())))))),</b>
<b class="fc">&nbsp;                                                or(negative, greaterEq(lprec, integer(prec_level.getLhs()))));</b>
&nbsp;
<b class="fc">&nbsp;                                if (rule.isILeftRecursive() &amp;&amp; canBePrefix)</b>
<b class="nc">&nbsp;                                    lcond = or(equal(var(&quot;l&quot;), undef()), lcond);</b>
&nbsp;                            }
&nbsp;
<b class="fc">&nbsp;                            if (rule.isLeftRecursive() || rule.isILeftRecursive()) {</b>
<b class="fc">&nbsp;                                if (rule.getAssociativity() == Associativity.RIGHT) // parity == 2</b>
<b class="nc">&nbsp;                                    rcond = and(or(equal(passoc, integer(prec)),</b>
<b class="nc">&nbsp;                                                   not(and(greaterEq(integer(assoc_group.getRhs()), passoc),</b>
<b class="nc">&nbsp;                                                           greaterEq(passoc, integer(assoc_group.getLhs()))))),</b>
<b class="nc">&nbsp;                                                greaterEq(integer(prec_level.getRhs()), pprec));</b>
&nbsp;                                else
<b class="fc">&nbsp;                                    rcond = and(assoc_group.getLhs() == assoc_group.getRhs()</b>
<b class="fc">&nbsp;                                                        ? notEqual(parity == 2 ? passoc : pprec,</b>
<b class="fc">&nbsp;                                                                 integer(assoc_group.getLhs()))</b>
<b class="nc">&nbsp;                                                        : not(and(greaterEq(integer(assoc_group.getRhs()),</b>
<b class="nc">&nbsp;                                                                            parity == 2 ? passoc : pprec),</b>
<b class="nc">&nbsp;                                                                  greaterEq(parity == 2 ? passoc : pprec,</b>
<b class="nc">&nbsp;                                                                            integer(assoc_group.getLhs())))),</b>
<b class="fc">&nbsp;                                                greaterEq(integer(prec_level.getRhs()), pprec));</b>
&nbsp;                            }
&nbsp;
<b class="fc">&nbsp;                            if (rule.isILeftRecursive() &amp;&amp; canBePrefix) {</b>
<b class="nc">&nbsp;                                rcond = ifThenElse(equal(var(&quot;l&quot;), undef()),</b>
<b class="nc">&nbsp;                                                   assoc_group.getLhs() == assoc_group.getRhs()</b>
<b class="nc">&nbsp;                                                           ? notEqual(parity == 2 ? passoc : pprec,</b>
<b class="nc">&nbsp;                                                                    integer(assoc_group.getLhs()))</b>
<b class="nc">&nbsp;                                                           : not(and(greaterEq(integer(assoc_group.getRhs()),</b>
<b class="nc">&nbsp;                                                                               parity == 2 ? passoc : pprec),</b>
<b class="nc">&nbsp;                                                                     greaterEq(parity == 2 ? passoc : pprec,</b>
<b class="nc">&nbsp;                                                                               integer(assoc_group.getLhs())))),</b>
&nbsp;                                                   rcond); // TODO: should become post-condition
&nbsp;                            }
&nbsp;
<b class="fc">&nbsp;                            if (rule.isRightRecursive() || rule.isIRightRecursive()) {</b>
<b class="fc">&nbsp;                                if (parity == 2)</b>
<b class="nc">&nbsp;                                    rarg = tuple(integer(prec_level.getRhs()), integer(prec));</b>
&nbsp;                                else {
<b class="fc">&nbsp;                                    if (this.parity == 2)</b>
<b class="nc">&nbsp;                                        rarg = tuple(integer(prec), integer(0));</b>
&nbsp;                                    else
<b class="fc">&nbsp;                                        rarg = integer(prec);</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;
<b class="fc">&nbsp;                            if (rule.isRightRecursive() || rule.isIRightRecursive()) {</b>
<b class="fc">&nbsp;                                if (config.hasPrefixBelow(prec_level.getLhs())) {</b>
<b class="nc">&nbsp;                                    if (larity == 2)</b>
<b class="nc">&nbsp;                                        ret = tuple(minimum(prec_level.getLhs(), rprec), integer(prec));</b>
&nbsp;                                    else {
<b class="nc">&nbsp;                                        if (this.larity == 2)</b>
<b class="nc">&nbsp;                                            ret = tuple(minimum(prec, rprec), integer(0));</b>
&nbsp;                                        else
<b class="nc">&nbsp;                                            ret = minimum(prec, rprec);</b>
&nbsp;                                    }
&nbsp;                                } else {
<b class="fc">&nbsp;                                    if (larity == 2)</b>
<b class="fc">&nbsp;                                        ret = tuple(integer(prec_level.getLhs()), integer(prec));</b>
&nbsp;                                    else {
<b class="nc">&nbsp;                                        if (this.larity == 2)</b>
<b class="nc">&nbsp;                                            ret = tuple(integer(prec), integer(0));</b>
&nbsp;                                        else
<b class="nc">&nbsp;                                            ret = integer(prec);</b>
&nbsp;                                    }
&nbsp;                                }
&nbsp;
<b class="fc">&nbsp;                                if (rule.isIRightRecursive() &amp;&amp; canBePostfix) {</b>
<b class="fc">&nbsp;                                    if (rule.isLeftRecursive())</b>
<b class="fc">&nbsp;                                        ret = ifThenElse(equal(var(&quot;r&quot;), undef()),</b>
<b class="fc">&nbsp;                                                         larity == 2 ? tuple(integer(0), neg(integer(prec)))</b>
<b class="nc">&nbsp;                                                                 : (this.larity == 2 ? tuple(neg(integer(prec)),</b>
<b class="nc">&nbsp;                                                                                             integer(0))</b>
<b class="nc">&nbsp;                                                                 : neg(integer(prec))),</b>
&nbsp;                                                         ret);
<b class="nc">&nbsp;                                    else if (rule.isILeftRecursive())</b>
<b class="nc">&nbsp;                                        ret = ifThenElse(equal(var(&quot;r&quot;), undef()),</b>
<b class="nc">&nbsp;                                                         ifThenElse(equal(var(&quot;l&quot;), undef()),</b>
<b class="nc">&nbsp;                                                                    larity == 2 ? tuple(integer(0), integer(0))</b>
<b class="nc">&nbsp;                                                                            : integer(0),</b>
<b class="nc">&nbsp;                                                                    larity == 2 ? tuple(integer(0), neg(integer(prec)))</b>
<b class="nc">&nbsp;                                                                            : (this.larity == 2</b>
<b class="nc">&nbsp;                                                                            ? tuple(neg(integer(prec)), integer(0))</b>
<b class="nc">&nbsp;                                                                            : neg(integer(prec)))),</b>
&nbsp;                                                         ret);
&nbsp;                                    else
<b class="nc">&nbsp;                                        throw new RuntimeException(&quot;Shouldn&#39;t have happened!&quot;);</b>
&nbsp;                                }
&nbsp;
&nbsp;                            } else {
<b class="nc">&nbsp;                                if (this.larity == 2)</b>
<b class="nc">&nbsp;                                    ret = tuple(integer(0), integer(0));</b>
&nbsp;                                else
<b class="nc">&nbsp;                                    ret = integer(prec);</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        // Normal prefix
<b class="fc">&nbsp;                        if (!(rule.isLeftRecursive() || rule.isILeftRecursive()) &amp;&amp; rule.isRightRecursive())</b>
<b class="fc">&nbsp;                            rcond = assoc_group.getLhs() == assoc_group.getRhs()</b>
<b class="fc">&nbsp;                                    ? notEqual(parity == 2 ? passoc : pprec, integer(assoc_group.getLhs()))</b>
<b class="nc">&nbsp;                                    : not(and(greaterEq(integer(assoc_group.getRhs()), parity == 2 ? passoc : pprec),</b>
<b class="nc">&nbsp;                                              greaterEq(parity == 2 ? passoc : pprec,</b>
<b class="nc">&nbsp;                                                        integer(assoc_group.getLhs()))));</b>
&nbsp;
&nbsp;                        // Normal postfix
<b class="fc">&nbsp;                        if (rule.isLeftRecursive() &amp;&amp; !(rule.isRightRecursive() || rule.isIRightRecursive())) {</b>
<b class="nc">&nbsp;                            if (larity == 2)</b>
<b class="nc">&nbsp;                                ret = tuple(integer(0), neg(integer(prec)));</b>
&nbsp;                            else {
<b class="nc">&nbsp;                                if (this.larity == 2)</b>
<b class="nc">&nbsp;                                    ret = tuple(neg(integer(prec)), integer(0));</b>
&nbsp;                                else
<b class="nc">&nbsp;                                    ret = neg(integer(prec));</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        break;
&nbsp;                    default:
<b class="nc">&nbsp;                        throw new RuntimeException(&quot;Unexpected associativity: &quot; + assoc_group.getAssociativity());</b>
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (assoc_group == null &amp;&amp; prec_level.getLhs() == prec_level.getRhs()) { // larity == 1 &amp;&amp; parity == 1</b>
<b class="fc">&nbsp;                switch (assoc) {</b>
&nbsp;                    case LEFT:
&nbsp;
<b class="fc">&nbsp;                        if (rule.isLeftRecursive() || rule.isILeftRecursive()) {</b>
&nbsp;
<b class="fc">&nbsp;                            lcond = or(lessEq(lprec, integer(0)), greaterEq(lprec, integer(prec)));</b>
<b class="fc">&nbsp;                            rcond = greaterEq(integer(prec), pprec);</b>
&nbsp;
<b class="fc">&nbsp;                            if (rule.isILeftRecursive() &amp;&amp; canBePrefix) {</b>
<b class="nc">&nbsp;                                lcond = or(equal(var(&quot;l&quot;), undef()), lcond);</b>
&nbsp;                                // TODO: should become post-condition
<b class="nc">&nbsp;                                rcond = ifThenElse(equal(var(&quot;l&quot;), undef()), TRUE, rcond);</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;
<b class="fc">&nbsp;                        if (rule.isRightRecursive() || rule.isIRightRecursive()) {</b>
<b class="fc">&nbsp;                            if (this.parity == 2)</b>
<b class="nc">&nbsp;                                rarg = tuple(integer(prec + 1), integer(0));</b>
&nbsp;                            else
<b class="fc">&nbsp;                                rarg = integer(prec + 1);</b>
&nbsp;
&nbsp;                            // larity == 1
<b class="fc">&nbsp;                            if (config.hasPrefixBelow(prec_level.getLhs())) {</b>
<b class="fc">&nbsp;                                if (this.larity == 2)</b>
<b class="nc">&nbsp;                                    ret = tuple(minimum(prec, rprec), integer(0));</b>
&nbsp;                                else
<b class="fc">&nbsp;                                    ret = minimum(prec, rprec);</b>
&nbsp;
<b class="fc">&nbsp;                                if (rule.isIRightRecursive() &amp;&amp; canBePostfix)</b>
<b class="nc">&nbsp;                                    ret = ifThenElse(equal(var(&quot;r&quot;), undef()),</b>
<b class="nc">&nbsp;                                                     this.larity == 2 ? tuple(integer(0), integer(0)) : integer(0),</b>
&nbsp;                                                     ret);
&nbsp;
&nbsp;                            } else { // In this case, r-variable is not used
<b class="fc">&nbsp;                                if (this.larity == 2)</b>
<b class="fc">&nbsp;                                    ret = tuple(integer(prec), integer(0));</b>
&nbsp;                                else
<b class="fc">&nbsp;                                    ret = integer(prec);</b>
&nbsp;                            }
&nbsp;                        } else {
<b class="nc">&nbsp;                            if (this.larity == 2)</b>
<b class="nc">&nbsp;                                ret = tuple(integer(0), integer(0));</b>
&nbsp;                            else
<b class="nc">&nbsp;                                ret = integer(0);</b>
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case RIGHT:
&nbsp;
<b class="fc">&nbsp;                        if (rule.isLeftRecursive() || rule.isILeftRecursive()) {</b>
<b class="fc">&nbsp;                            lcond = or(lessEq(lprec, integer(0)), greaterEq(lprec, integer(prec + 1)));</b>
<b class="fc">&nbsp;                            rcond = greaterEq(integer(prec), pprec);</b>
&nbsp;
<b class="fc">&nbsp;                            if (rule.isILeftRecursive() &amp;&amp; canBePrefix) {</b>
<b class="nc">&nbsp;                                lcond = or(equal(var(&quot;l&quot;), undef()), lcond);</b>
&nbsp;                                // TODO: should become post-condition
<b class="nc">&nbsp;                                rcond = ifThenElse(equal(var(&quot;l&quot;), undef()), TRUE, rcond);</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;
<b class="fc">&nbsp;                        if (rule.isRightRecursive() || rule.isIRightRecursive()) {</b>
<b class="fc">&nbsp;                            if (this.parity == 2)</b>
<b class="nc">&nbsp;                                rarg = tuple(integer(first ? 0 : prec), integer(0));</b>
&nbsp;                            else
<b class="fc">&nbsp;                                rarg = integer(first ? 0 : prec);</b>
&nbsp;
&nbsp;                            // larity == 1
<b class="fc">&nbsp;                            if (config.hasPrefixBelow(prec_level.getLhs())) {</b>
<b class="fc">&nbsp;                                if (this.larity == 2)</b>
<b class="fc">&nbsp;                                    ret = tuple(minimum(prec, rprec), integer(0));</b>
&nbsp;                                else
<b class="fc">&nbsp;                                    ret = minimum(prec, rprec);</b>
&nbsp;
<b class="fc">&nbsp;                                if (rule.isIRightRecursive() &amp;&amp; canBePostfix)</b>
<b class="nc">&nbsp;                                    ret = ifThenElse(equal(var(&quot;r&quot;), undef()),</b>
<b class="nc">&nbsp;                                                     this.larity == 2 ? tuple(integer(0), integer(0)) : integer(0),</b>
&nbsp;                                                     ret);
&nbsp;                            } else {
<b class="fc">&nbsp;                                if (this.larity == 2)</b>
<b class="nc">&nbsp;                                    ret = tuple(integer(prec), integer(0));</b>
&nbsp;                                else
<b class="fc">&nbsp;                                    ret = integer(prec);</b>
&nbsp;                            }
&nbsp;                        } else {
<b class="nc">&nbsp;                            if (this.larity == 2)</b>
<b class="nc">&nbsp;                                ret = tuple(integer(0), integer(0));</b>
&nbsp;                            else
<b class="nc">&nbsp;                                ret = integer(0);</b>
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case NON_ASSOC: // TODO: non all the cases have been yet supported
<b class="fc">&nbsp;                        if ((rule.isLeftRecursive() &amp;&amp; rule.isRightRecursive())</b>
<b class="fc">&nbsp;                            || (rule.isILeftRecursive() &amp;&amp; rule.isRightRecursive() &amp;&amp; !canBePrefix)</b>
<b class="fc">&nbsp;                            || (rule.isLeftRecursive() &amp;&amp; rule.isIRightRecursive() &amp;&amp; !canBePostfix)) {</b>
&nbsp;
<b class="fc">&nbsp;                            lcond = or(lessEq(lprec, integer(0)), greaterEq(lprec, integer(prec + 1)));</b>
<b class="fc">&nbsp;                            rcond = greaterEq(integer(prec), pprec);</b>
&nbsp;
<b class="fc">&nbsp;                            if (this.parity == 2)</b>
<b class="nc">&nbsp;                                rarg = tuple(integer(prec + 1), integer(0));</b>
&nbsp;                            else
<b class="fc">&nbsp;                                rarg = integer(prec + 1);</b>
&nbsp;
<b class="fc">&nbsp;                            if (config.hasPrefixBelow(prec_level.getLhs())) {</b>
<b class="fc">&nbsp;                                if (this.larity == 2)</b>
<b class="nc">&nbsp;                                    ret = tuple(minimum(prec, rprec), integer(0));</b>
&nbsp;                                else
<b class="fc">&nbsp;                                    ret = minimum(prec, rprec);</b>
&nbsp;                            } else {
<b class="fc">&nbsp;                                if (this.larity == 2)</b>
<b class="nc">&nbsp;                                    ret = tuple(integer(prec), integer(0));</b>
&nbsp;                                else
<b class="fc">&nbsp;                                    ret = integer(prec);</b>
&nbsp;                            }
&nbsp;
<b class="nc">&nbsp;                        } else if (rule.isLeftRecursive()) {</b>
<b class="nc">&nbsp;                            lcond = or(and(lessEq(lprec, integer(0)),</b>
<b class="nc">&nbsp;                                           notEqual(lprec, neg(integer(prec)))),</b>
<b class="nc">&nbsp;                                       greaterEq(lprec, integer(prec)));</b>
<b class="nc">&nbsp;                            rcond = greaterEq(integer(prec), pprec);</b>
&nbsp;
<b class="nc">&nbsp;                            if (this.larity == 2)</b>
<b class="nc">&nbsp;                                ret = tuple(neg(integer(prec)), integer(0));</b>
&nbsp;                            else
<b class="nc">&nbsp;                                ret = neg(integer(prec));</b>
&nbsp;
&nbsp;                        } else {
&nbsp;
<b class="nc">&nbsp;                            rcond = notEqual(pprec, integer(prec));</b>
&nbsp;
<b class="nc">&nbsp;                            if (this.parity == 2)</b>
<b class="nc">&nbsp;                                rarg = tuple(integer(first ? 0 : prec), integer(0));</b>
&nbsp;                            else
<b class="nc">&nbsp;                                rarg = integer(first ? 0 : prec);</b>
&nbsp;
&nbsp;                            // larity == 1
<b class="nc">&nbsp;                            if (config.hasPrefixBelow(prec_level.getLhs())) {</b>
<b class="nc">&nbsp;                                if (this.larity == 2)</b>
<b class="nc">&nbsp;                                    ret = tuple(minimum(prec, rprec), integer(0));</b>
&nbsp;                                else
<b class="nc">&nbsp;                                    ret = minimum(prec, rprec);</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                if (this.larity == 2)</b>
<b class="nc">&nbsp;                                    ret = tuple(integer(prec), integer(0));</b>
&nbsp;                                else
<b class="nc">&nbsp;                                    ret = integer(prec);</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    case UNDEFINED:
&nbsp;
<b class="fc">&nbsp;                        if (rule.isLeftRecursive() || rule.isILeftRecursive()) {</b>
<b class="fc">&nbsp;                            lcond = or(lessEq(lprec, integer(0)), greaterEq(lprec, integer(prec)));</b>
<b class="fc">&nbsp;                            rcond = greaterEq(integer(prec), pprec);</b>
&nbsp;
<b class="fc">&nbsp;                            if (rule.isILeftRecursive() &amp;&amp; canBePrefix) {</b>
<b class="nc">&nbsp;                                lcond = or(equal(var(&quot;l&quot;), undef()), lcond);</b>
&nbsp;                                // TODO: should become post-condition
<b class="nc">&nbsp;                                rcond = ifThenElse(equal(var(&quot;l&quot;), undef()), TRUE, rcond);</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;
<b class="fc">&nbsp;                        if (rule.isRightRecursive() || rule.isIRightRecursive()) {</b>
<b class="fc">&nbsp;                            if (this.parity == 2)</b>
<b class="nc">&nbsp;                                rarg = tuple(integer(first ? 0 : prec), integer(0));</b>
&nbsp;                            else
<b class="fc">&nbsp;                                rarg = integer(first ? 0 : prec);</b>
&nbsp;
&nbsp;                            // larity == 1
<b class="fc">&nbsp;                            if (config.hasPrefixBelow(prec_level.getLhs())) {</b>
<b class="fc">&nbsp;                                if (this.larity == 2)</b>
<b class="nc">&nbsp;                                    ret = tuple(minimum(prec, rprec), integer(0));</b>
&nbsp;                                else
<b class="fc">&nbsp;                                    ret = minimum(prec, rprec);</b>
&nbsp;
<b class="fc">&nbsp;                                if (rule.isIRightRecursive() &amp;&amp; canBePostfix)</b>
<b class="nc">&nbsp;                                    ret = ifThenElse(equal(var(&quot;r&quot;), undef()),</b>
<b class="nc">&nbsp;                                                     this.larity == 2 ? tuple(integer(0), integer(0)) : integer(0),</b>
&nbsp;                                                     ret);
&nbsp;
&nbsp;                            } else {
<b class="fc">&nbsp;                                if (this.larity == 2)</b>
<b class="nc">&nbsp;                                    ret = tuple(integer(prec), integer(0));</b>
&nbsp;                                else
<b class="fc">&nbsp;                                    ret = integer(prec);</b>
&nbsp;                            }
&nbsp;                        } else {
<b class="fc">&nbsp;                            if (this.larity == 2)</b>
<b class="nc">&nbsp;                                ret = tuple(integer(0), integer(0));</b>
&nbsp;                            else
<b class="fc">&nbsp;                                ret = integer(0);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        break;</b>
&nbsp;                    default:
<b class="nc">&nbsp;                        throw new RuntimeException(&quot;Unexpected associativity: &quot; + assoc);</b>
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (assoc_group == null &amp;&amp; prec_level.getLhs() != prec_level.getRhs()) {</b>
&nbsp;
<b class="fc">&nbsp;                if (rule.isILeftRecursive() || rule.isIRightRecursive()) {</b>
<b class="nc">&nbsp;                    System.out.println(&quot;Warning: not yet implemented: indirect recursion inside a group of the same &quot;</b>
&nbsp;                                       + &quot;precedence with multiple rules: &quot; + rule);
&nbsp;                }
&nbsp;
&nbsp;                // Local to an associativity group
<b class="fc">&nbsp;                int arity = config.groups.get(prec_level.getLhs()) == null ? 1 : config.groups.get(prec_level.getLhs());</b>
<b class="fc">&nbsp;                int larity = (arity == 2 || arity == 4) ? 2 : 1;</b>
<b class="fc">&nbsp;                int parity = (arity == 3 || arity == 4) ? 2 : 1;</b>
&nbsp;
<b class="fc">&nbsp;                if (rule.isLeftRecursive()) {</b>
<b class="fc">&nbsp;                    lcond = or(lessEq(lprec, integer(0)), greaterEq(lprec, integer(prec)));</b>
<b class="fc">&nbsp;                    rcond = greaterEq(integer(prec), pprec);</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (rule.isRightRecursive()) {</b>
<b class="fc">&nbsp;                    if (parity == 2)</b>
<b class="fc">&nbsp;                        rarg = tuple(integer(first ? 0 : undefined), integer(0));</b>
&nbsp;                    else {
<b class="fc">&nbsp;                        if (this.parity == 2)</b>
<b class="nc">&nbsp;                            rarg = tuple(integer(first ? 0 : undefined), integer(0));</b>
&nbsp;                        else
<b class="fc">&nbsp;                            rarg = integer(first ? 0 : undefined);</b>
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    if (prec_level.hasPrefixUnaryBelow()) {</b>
<b class="nc">&nbsp;                        if (larity == 2)</b>
<b class="nc">&nbsp;                            ret = tuple(minimum(undefined, rprec), integer(0));</b>
&nbsp;                        else {
<b class="nc">&nbsp;                            if (this.larity == 2)</b>
<b class="nc">&nbsp;                                ret = tuple(minimum(undefined, rprec), integer(0));</b>
&nbsp;                            else
<b class="nc">&nbsp;                                ret = minimum(undefined, rprec);</b>
&nbsp;                        }
&nbsp;                    } else {
<b class="fc">&nbsp;                        if (larity == 2)</b>
<b class="nc">&nbsp;                            ret = tuple(integer(undefined), integer(0));</b>
&nbsp;                        else {
<b class="fc">&nbsp;                            if (this.larity == 2)</b>
<b class="nc">&nbsp;                                ret = tuple(integer(undefined), integer(0));</b>
&nbsp;                            else
<b class="fc">&nbsp;                                ret = integer(undefined);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                } else {
<b class="fc">&nbsp;                    if (this.larity == 2)</b>
<b class="nc">&nbsp;                        ret = tuple(integer(0), integer(0));</b>
&nbsp;                    else
<b class="fc">&nbsp;                        ret = integer(0);</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (rule.getAssociativity() != Associativity.UNDEFINED) {</b>
&nbsp;
<b class="fc">&nbsp;                    switch (rule.getAssociativity()) {</b>
&nbsp;
&nbsp;                        case LEFT:
<b class="fc">&nbsp;                            if (parity == 2)</b>
<b class="fc">&nbsp;                                rarg = tuple(integer(first ? 0 : undefined), integer(prec));</b>
&nbsp;                            else {
<b class="fc">&nbsp;                                if (this.parity == 2)</b>
<b class="nc">&nbsp;                                    rarg = tuple(integer(prec), integer(0));</b>
&nbsp;                                else
<b class="fc">&nbsp;                                    rarg = integer(prec);</b>
&nbsp;                            }
&nbsp;
<b class="fc">&nbsp;                            rcond = and(greaterEq(integer(prec), pprec),</b>
<b class="fc">&nbsp;                                        notEqual(parity == 2 ? passoc : pprec, integer(prec)));</b>
&nbsp;
<b class="fc">&nbsp;                            break;</b>
&nbsp;                        case RIGHT:
&nbsp;
<b class="nc">&nbsp;                            if (prec_level.hasPrefixUnaryBelow()) {</b>
<b class="nc">&nbsp;                                if (larity == 2)</b>
<b class="nc">&nbsp;                                    ret = tuple(minimum(prec, rprec), integer(0));</b>
&nbsp;                                else {
<b class="nc">&nbsp;                                    if (this.larity == 2)</b>
<b class="nc">&nbsp;                                        ret = tuple(minimum(prec, rprec), integer(0));</b>
&nbsp;                                    else
<b class="nc">&nbsp;                                        ret = minimum(prec, rprec);</b>
&nbsp;                                }
&nbsp;                            } else {
<b class="nc">&nbsp;                                if (larity == 2)</b>
<b class="nc">&nbsp;                                    ret = tuple(integer(prec), integer(0));</b>
&nbsp;                                else {
<b class="nc">&nbsp;                                    if (this.larity == 2)</b>
<b class="nc">&nbsp;                                        ret = tuple(integer(prec), integer(0));</b>
&nbsp;                                    else
<b class="nc">&nbsp;                                        ret = integer(prec);</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;
<b class="nc">&nbsp;                            lcond = or(lessEq(lprec, integer(0)),</b>
<b class="nc">&nbsp;                                       and(notEqual(larity == 2 ? lassoc : lprec, integer(prec)),</b>
<b class="nc">&nbsp;                                           greaterEq(lprec, integer(prec))));</b>
&nbsp;
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case NON_ASSOC:
&nbsp;
<b class="fc">&nbsp;                            if (rule.isLeftRecursive() &amp;&amp; rule.isRightRecursive()) {</b>
&nbsp;
<b class="nc">&nbsp;                                if (parity == 2)</b>
<b class="nc">&nbsp;                                    rarg = tuple(integer(first ? 0 : undefined), integer(prec));</b>
&nbsp;                                else {
<b class="nc">&nbsp;                                    if (this.parity == 2)</b>
<b class="nc">&nbsp;                                        rarg = tuple(integer(prec), integer(0));</b>
&nbsp;                                    else
<b class="nc">&nbsp;                                        rarg = integer(prec);</b>
&nbsp;                                }
&nbsp;
<b class="nc">&nbsp;                                if (prec_level.hasPrefixUnaryBelow()) {</b>
<b class="nc">&nbsp;                                    if (larity == 2)</b>
<b class="nc">&nbsp;                                        ret = tuple(minimum(prec, rprec), integer(0));</b>
&nbsp;                                    else {
<b class="nc">&nbsp;                                        if (this.larity == 2)</b>
<b class="nc">&nbsp;                                            ret = tuple(minimum(prec, rprec), integer(0));</b>
&nbsp;                                        else
<b class="nc">&nbsp;                                            ret = minimum(prec, rprec);</b>
&nbsp;                                    }
&nbsp;                                } else {
<b class="nc">&nbsp;                                    if (larity == 2)</b>
<b class="nc">&nbsp;                                        ret = tuple(integer(prec), integer(0));</b>
&nbsp;                                    else {
<b class="nc">&nbsp;                                        if (this.larity == 2)</b>
<b class="nc">&nbsp;                                            ret = tuple(integer(prec), integer(0));</b>
&nbsp;                                        else
<b class="nc">&nbsp;                                            ret = integer(prec);</b>
&nbsp;                                    }
&nbsp;                                }
&nbsp;
<b class="nc">&nbsp;                                lcond = or(lessEq(lprec, integer(0)),</b>
<b class="nc">&nbsp;                                           and(notEqual(larity == 2 ? lassoc : lprec, integer(prec)),</b>
<b class="nc">&nbsp;                                               greaterEq(lprec, integer(prec))));</b>
&nbsp;
<b class="nc">&nbsp;                                rcond = and(greaterEq(integer(prec), pprec),</b>
<b class="nc">&nbsp;                                            notEqual(parity == 2 ? passoc : pprec, integer(prec)));</b>
&nbsp;
<b class="fc">&nbsp;                            } else if (rule.isLeftRecursive()) {</b>
&nbsp;
<b class="fc">&nbsp;                                if (larity == 2) {</b>
<b class="nc">&nbsp;                                    ret = tuple(integer(0), neg(integer(prec)));</b>
&nbsp;
<b class="nc">&nbsp;                                    lcond = and(or(lessEq(lprec, integer(0)), greaterEq(lprec, integer(prec))),</b>
<b class="nc">&nbsp;                                                notEqual(lassoc, neg(integer(prec))));</b>
&nbsp;                                } else {
<b class="fc">&nbsp;                                    if (this.larity == 2)</b>
<b class="nc">&nbsp;                                        ret = tuple(neg(integer(prec)), integer(0));</b>
&nbsp;                                    else
<b class="fc">&nbsp;                                        ret = neg(integer(prec));</b>
&nbsp;
<b class="fc">&nbsp;                                    lcond = or(and(lessEq(lprec, integer(0)),</b>
<b class="fc">&nbsp;                                                   notEqual(lprec, neg(integer(prec)))),</b>
<b class="fc">&nbsp;                                               greaterEq(lprec, integer(prec)));</b>
&nbsp;                                }
&nbsp;
&nbsp;                            } else {
<b class="nc">&nbsp;                                if (parity == 2)</b>
<b class="nc">&nbsp;                                    rarg = tuple(integer(first ? 0 : undefined), integer(prec));</b>
&nbsp;                                else {
<b class="nc">&nbsp;                                    if (this.parity == 2)</b>
<b class="nc">&nbsp;                                        rarg = tuple(integer(prec), integer(0));</b>
&nbsp;                                    else
<b class="nc">&nbsp;                                        rarg = integer(prec);</b>
&nbsp;                                }
&nbsp;
<b class="nc">&nbsp;                                rcond = notEqual(parity == 2 ? passoc : pprec, integer(prec));</b>
&nbsp;                            }
&nbsp;
<b class="nc">&nbsp;                            break;</b>
&nbsp;
&nbsp;                        default:
&nbsp;                            break;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        private static Expression pr(int current, Integer[] indices, boolean prefix) {
<b class="nc">&nbsp;            if (prefix) {</b>
<b class="nc">&nbsp;                if (indices.length == 0)</b>
<b class="nc">&nbsp;                    return var(&quot;l&quot;);</b>
&nbsp;
<b class="nc">&nbsp;                if (indices.length == 1)</b>
<b class="nc">&nbsp;                    return pr1(var(&quot;l&quot;), integer(current), integer(indices[0] + 1));</b>
&nbsp;
<b class="nc">&nbsp;                List&lt;Integer&gt; list = Arrays.asList(indices);</b>
<b class="nc">&nbsp;                Collections.reverse(list);</b>
&nbsp;
<b class="nc">&nbsp;                return pr2(var(&quot;l&quot;), integer(current),</b>
<b class="nc">&nbsp;                           list.stream().map(i -&gt; integer(i + 1)).toArray(Expression[]::new));</b>
&nbsp;
&nbsp;            } else {
<b class="nc">&nbsp;                if (indices.length == 0)</b>
<b class="nc">&nbsp;                    return var(&quot;r&quot;);</b>
&nbsp;
<b class="nc">&nbsp;                if (indices.length == 1)</b>
<b class="nc">&nbsp;                    return pr1(var(&quot;r&quot;), integer(current), integer(indices[0] + 1));</b>
&nbsp;
<b class="nc">&nbsp;                List&lt;Integer&gt; list = Arrays.asList(indices);</b>
<b class="nc">&nbsp;                Collections.reverse(list);</b>
&nbsp;
<b class="nc">&nbsp;                return pr2(var(&quot;r&quot;), integer(current),</b>
<b class="nc">&nbsp;                           list.stream().map(i -&gt; integer(i + 1)).toArray(Expression[]::new));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        private static Expression minimum(int precedence, Expression rprec) {
<b class="fc">&nbsp;            return ifThenElse(lessEq(rprec, integer(0)),</b>
<b class="fc">&nbsp;                              integer(precedence),</b>
<b class="fc">&nbsp;                              min(rprec, integer(precedence)));</b>
&nbsp;        }
&nbsp;
&nbsp;        public RuntimeRule transform() {
&nbsp;
<b class="fc">&nbsp;            if (rule.getBody() == null)</b>
<b class="nc">&nbsp;                return rule;</b>
&nbsp;
<b class="fc">&nbsp;            List&lt;Symbol&gt; symbols = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;            RuntimeRule.Builder builder = null;</b>
&nbsp;
<b class="fc">&nbsp;            String head = rule.getHead().getName();</b>
&nbsp;
<b class="fc">&nbsp;            boolean isLeftOrRightRecursiveNonterminal = leftOrRightRecursiveNonterminals.contains(head);</b>
<b class="fc">&nbsp;            boolean isHeadWithLabeledRules = headsWithLabeledRules.containsKey(head);</b>
&nbsp;
<b class="fc">&nbsp;            switch (config_op) {</b>
&nbsp;                case _1:
<b class="nc">&nbsp;                    if (isLeftOrRightRecursiveNonterminal &amp;&amp; isHeadWithLabeledRules)</b>
<b class="nc">&nbsp;                        builder = rule.copyBuilderButWithHead(</b>
<b class="nc">&nbsp;                                rule.getHead().copy().addParameters(&quot;l&quot;, &quot;r&quot;, &quot;_not&quot;).build());</b>
<b class="nc">&nbsp;                    else if (isLeftOrRightRecursiveNonterminal)</b>
<b class="nc">&nbsp;                        builder = rule.copyBuilderButWithHead(rule.getHead().copy().addParameters(&quot;l&quot;, &quot;r&quot;).build());</b>
<b class="nc">&nbsp;                    else if (isHeadWithLabeledRules)</b>
<b class="nc">&nbsp;                        builder = rule.copyBuilderButWithHead(rule.getHead().copy().addParameters(&quot;_not&quot;).build());</b>
<b class="nc">&nbsp;                    else builder = rule.copy();</b>
&nbsp;
<b class="nc">&nbsp;                    builder = builder.setSymbols(symbols);</b>
&nbsp;
<b class="nc">&nbsp;                    int i = 0;</b>
<b class="nc">&nbsp;                    for (Symbol symbol : rule.getBody()) {</b>
&nbsp;
<b class="nc">&nbsp;                        if (i == 0) isFirst = true;</b>
<b class="nc">&nbsp;                        else isFirst = false;</b>
&nbsp;
<b class="nc">&nbsp;                        if (i == rule.getBody().size() - 1) isLast = true;</b>
<b class="nc">&nbsp;                        else isLast = false;</b>
&nbsp;
<b class="nc">&nbsp;                        Symbol sym = symbol.accept(this);</b>
<b class="nc">&nbsp;                        if (preconditions != null &amp;&amp; i == 0)</b>
<b class="nc">&nbsp;                            symbols.add(sym.copy().addPreConditions(preconditions).build());</b>
&nbsp;                        else
<b class="nc">&nbsp;                            symbols.add(sym);</b>
<b class="nc">&nbsp;                        i++;</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case _2:
&nbsp;
<b class="fc">&nbsp;                    if (isLeftOrRightRecursiveNonterminal &amp;&amp; isHeadWithLabeledRules)</b>
<b class="fc">&nbsp;                        builder = rule.copyBuilderButWithHead(rule.getHead().copy().addParameters(&quot;p&quot;, &quot;_not&quot;).build());</b>
<b class="fc">&nbsp;                    else if (isLeftOrRightRecursiveNonterminal)</b>
<b class="fc">&nbsp;                        builder = rule.copyBuilderButWithHead(rule.getHead().copy().addParameters(&quot;p&quot;).build());</b>
<b class="fc">&nbsp;                    else if (isHeadWithLabeledRules)</b>
<b class="fc">&nbsp;                        builder = rule.copyBuilderButWithHead(rule.getHead().copy().addParameters(&quot;_not&quot;).build());</b>
<b class="fc">&nbsp;                    else builder = rule.copy();</b>
&nbsp;
<b class="fc">&nbsp;                    boolean isIndirectEnd = false;</b>
&nbsp;
<b class="fc">&nbsp;                    for (String pend : config.pends) {</b>
<b class="fc">&nbsp;                        Configuration c = configs.get(pend);</b>
<b class="fc">&nbsp;                        if (c.leftEnds.contains(rule.getHead().getName())</b>
<b class="fc">&nbsp;                            || c.rightEnds.contains(rule.getHead().getName())) {</b>
<b class="fc">&nbsp;                            isIndirectEnd = true;</b>
<b class="fc">&nbsp;                            break;</b>
&nbsp;                        }
<b class="fc">&nbsp;                    }</b>
&nbsp;
<b class="fc">&nbsp;                    if (isIndirectEnd) {</b>
<b class="fc">&nbsp;                        String[] parameters = new String[config.pends.size()];</b>
<b class="fc">&nbsp;                        int n = 0;</b>
<b class="fc">&nbsp;                        for (int j = 0; j &lt; config.pends.size(); j++) {</b>
<b class="fc">&nbsp;                            Configuration configOfEnd = configs.get(config.pends.get(j));</b>
<b class="fc">&nbsp;                            if (configOfEnd.leftEnds.contains(rule.getHead().getName())</b>
<b class="fc">&nbsp;                                || configOfEnd.rightEnds.contains(rule.getHead().getName())) {</b>
<b class="fc">&nbsp;                                parameters[j] = &quot;p&quot; + j;</b>
<b class="fc">&nbsp;                                n++;</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;
<b class="fc">&nbsp;                        String[] params = new String[n];</b>
<b class="fc">&nbsp;                        int j = 0;</b>
<b class="fc">&nbsp;                        for (String parameter : parameters) {</b>
<b class="fc">&nbsp;                            if (parameter != null)</b>
<b class="fc">&nbsp;                                params[j++] = parameter;</b>
&nbsp;                        }
&nbsp;
<b class="fc">&nbsp;                        if (isHeadWithLabeledRules)</b>
<b class="nc">&nbsp;                            builder = rule.copyBuilderButWithHead(rule.getHead().copy().addParameters(params)</b>
<b class="nc">&nbsp;                                                                      .addParameters(&quot;_not&quot;).build());</b>
&nbsp;                        else
<b class="fc">&nbsp;                            builder = rule.copyBuilderButWithHead(rule.getHead().copy().addParameters(params).build());</b>
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    builder = builder.setSymbols(symbols);</b>
&nbsp;
<b class="fc">&nbsp;                    i = 0;</b>
<b class="fc">&nbsp;                    for (Symbol symbol : rule.getBody()) {</b>
&nbsp;
<b class="fc">&nbsp;                        if (i == 0) isFirst = true;</b>
<b class="fc">&nbsp;                        else isFirst = false;</b>
&nbsp;
<b class="fc">&nbsp;                        if (i == rule.getBody().size() - 1) isLast = true;</b>
<b class="fc">&nbsp;                        else isLast = false;</b>
&nbsp;
<b class="fc">&nbsp;                        Symbol sym = symbol.accept(this);</b>
&nbsp;
<b class="fc">&nbsp;                        Set&lt;Condition&gt; preconditions = new LinkedHashSet&lt;&gt;();</b>
<b class="fc">&nbsp;                        Set&lt;Condition&gt; postconditions = new LinkedHashSet&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;                        if (rcond != null &amp;&amp; i == 0)</b>
<b class="fc">&nbsp;                            preconditions.add(DataDependentCondition.predicate(rcond));</b>
&nbsp;
<b class="fc">&nbsp;                        if (xrcond != null &amp;&amp; i == 0)</b>
<b class="fc">&nbsp;                            preconditions.add(DataDependentCondition.predicate(xrcond));</b>
&nbsp;
<b class="fc">&nbsp;                        if (lcond != null &amp;&amp; i == 0)</b>
<b class="fc">&nbsp;                            postconditions.add(DataDependentCondition.predicate(lcond));</b>
&nbsp;
<b class="fc">&nbsp;                        if (xlcond != null &amp;&amp; i == 0)</b>
<b class="fc">&nbsp;                            postconditions.add(DataDependentCondition.predicate(xlcond));</b>
&nbsp;
<b class="fc">&nbsp;                        if (!preconditions.isEmpty() &amp;&amp; !postconditions.isEmpty())</b>
<b class="fc">&nbsp;                            symbols.add(sym.copy().addPreConditions(preconditions).addPostConditions(postconditions)</b>
<b class="fc">&nbsp;                                           .build());</b>
<b class="fc">&nbsp;                        else if (!postconditions.isEmpty())</b>
<b class="nc">&nbsp;                            symbols.add(sym.copy().addPostConditions(postconditions).build());</b>
<b class="fc">&nbsp;                        else if (!preconditions.isEmpty())</b>
<b class="fc">&nbsp;                            symbols.add(sym.copy().addPreConditions(preconditions).build());</b>
&nbsp;                        else
<b class="fc">&nbsp;                            symbols.add(sym);</b>
&nbsp;
<b class="fc">&nbsp;                        i++;</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;
<b class="fc">&nbsp;                    Expression iret = null;</b>
&nbsp;
<b class="fc">&nbsp;                    if (isIndirectEnd) {</b>
<b class="fc">&nbsp;                        if (config.pends.size() == 1) {</b>
<b class="fc">&nbsp;                            if (lret[0] != null &amp;&amp; rret[0] != null)</b>
<b class="nc">&nbsp;                                iret = tuple(lret[0], rret[0]);</b>
<b class="fc">&nbsp;                            else if (lret[0] != null)</b>
<b class="nc">&nbsp;                                iret = lret[0];</b>
<b class="fc">&nbsp;                            else if (rret[0] != null)</b>
<b class="fc">&nbsp;                                iret = rret[0];</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            int j = 0;</b>
<b class="nc">&nbsp;                            int size = 0;</b>
&nbsp;
<b class="nc">&nbsp;                            for (Expression l : lret) {</b>
<b class="nc">&nbsp;                                if (l != null || rret[j] != null)</b>
<b class="nc">&nbsp;                                    size++;</b>
<b class="nc">&nbsp;                                j++;</b>
&nbsp;                            }
&nbsp;
<b class="nc">&nbsp;                            j = 0;</b>
<b class="nc">&nbsp;                            int k = 0;</b>
<b class="nc">&nbsp;                            Expression[] rets = new Expression[size];</b>
<b class="nc">&nbsp;                            for (Expression l : lret) {</b>
<b class="nc">&nbsp;                                if (l != null &amp;&amp; rret[j] != null) {</b>
<b class="nc">&nbsp;                                    rets[k++] = tuple(l, rret[j]);</b>
<b class="nc">&nbsp;                                } else if (l != null)</b>
<b class="nc">&nbsp;                                    rets[k++] = l;</b>
<b class="nc">&nbsp;                                else if (rret[j] != null)</b>
<b class="nc">&nbsp;                                    rets[k++] = rret[j];</b>
<b class="nc">&nbsp;                                j++;</b>
&nbsp;                            }
<b class="nc">&nbsp;                            if (rets.length != 0)</b>
<b class="nc">&nbsp;                                iret = tuple(rets);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    if (ret != null &amp;&amp; xret != null)</b>
<b class="fc">&nbsp;                        symbols.add(Return.ret(tuple(ret, xret)));</b>
<b class="fc">&nbsp;                    else if (ret != null)</b>
<b class="fc">&nbsp;                        symbols.add(Return.ret(ret));</b>
<b class="fc">&nbsp;                    else if (xret != null &amp;&amp; iret == null)</b>
<b class="fc">&nbsp;                        symbols.add(Return.ret(xret));</b>
&nbsp;
<b class="fc">&nbsp;                    if (iret != null &amp;&amp; xret != null)</b>
<b class="nc">&nbsp;                        symbols.add(Return.ret(tuple(iret, xret)));</b>
<b class="fc">&nbsp;                    else if (iret != null)</b>
<b class="fc">&nbsp;                        symbols.add(Return.ret(iret));</b>
&nbsp;
&nbsp;                    break;
&nbsp;            }
<b class="fc">&nbsp;            return builder.setDefinition(rule.getDefinition()).build();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Symbol visit(Align symbol) {
<b class="nc">&nbsp;            Symbol sym = symbol.getSymbol().accept(this);</b>
&nbsp;
<b class="nc">&nbsp;            return sym == symbol.getSymbol() ? symbol</b>
<b class="nc">&nbsp;                    : new Align.Builder(sym).setLabel(symbol.getLabel()).addConditions(symbol).build();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Symbol visit(Block symbol) {
<b class="nc">&nbsp;            List&lt;Symbol&gt; symbols = symbol.getSymbols();</b>
<b class="nc">&nbsp;            Symbol[] syms = new Symbol[symbols.size()];</b>
&nbsp;
<b class="nc">&nbsp;            boolean isFirst = this.isFirst;</b>
<b class="nc">&nbsp;            boolean isLast = this.isLast;</b>
&nbsp;
<b class="nc">&nbsp;            int j = 0;</b>
<b class="nc">&nbsp;            boolean modified = false;</b>
<b class="nc">&nbsp;            for (Symbol sym : symbols) {</b>
&nbsp;
<b class="nc">&nbsp;                if (isFirst &amp;&amp; j == 0) this.isFirst = true;</b>
<b class="nc">&nbsp;                else this.isFirst = false;</b>
&nbsp;
<b class="nc">&nbsp;                if (isLast &amp;&amp; j == symbols.size() - 1) this.isLast = true;</b>
<b class="nc">&nbsp;                else this.isLast = false;</b>
&nbsp;
<b class="nc">&nbsp;                syms[j] = sym.accept(this);</b>
<b class="nc">&nbsp;                if (sym != syms[j])</b>
<b class="nc">&nbsp;                    modified |= true;</b>
<b class="nc">&nbsp;                j++;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            this.isFirst = isFirst;</b>
<b class="nc">&nbsp;            this.isLast = isLast;</b>
&nbsp;
<b class="nc">&nbsp;            return modified ? new Block.Builder(syms).setLabel(symbol.getLabel()).addConditions(symbol).build()</b>
<b class="nc">&nbsp;                    : symbol;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Symbol visit(Code symbol) {
<b class="fc">&nbsp;            Symbol sym = symbol.getSymbol().accept(this);</b>
<b class="fc">&nbsp;            if (sym == symbol.getSymbol())</b>
<b class="fc">&nbsp;                return symbol;</b>
&nbsp;
<b class="fc">&nbsp;            return new Code.Builder(sym, symbol.getStatements()).setLabel(symbol.getLabel()).addConditions(symbol)</b>
<b class="fc">&nbsp;                                                                .build();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Symbol visit(Error error) {
<b class="fc">&nbsp;            return error;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Symbol visit(Conditional symbol) {
<b class="nc">&nbsp;            Symbol sym = symbol.getSymbol().accept(this);</b>
<b class="nc">&nbsp;            if (sym == symbol.getSymbol())</b>
<b class="nc">&nbsp;                return symbol;</b>
&nbsp;
<b class="nc">&nbsp;            return new Conditional.Builder(sym, symbol.getExpression()).setLabel(symbol.getLabel()).addConditions(</b>
<b class="nc">&nbsp;                    symbol).build();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Symbol visit(IfThen symbol) {
<b class="nc">&nbsp;            Symbol sym = symbol.getThenPart().accept(this);</b>
<b class="nc">&nbsp;            if (sym == symbol.getThenPart())</b>
<b class="nc">&nbsp;                return symbol;</b>
&nbsp;
<b class="nc">&nbsp;            return new IfThen.Builder(symbol.getExpression(), sym).setLabel(symbol.getLabel()).addConditions(symbol)</b>
<b class="nc">&nbsp;                                                                  .build();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Symbol visit(IfThenElse symbol) {
<b class="nc">&nbsp;            Symbol thenPart = symbol.getThenPart().accept(this);</b>
<b class="nc">&nbsp;            Symbol elsePart = symbol.getElsePart().accept(this);</b>
<b class="nc">&nbsp;            if (thenPart == symbol.getThenPart()</b>
<b class="nc">&nbsp;                &amp;&amp; elsePart == symbol.getElsePart())</b>
<b class="nc">&nbsp;                return symbol;</b>
&nbsp;
<b class="nc">&nbsp;            return new IfThenElse.Builder(symbol.getExpression(), thenPart, elsePart).setLabel(symbol.getLabel())</b>
<b class="nc">&nbsp;                                                                                     .addConditions(symbol).build();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Symbol visit(Ignore symbol) {
<b class="nc">&nbsp;            Symbol sym = symbol.getSymbol().accept(this);</b>
&nbsp;
<b class="nc">&nbsp;            return sym == symbol.getSymbol() ? symbol</b>
<b class="nc">&nbsp;                    : new Ignore.Builder(sym).setLabel(symbol.getLabel()).addConditions(symbol).build();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Symbol visit(Nonterminal symbol) {
&nbsp;            // recursive symbol with precedence, i.e., it has parameters and needs arguments
<b class="fc">&nbsp;            boolean isUseOfLeftOrRight = leftOrRightRecursiveNonterminals.contains(symbol.getName());</b>
&nbsp;
<b class="fc">&nbsp;            Configuration config = configs.get(symbol.getName());</b>
&nbsp;            // symbol that introduces indirection, i.e., it has parameters and needs arguments
<b class="fc">&nbsp;            boolean isUseOfLeftOrRightEnd = false;</b>
&nbsp;
<b class="fc">&nbsp;            List&lt;String&gt; pends = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;            if (!config.pends.isEmpty()) {</b>
<b class="fc">&nbsp;                for (String end : config.pends)</b>
<b class="fc">&nbsp;                    if (configs.get(end).leftEnds.contains(symbol.getName())</b>
<b class="fc">&nbsp;                        || configs.get(end).rightEnds.contains(symbol.getName())) {</b>
<b class="fc">&nbsp;                        isUseOfLeftOrRightEnd = true;</b>
<b class="fc">&nbsp;                        pends.add(end);</b>
&nbsp;                    }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            Map&lt;String, Integer&gt; labels = headsWithLabeledRules.get(symbol.getName());</b>
&nbsp;
<b class="fc">&nbsp;            if (!isUseOfLeftOrRight &amp;&amp; labels == null &amp;&amp; !isUseOfLeftOrRightEnd) return symbol;</b>
&nbsp;
<b class="fc">&nbsp;            boolean isRecursiveUseOfLeftOrRight = isUseOfLeftOrRight &amp;&amp; symbol.getName().equals(</b>
<b class="fc">&nbsp;                    rule.getHead().getName());</b>
&nbsp;
<b class="fc">&nbsp;            boolean isIndirectRecursiveUseOfLeftOrRight = isUseOfLeftOrRightEnd &amp;&amp; pends.contains(</b>
<b class="fc">&nbsp;                    rule.getHead().getName());</b>
&nbsp;
<b class="fc">&nbsp;            Expression _not = null;</b>
<b class="fc">&nbsp;            Expression[] arguments = null;</b>
&nbsp;
<b class="fc">&nbsp;            switch (config_op) {</b>
&nbsp;                case _1:
<b class="nc">&nbsp;                    if (labels != null) {</b>
<b class="nc">&nbsp;                        int n = 0;</b>
<b class="nc">&nbsp;                        Set&lt;String&gt; excepts = symbol.getExcepts();</b>
<b class="nc">&nbsp;                        if (excepts != null)</b>
<b class="nc">&nbsp;                            for (String except : excepts) {</b>
<b class="nc">&nbsp;                                Integer i = labels.get(except);</b>
&nbsp;
<b class="nc">&nbsp;                                if (i == null)</b>
<b class="nc">&nbsp;                                    throw new RuntimeException(&quot;Undeclared label: &quot; + except);</b>
&nbsp;
<b class="nc">&nbsp;                                n += 1 &lt;&lt; i;</b>
<b class="nc">&nbsp;                            }</b>
&nbsp;
<b class="nc">&nbsp;                        _not = integer(n);</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    if (isUseOfLeftOrRight)</b>
<b class="nc">&nbsp;                        arguments = new Expression[]{integer(0), integer(0)};</b>
&nbsp;
<b class="nc">&nbsp;                    if (isRecursiveUseOfLeftOrRight &amp;&amp; isFirst)</b>
<b class="nc">&nbsp;                        arguments = new Expression[]{l1, r1};</b>
<b class="nc">&nbsp;                    else if (isRecursiveUseOfLeftOrRight &amp;&amp; isLast)</b>
<b class="nc">&nbsp;                        arguments = new Expression[]{l2, r2};</b>
&nbsp;
<b class="nc">&nbsp;                    if (arguments != null &amp;&amp; _not != null)</b>
<b class="nc">&nbsp;                        return symbol.copy().apply(arguments).apply(_not).build();</b>
<b class="nc">&nbsp;                    else if (arguments != null)</b>
<b class="nc">&nbsp;                        return symbol.copy().apply(arguments).build();</b>
&nbsp;                    else
<b class="nc">&nbsp;                        return symbol.copy().apply(_not).build();</b>
&nbsp;
&nbsp;                case _2:
<b class="fc">&nbsp;                    if (labels != null) {</b>
<b class="fc">&nbsp;                        if (rule.isLeftRecursive() &amp;&amp; isFirst) {</b>
<b class="fc">&nbsp;                            _not = integer(0);</b>
<b class="fc">&nbsp;                            if (isRecursiveUseOfLeftOrRight) {</b>
<b class="fc">&nbsp;                                Configuration c = configs.get(rule.getHead().getName());</b>
<b class="fc">&nbsp;                                if (c != null &amp;&amp; !c.right_rec_rules.isEmpty()) {</b>
&nbsp;
<b class="fc">&nbsp;                                    int n = 0;</b>
<b class="fc">&nbsp;                                    for (Map.Entry&lt;String, RuntimeRule&gt; entry : c.right_rec_rules.entrySet()) {</b>
<b class="fc">&nbsp;                                        if (rule.getPrecedence() != -1</b>
<b class="fc">&nbsp;                                            &amp;&amp; rule.getPrecedence() &gt; entry.getValue().getPrecedenceLevel().getRhs()) {</b>
<b class="fc">&nbsp;                                            n = 1 &lt;&lt; labels.get(entry.getKey());</b>
&nbsp;                                        }
<b class="fc">&nbsp;                                    }</b>
<b class="fc">&nbsp;                                    _not = AST.shift(var(&quot;_not&quot;), integer(n));</b>
&nbsp;                                }
<b class="fc">&nbsp;                            }</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            int n = 0;</b>
<b class="fc">&nbsp;                            Set&lt;String&gt; excepts = symbol.getExcepts();</b>
<b class="fc">&nbsp;                            if (excepts != null)</b>
<b class="fc">&nbsp;                                for (String except : excepts) {</b>
<b class="fc">&nbsp;                                    Integer i = labels.get(except);</b>
&nbsp;
<b class="fc">&nbsp;                                    if (i == null)</b>
<b class="nc">&nbsp;                                        throw new RuntimeException(&quot;Undeclared label: &quot; + except);</b>
&nbsp;
<b class="fc">&nbsp;                                    n += 1 &lt;&lt; i;</b>
<b class="fc">&nbsp;                                }</b>
&nbsp;
<b class="fc">&nbsp;                            _not = integer(n);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    String variable = &quot;&quot;;</b>
&nbsp;
<b class="fc">&nbsp;                    if (isUseOfLeftOrRight) {</b>
<b class="fc">&nbsp;                        int parity = config.parity;</b>
&nbsp;
<b class="fc">&nbsp;                        if (config.leftEnds.contains(rule.getHead().getName())</b>
&nbsp;                            // TODO: if precedence also applies to X, use larg and rarg
<b class="fc">&nbsp;                            || config.rightEnds.contains(rule.getHead().getName())) {</b>
&nbsp;
<b class="fc">&nbsp;                            List&lt;String&gt; ends = configs.get(rule.getHead().getName()).pends;</b>
&nbsp;
<b class="fc">&nbsp;                            int i = ends.indexOf(symbol.getName());</b>
&nbsp;
<b class="fc">&nbsp;                            boolean canBeFromLeft = config.leftEnds.contains(rule.getHead().getName());</b>
<b class="fc">&nbsp;                            boolean canBeFromRight = config.rightEnds.contains(rule.getHead().getName());</b>
&nbsp;
<b class="fc">&nbsp;                            if (isFirst &amp;&amp; isLast) { // X ::= E</b>
&nbsp;
<b class="fc">&nbsp;                                if (canBeFromLeft &amp;&amp; canBeFromRight) {</b>
<b class="nc">&nbsp;                                    variable = &quot;l&quot;;</b>
<b class="nc">&nbsp;                                    arguments = new Expression[]{var(&quot;p&quot; + i)};</b>
&nbsp;
&nbsp;                                    // TODO: if-then-else is needed for the return value
<b class="nc">&nbsp;                                    throw new RuntimeException(&quot;Unsupported yet!&quot;);</b>
&nbsp;
<b class="fc">&nbsp;                                } else if (canBeFromLeft) {</b>
<b class="nc">&nbsp;                                    variable = &quot;l&quot;;</b>
<b class="nc">&nbsp;                                    arguments = new Expression[]{var(&quot;p&quot; + i)};</b>
<b class="nc">&nbsp;                                    lret[i] = var(&quot;l&quot;);</b>
<b class="fc">&nbsp;                                } else if (canBeFromRight) {</b>
<b class="fc">&nbsp;                                    variable = &quot;r&quot;;</b>
<b class="fc">&nbsp;                                    arguments = new Expression[]{var(&quot;p&quot; + i)};</b>
<b class="fc">&nbsp;                                    boolean hasPrefixBelow = config.rightEndsPrefixBelow.contains(</b>
<b class="fc">&nbsp;                                            rule.getHead().getName());</b>
<b class="fc">&nbsp;                                    boolean canBecomePostfix = config.rightEndsThatCanLeadToPostfix.contains(</b>
<b class="fc">&nbsp;                                            rule.getHead().getName());</b>
<b class="fc">&nbsp;                                    if (hasPrefixBelow || canBecomePostfix)</b>
<b class="fc">&nbsp;                                        rret[i] = var(&quot;r&quot;);</b>
&nbsp;                                    else
<b class="fc">&nbsp;                                        variable = &quot;&quot;;</b>
<b class="fc">&nbsp;                                } else {</b>
<b class="nc">&nbsp;                                    throw new RuntimeException(&quot;Shouldn&#39;t have happened!&quot;);</b>
&nbsp;                                }
&nbsp;
<b class="fc">&nbsp;                            } else if (isFirst) { // X ::= E alpha</b>
<b class="nc">&nbsp;                                variable = &quot;l&quot;;</b>
<b class="nc">&nbsp;                                if (canBeFromLeft &amp;&amp; canBeFromRight)</b>
<b class="nc">&nbsp;                                    arguments = new Expression[]{get(var(&quot;p&quot; + i), 0)};</b>
<b class="nc">&nbsp;                                else if (canBeFromLeft)</b>
<b class="nc">&nbsp;                                    arguments = new Expression[]{var(&quot;p&quot; + i)};</b>
<b class="nc">&nbsp;                                lret[i] = var(&quot;l&quot;);</b>
<b class="fc">&nbsp;                            } else if (isLast) { // X ::= alpha E</b>
<b class="fc">&nbsp;                                variable = &quot;r&quot;;</b>
<b class="fc">&nbsp;                                if (canBeFromLeft &amp;&amp; canBeFromRight)</b>
<b class="nc">&nbsp;                                    arguments = new Expression[]{get(var(&quot;p&quot; + i), 1)};</b>
<b class="fc">&nbsp;                                else if (canBeFromRight) {</b>
<b class="fc">&nbsp;                                    arguments = new Expression[]{var(&quot;p&quot; + i)};</b>
&nbsp;
<b class="fc">&nbsp;                                    boolean hasPrefixBelow = config.rightEndsPrefixBelow.contains(</b>
<b class="fc">&nbsp;                                            rule.getHead().getName());</b>
<b class="fc">&nbsp;                                    boolean canBecomePostfix = config.rightEndsThatCanLeadToPostfix.contains(</b>
<b class="fc">&nbsp;                                            rule.getHead().getName());</b>
&nbsp;
<b class="fc">&nbsp;                                    if (hasPrefixBelow || canBecomePostfix)</b>
<b class="fc">&nbsp;                                        rret[i] = var(&quot;r&quot;);</b>
&nbsp;                                    else
<b class="fc">&nbsp;                                        variable = &quot;&quot;;</b>
<b class="fc">&nbsp;                                }</b>
&nbsp;                            } else
<b class="nc">&nbsp;                                arguments = new Expression[]{parity == 2 ? tuple(integer(0), integer(0)) : integer(0)};</b>
&nbsp;
<b class="fc">&nbsp;                        } else</b>
<b class="fc">&nbsp;                            arguments = new Expression[]{parity == 2 ? tuple(integer(0), integer(0)) : integer(0)};</b>
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    if (isUseOfLeftOrRightEnd) { // . ::= alpha X alpha</b>
<b class="fc">&nbsp;                        arguments = new Expression[config.pends.size()];</b>
<b class="fc">&nbsp;                        int i = 0;</b>
<b class="fc">&nbsp;                        for (String end : config.pends) {</b>
&nbsp;
<b class="fc">&nbsp;                            if (configs.get(end).leftEnds.contains(symbol.getName())</b>
<b class="fc">&nbsp;                                || configs.get(end).rightEnds.contains(symbol.getName())) {</b>
&nbsp;
<b class="fc">&nbsp;                                boolean canReachFromLeft = configs.get(end).leftEnds.contains(symbol.getName());</b>
<b class="fc">&nbsp;                                boolean canReachFromRight = configs.get(end).rightEnds.contains(symbol.getName());</b>
&nbsp;
<b class="fc">&nbsp;                                int parity = configs.get(end).parity;</b>
&nbsp;
<b class="fc">&nbsp;                                if (canReachFromLeft &amp;&amp; canReachFromRight)</b>
<b class="nc">&nbsp;                                    arguments[i] = tuple(parity == 2 ? tuple(integer(0), integer(0)) : integer(0),</b>
<b class="nc">&nbsp;                                                         parity == 2 ? tuple(integer(0), integer(0)) : integer(0));</b>
&nbsp;                                else
<b class="fc">&nbsp;                                    arguments[i] = parity == 2 ? tuple(integer(0), integer(0)) : integer(0);</b>
<b class="fc">&nbsp;                                i++;</b>
&nbsp;                            }
<b class="fc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    if (isRecursiveUseOfLeftOrRight &amp;&amp; isFirst &amp;&amp; isLast) // E ::= E</b>
<b class="nc">&nbsp;                        throw new RuntimeException(&quot;Cyclic use where precedence applies:&quot; + rule);</b>
&nbsp;
<b class="fc">&nbsp;                    if (isRecursiveUseOfLeftOrRight &amp;&amp; isFirst) { // E ::= E alpha</b>
<b class="fc">&nbsp;                        variable = &quot;l&quot;;</b>
<b class="fc">&nbsp;                        arguments = new Expression[]{larg};</b>
<b class="fc">&nbsp;                    } else if (isRecursiveUseOfLeftOrRight &amp;&amp; isLast) { // E ::= alpha E</b>
<b class="fc">&nbsp;                        variable = &quot;r&quot;;</b>
<b class="fc">&nbsp;                        arguments = new Expression[]{rarg};</b>
<b class="fc">&nbsp;                        if (!config.hasPrefixBelow(rule.getPrecedenceLevel().getLhs()))</b>
<b class="fc">&nbsp;                            variable = &quot;&quot;;</b>
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    Statement binding = null;</b>
<b class="fc">&nbsp;                    Statement lbinding = null;</b>
<b class="fc">&nbsp;                    Statement rbinding = null;</b>
&nbsp;
&nbsp;                    // TODO: if precedence also applies to X, propagate argument from E
<b class="fc">&nbsp;                    if (isIndirectRecursiveUseOfLeftOrRight) {</b>
&nbsp;
<b class="fc">&nbsp;                        boolean canReachLeft = configs.get(rule.getHead().getName()).leftEnds.contains(</b>
<b class="fc">&nbsp;                                symbol.getName());</b>
<b class="fc">&nbsp;                        boolean canReachRight = configs.get(rule.getHead().getName()).rightEnds.contains(</b>
<b class="fc">&nbsp;                                symbol.getName());</b>
&nbsp;
<b class="fc">&nbsp;                        if (isFirst &amp;&amp; isLast) { // E ::= X</b>
<b class="nc">&nbsp;                            if (pends.size() == 1) {</b>
<b class="nc">&nbsp;                                variable = symbol.getName().toLowerCase(); // x</b>
<b class="nc">&nbsp;                                if (canReachLeft &amp;&amp; canReachRight) {</b>
<b class="nc">&nbsp;                                    lbinding = varDeclStat(&quot;l&quot;, get(var(variable), 0));</b>
<b class="nc">&nbsp;                                    rbinding = varDeclStat(&quot;r&quot;, get(var(variable), 1));</b>
<b class="nc">&nbsp;                                    arguments = new Expression[]{tuple(larg, rarg)};</b>
<b class="nc">&nbsp;                                } else if (canReachLeft) {</b>
<b class="nc">&nbsp;                                    variable = &quot;l&quot;;</b>
<b class="nc">&nbsp;                                    arguments = new Expression[]{larg};</b>
&nbsp;                                } else {
<b class="nc">&nbsp;                                    boolean prefixBelow = configs.get(</b>
<b class="nc">&nbsp;                                            rule.getHead().getName()).rightEndsPrefixBelow.contains(symbol.getName());</b>
<b class="nc">&nbsp;                                    boolean canBecomePostfix = configs.get(</b>
<b class="nc">&nbsp;                                            rule.getHead().getName()).rightEndsThatCanLeadToPostfix.contains(</b>
<b class="nc">&nbsp;                                            symbol.getName());</b>
<b class="nc">&nbsp;                                    if (prefixBelow || canBecomePostfix)</b>
<b class="nc">&nbsp;                                        variable = &quot;r&quot;;</b>
&nbsp;                                    else
<b class="nc">&nbsp;                                        variable = &quot;&quot;;</b>
<b class="nc">&nbsp;                                    arguments = new Expression[]{rarg};</b>
<b class="nc">&nbsp;                                }</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                int i = config.pends.indexOf(rule.getHead().getName());</b>
<b class="nc">&nbsp;                                variable = symbol.getName().toLowerCase();</b>
<b class="nc">&nbsp;                                if (canReachLeft &amp;&amp; canReachRight) {</b>
<b class="nc">&nbsp;                                    lbinding = varDeclStat(&quot;l&quot;, get(get(var(variable), i), 0)); // l = x.i.0</b>
<b class="nc">&nbsp;                                    rbinding = varDeclStat(&quot;r&quot;, get(get(var(variable), i), 1)); // r = x.i.1</b>
<b class="nc">&nbsp;                                    arguments[i] = tuple(larg, rarg);</b>
<b class="nc">&nbsp;                                } else if (canReachLeft) {</b>
<b class="nc">&nbsp;                                    binding = varDeclStat(&quot;l&quot;, get(var(variable), i));</b>
<b class="nc">&nbsp;                                    arguments[i] = larg;</b>
&nbsp;                                } else {
<b class="nc">&nbsp;                                    boolean prefixBelow = configs.get(</b>
<b class="nc">&nbsp;                                            rule.getHead().getName()).rightEndsPrefixBelow.contains(symbol.getName());</b>
<b class="nc">&nbsp;                                    boolean canBecomePostfix = configs.get(</b>
<b class="nc">&nbsp;                                            rule.getHead().getName()).rightEndsThatCanLeadToPostfix.contains(</b>
<b class="nc">&nbsp;                                            symbol.getName());</b>
<b class="nc">&nbsp;                                    if (prefixBelow || canBecomePostfix)</b>
<b class="nc">&nbsp;                                        binding = varDeclStat(&quot;r&quot;, get(var(variable), i));</b>
&nbsp;                                    else
<b class="nc">&nbsp;                                        variable = &quot;&quot;;</b>
<b class="nc">&nbsp;                                    arguments[i] = rarg;</b>
&nbsp;                                }
<b class="nc">&nbsp;                            }</b>
<b class="fc">&nbsp;                        } else if (isFirst) { // E ::= X aplha</b>
<b class="nc">&nbsp;                            if (pends.size() == 1) {</b>
<b class="nc">&nbsp;                                variable = &quot;l&quot; + symbol.getName().toLowerCase();</b>
<b class="nc">&nbsp;                                if (canReachLeft &amp;&amp; canReachRight) {</b>
<b class="nc">&nbsp;                                    binding = varDeclStat(&quot;l&quot;, get(var(variable), 0));</b>
<b class="nc">&nbsp;                                    arguments = new Expression[]{tuple(larg,</b>
<b class="nc">&nbsp;                                                                       config.parity == 2 ? tuple(integer(0),</b>
<b class="nc">&nbsp;                                                                                                  integer(0)) : integer(</b>
<b class="nc">&nbsp;                                                                               0))};</b>
&nbsp;                                } else {
<b class="nc">&nbsp;                                    variable = &quot;l&quot;;</b>
<b class="nc">&nbsp;                                    arguments = new Expression[]{larg};</b>
&nbsp;                                }
&nbsp;                            } else {
<b class="nc">&nbsp;                                int i = config.pends.indexOf(rule.getHead().getName());</b>
<b class="nc">&nbsp;                                variable = &quot;l&quot; + symbol.getName().toLowerCase();</b>
<b class="nc">&nbsp;                                if (canReachLeft &amp;&amp; canReachRight) {</b>
<b class="nc">&nbsp;                                    binding = varDeclStat(&quot;l&quot;, get(get(var(variable), i), 0));</b>
<b class="nc">&nbsp;                                    arguments[i] = tuple(larg,</b>
<b class="nc">&nbsp;                                                         config.parity == 2 ? tuple(integer(0), integer(0)) : integer(</b>
<b class="nc">&nbsp;                                                                 0));</b>
&nbsp;                                } else {
<b class="nc">&nbsp;                                    binding = varDeclStat(&quot;l&quot;, get(var(variable), i));</b>
<b class="nc">&nbsp;                                    arguments[i] = larg;</b>
&nbsp;                                }
<b class="nc">&nbsp;                            }</b>
<b class="fc">&nbsp;                        } else if (isLast) { // E ::= alpha X</b>
<b class="fc">&nbsp;                            if (pends.size() == 1) {</b>
&nbsp;
<b class="fc">&nbsp;                                variable = &quot;r&quot; + symbol.getName().toLowerCase();</b>
<b class="fc">&nbsp;                                boolean prefixBelow = configs.get(</b>
<b class="fc">&nbsp;                                        rule.getHead().getName()).rightEndsPrefixBelow.contains(symbol.getName());</b>
<b class="fc">&nbsp;                                boolean canBecomePostfix = configs.get(</b>
<b class="fc">&nbsp;                                        rule.getHead().getName()).rightEndsThatCanLeadToPostfix.contains(</b>
<b class="fc">&nbsp;                                        symbol.getName());</b>
&nbsp;
<b class="fc">&nbsp;                                if (canReachLeft &amp;&amp; canReachRight) {</b>
<b class="nc">&nbsp;                                    if (prefixBelow || canBecomePostfix)</b>
<b class="nc">&nbsp;                                        binding = varDeclStat(&quot;r&quot;, get(var(variable), 1));</b>
&nbsp;                                    else
<b class="nc">&nbsp;                                        variable = &quot;&quot;;</b>
<b class="nc">&nbsp;                                    arguments = new Expression[]{tuple(</b>
<b class="nc">&nbsp;                                            config.parity == 2 ? tuple(integer(0), integer(0)) : integer(0), rarg)};</b>
&nbsp;                                } else {
<b class="fc">&nbsp;                                    if (prefixBelow || canBecomePostfix)</b>
<b class="fc">&nbsp;                                        variable = &quot;r&quot;;</b>
&nbsp;                                    else
<b class="fc">&nbsp;                                        variable = &quot;&quot;;</b>
<b class="fc">&nbsp;                                    arguments = new Expression[]{rarg};</b>
&nbsp;                                }
<b class="fc">&nbsp;                            } else {</b>
<b class="nc">&nbsp;                                int i = config.pends.indexOf(rule.getHead().getName());</b>
<b class="nc">&nbsp;                                variable = &quot;r&quot; + symbol.getName();</b>
<b class="nc">&nbsp;                                boolean prefixBelow = configs.get(</b>
<b class="nc">&nbsp;                                        rule.getHead().getName()).rightEndsPrefixBelow.contains(symbol.getName());</b>
<b class="nc">&nbsp;                                boolean canBecomePostfix = configs.get(</b>
<b class="nc">&nbsp;                                        rule.getHead().getName()).rightEndsThatCanLeadToPostfix.contains(</b>
<b class="nc">&nbsp;                                        symbol.getName());</b>
&nbsp;
<b class="nc">&nbsp;                                if (canReachLeft &amp;&amp; canReachRight) {</b>
<b class="nc">&nbsp;                                    if (prefixBelow || canBecomePostfix)</b>
<b class="nc">&nbsp;                                        binding = varDeclStat(&quot;r&quot;, get(get(var(variable), i), 1));</b>
&nbsp;                                    else
<b class="nc">&nbsp;                                        variable = &quot;&quot;;</b>
<b class="nc">&nbsp;                                    arguments[i] = tuple(</b>
<b class="nc">&nbsp;                                            config.parity == 2 ? tuple(integer(0), integer(0)) : integer(0), rarg);</b>
&nbsp;                                } else {
<b class="nc">&nbsp;                                    if (prefixBelow || canBecomePostfix)</b>
<b class="nc">&nbsp;                                        binding = varDeclStat(&quot;r&quot;, get(var(variable), i));</b>
&nbsp;                                    else
<b class="nc">&nbsp;                                        variable = &quot;&quot;;</b>
<b class="nc">&nbsp;                                    arguments[i] = rarg;</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;                        // TODO: if precedence also applies to X, use larg and rarg to propagate down
<b class="fc">&nbsp;                    } else if (isUseOfLeftOrRightEnd) {</b>
<b class="fc">&nbsp;                        if (isFirst &amp;&amp; isLast) { // X ::= Y</b>
<b class="fc">&nbsp;                            List&lt;String&gt; ends = config.pends;</b>
<b class="fc">&nbsp;                            for (String end : ends) {</b>
&nbsp;
<b class="fc">&nbsp;                                if (configs.get(end).leftEnds.contains(symbol.getName())</b>
<b class="fc">&nbsp;                                    || configs.get(end).rightEnds.contains(symbol.getName())) {</b>
&nbsp;
<b class="fc">&nbsp;                                    int i = ends.indexOf(end);</b>
&nbsp;
&nbsp;                                    // Note: shouldn&#39;t look up the left and right ends of the head
<b class="fc">&nbsp;                                    boolean canBeFromLeft = configs.get(end).leftEnds.contains(symbol.getName());</b>
<b class="fc">&nbsp;                                    boolean canBeFromRight = configs.get(end).rightEnds.contains(symbol.getName());</b>
&nbsp;
<b class="fc">&nbsp;                                    variable = symbol.getName().toLowerCase();</b>
<b class="fc">&nbsp;                                    arguments[i] = var(&quot;p&quot; + i);</b>
&nbsp;
<b class="fc">&nbsp;                                    if (canBeFromLeft &amp;&amp; canBeFromRight) {</b>
<b class="nc">&nbsp;                                        lret[config.pends.indexOf(end)] = ends.size() == 1 ? get(var(variable),</b>
<b class="nc">&nbsp;                                                                                                 0) : get(</b>
<b class="nc">&nbsp;                                                get(var(variable), i), 0);</b>
&nbsp;
<b class="nc">&nbsp;                                        boolean hasPrefixBelow = configs.get(end).rightEndsPrefixBelow.contains(</b>
<b class="nc">&nbsp;                                                symbol.getName());</b>
<b class="nc">&nbsp;                                        boolean canBecomePostfix = configs.get(</b>
<b class="nc">&nbsp;                                                end).rightEndsThatCanLeadToPostfix.contains(symbol.getName());</b>
&nbsp;
<b class="nc">&nbsp;                                        if (hasPrefixBelow || canBecomePostfix)</b>
<b class="nc">&nbsp;                                            rret[config.pends.indexOf(end)] = ends.size() == 1 ? get(var(variable),</b>
<b class="nc">&nbsp;                                                                                                     1) : get(</b>
<b class="nc">&nbsp;                                                    get(var(variable), i), 1);</b>
&nbsp;
<b class="nc">&nbsp;                                    } else if (canBeFromLeft) {</b>
<b class="nc">&nbsp;                                        variable = &quot;l&quot;;</b>
<b class="nc">&nbsp;                                        lret[config.pends.indexOf(end)] = ends.size() == 1 ? var(variable) : get(</b>
<b class="nc">&nbsp;                                                var(variable), i);</b>
&nbsp;                                    } else {
<b class="fc">&nbsp;                                        variable = &quot;r&quot;;</b>
<b class="fc">&nbsp;                                        boolean hasPrefixBelow = configs.get(end).rightEndsPrefixBelow.contains(</b>
<b class="fc">&nbsp;                                                symbol.getName());</b>
<b class="fc">&nbsp;                                        boolean canBecomePostfix = configs.get(</b>
<b class="fc">&nbsp;                                                end).rightEndsThatCanLeadToPostfix.contains(symbol.getName());</b>
&nbsp;
<b class="fc">&nbsp;                                        if (hasPrefixBelow || canBecomePostfix)</b>
<b class="fc">&nbsp;                                            rret[config.pends.indexOf(end)] = ends.size() == 1 ? var(variable) : get(</b>
<b class="nc">&nbsp;                                                    var(variable), i);</b>
&nbsp;                                        else
<b class="nc">&nbsp;                                            variable = &quot;&quot;;</b>
&nbsp;                                    }
&nbsp;                                }
<b class="fc">&nbsp;                            }</b>
<b class="fc">&nbsp;                        } else if (isFirst) { // X ::= Y alpha (includes X ::= X alpha)</b>
<b class="fc">&nbsp;                            List&lt;String&gt; ends = config.pends;</b>
<b class="fc">&nbsp;                            for (String end : ends) {</b>
&nbsp;
<b class="fc">&nbsp;                                if (configs.get(end).leftEnds.contains(symbol.getName())</b>
<b class="fc">&nbsp;                                    || configs.get(end).rightEnds.contains(symbol.getName())) {</b>
&nbsp;
<b class="fc">&nbsp;                                    int parity = configs.get(end).parity;</b>
<b class="fc">&nbsp;                                    int i = ends.indexOf(end);</b>
&nbsp;
&nbsp;                                    // Note: shouldn&#39;t look up the left and right ends of the head
<b class="fc">&nbsp;                                    boolean canBeFromLeft = configs.get(end).leftEnds.contains(</b>
<b class="fc">&nbsp;                                            rule.getHead().getName());</b>
<b class="fc">&nbsp;                                    boolean canBeFromRight = configs.get(end).rightEnds.contains(</b>
<b class="fc">&nbsp;                                            rule.getHead().getName());</b>
&nbsp;
<b class="fc">&nbsp;                                    variable = &quot;l&quot;;</b>
&nbsp;
<b class="fc">&nbsp;                                    if (canBeFromLeft &amp;&amp; canBeFromRight) {</b>
<b class="nc">&nbsp;                                        arguments[i] = tuple(get(var(&quot;p&quot; + i), 0),</b>
<b class="nc">&nbsp;                                                             parity == 2 ? tuple(integer(0), integer(0)) : integer(0));</b>
<b class="nc">&nbsp;                                        lret[config.pends.indexOf(end)] = ends.size() == 1 ? get(var(&quot;l&quot;), 0) : get(</b>
<b class="nc">&nbsp;                                                get(var(&quot;l&quot;), i), 0);</b>
<b class="fc">&nbsp;                                    } else if (canBeFromLeft) {</b>
<b class="nc">&nbsp;                                        arguments[i] = var(&quot;p&quot; + i);</b>
<b class="nc">&nbsp;                                        lret[config.pends.indexOf(end)] = ends.size() == 1 ? var(&quot;l&quot;) : get(var(&quot;l&quot;),</b>
&nbsp;                                                                                                            i);
<b class="fc">&nbsp;                                    } else if (canBeFromRight) {</b>
<b class="fc">&nbsp;                                        arguments[i] = parity == 2 ? tuple(integer(0), integer(0)) : integer(0);</b>
<b class="fc">&nbsp;                                        variable = &quot;&quot;;</b>
&nbsp;                                    }
&nbsp;                                }
<b class="fc">&nbsp;                            }</b>
<b class="fc">&nbsp;                        } else if (isLast) { // X ::= alpha Y (includes X ::= alpha X)</b>
<b class="fc">&nbsp;                            List&lt;String&gt; ends = config.pends;</b>
<b class="fc">&nbsp;                            for (String end : ends) {</b>
&nbsp;
<b class="fc">&nbsp;                                if (configs.get(end).leftEnds.contains(symbol.getName())</b>
<b class="fc">&nbsp;                                    || configs.get(end).rightEnds.contains(symbol.getName())) {</b>
&nbsp;
<b class="fc">&nbsp;                                    int parity = configs.get(end).parity;</b>
<b class="fc">&nbsp;                                    int i = ends.indexOf(end);</b>
&nbsp;
&nbsp;                                    // Note: shouldn&#39;t look up the left and right ends of the head
<b class="fc">&nbsp;                                    boolean canBeFromLeft = configs.get(end).leftEnds.contains(</b>
<b class="fc">&nbsp;                                            rule.getHead().getName());</b>
<b class="fc">&nbsp;                                    boolean canBeFromRight = configs.get(end).rightEnds.contains(</b>
<b class="fc">&nbsp;                                            rule.getHead().getName());</b>
&nbsp;
<b class="fc">&nbsp;                                    variable = &quot;r&quot;;</b>
&nbsp;
<b class="fc">&nbsp;                                    if (canBeFromLeft &amp;&amp; canBeFromRight) {</b>
<b class="nc">&nbsp;                                        arguments[i] = tuple(parity == 2 ? tuple(integer(0), integer(0)) : integer(0),</b>
<b class="nc">&nbsp;                                                             get(var(&quot;p&quot; + i), 1));</b>
&nbsp;
<b class="nc">&nbsp;                                        boolean hasPrefixBelow = configs.get(end).rightEndsPrefixBelow.contains(</b>
<b class="nc">&nbsp;                                                symbol.getName());</b>
<b class="nc">&nbsp;                                        boolean canBecomePostfix = configs.get(</b>
<b class="nc">&nbsp;                                                end).rightEndsThatCanLeadToPostfix.contains(symbol.getName());</b>
&nbsp;
<b class="nc">&nbsp;                                        if (hasPrefixBelow || canBecomePostfix)</b>
<b class="nc">&nbsp;                                            rret[config.pends.indexOf(end)] = ends.size() == 1 ? get(var(&quot;r&quot;), 1) : get(</b>
<b class="nc">&nbsp;                                                    get(var(&quot;r&quot;), i), 1);</b>
&nbsp;                                        else
<b class="nc">&nbsp;                                            variable = &quot;&quot;;</b>
<b class="nc">&nbsp;                                    } else if (canBeFromRight) {</b>
&nbsp;
<b class="fc">&nbsp;                                        arguments[i] = var(&quot;p&quot; + i);</b>
&nbsp;
<b class="fc">&nbsp;                                        boolean hasPrefixBelow = configs.get(end).rightEndsPrefixBelow.contains(</b>
<b class="fc">&nbsp;                                                symbol.getName());</b>
<b class="fc">&nbsp;                                        boolean canBecomePostfix = configs.get(</b>
<b class="fc">&nbsp;                                                end).rightEndsThatCanLeadToPostfix.contains(symbol.getName());</b>
&nbsp;
<b class="fc">&nbsp;                                        if (hasPrefixBelow || canBecomePostfix)</b>
<b class="fc">&nbsp;                                            rret[config.pends.indexOf(end)] = ends.size() == 1 ? var(&quot;r&quot;) : get(</b>
<b class="nc">&nbsp;                                                    var(&quot;r&quot;), i);</b>
&nbsp;                                        else
<b class="fc">&nbsp;                                            variable = &quot;&quot;;</b>
<b class="fc">&nbsp;                                    } else if (canBeFromLeft) {</b>
<b class="nc">&nbsp;                                        arguments[i] = parity == 2 ? tuple(integer(0), integer(0)) : integer(0);</b>
<b class="nc">&nbsp;                                        variable = &quot;&quot;;</b>
&nbsp;                                    }
&nbsp;                                }
<b class="fc">&nbsp;                            }</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    // Case of a left-recursive nonterminal that does not specify precedence
<b class="fc">&nbsp;                    if (labels != null &amp;&amp; symbol.getExcepts() != null &amp;&amp; rule.isLeftRecursive() &amp;&amp; isFirst)</b>
<b class="fc">&nbsp;                        variable = &quot;l&quot;;</b>
&nbsp;
<b class="fc">&nbsp;                    Symbol newone = null;</b>
&nbsp;
<b class="fc">&nbsp;                    if (arguments != null) {</b>
&nbsp;
<b class="fc">&nbsp;                        int n = 0;</b>
<b class="fc">&nbsp;                        for (Expression argument : arguments)</b>
<b class="fc">&nbsp;                            if (argument != null)</b>
<b class="fc">&nbsp;                                n++;</b>
&nbsp;
<b class="fc">&nbsp;                        Expression[] args = new Expression[n];</b>
&nbsp;
<b class="fc">&nbsp;                        n = 0;</b>
<b class="fc">&nbsp;                        for (Expression argument : arguments)</b>
<b class="fc">&nbsp;                            if (argument != null) {</b>
<b class="fc">&nbsp;                                args[n] = argument;</b>
<b class="fc">&nbsp;                                n++;</b>
&nbsp;                            }
&nbsp;
<b class="fc">&nbsp;                        arguments = args;</b>
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    if (arguments != null &amp;&amp; _not != null)</b>
<b class="fc">&nbsp;                        newone = variable.isEmpty() ? symbol.copy().apply(arguments).apply(_not).build()</b>
<b class="fc">&nbsp;                                : symbol.copy().apply(arguments).apply(_not).setVariable(variable)</b>
<b class="fc">&nbsp;                                        .build();</b>
<b class="fc">&nbsp;                    else if (arguments != null) {</b>
<b class="fc">&nbsp;                        newone = variable.isEmpty() ? symbol.copy().apply(arguments).build()</b>
<b class="fc">&nbsp;                                : symbol.copy().apply(arguments).setVariable(variable).build();</b>
&nbsp;                    } else
<b class="fc">&nbsp;                        newone = variable.isEmpty() ? symbol.copy().apply(_not).build()</b>
<b class="fc">&nbsp;                                : symbol.copy().apply(_not).setVariable(variable).build();</b>
<b class="fc">&nbsp;                    if (binding != null)</b>
<b class="nc">&nbsp;                        return Code.code(newone, binding);</b>
<b class="fc">&nbsp;                    else if (lbinding != null &amp;&amp; rbinding != null) {</b>
<b class="nc">&nbsp;                        return Code.code(newone, lbinding, rbinding);</b>
&nbsp;                    } else
<b class="fc">&nbsp;                        return newone;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            return symbol;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Symbol visit(Offside symbol) {
<b class="nc">&nbsp;            Symbol sym = symbol.getSymbol().accept(this);</b>
&nbsp;
<b class="nc">&nbsp;            return sym == symbol.getSymbol() ? symbol</b>
<b class="nc">&nbsp;                    : new Offside.Builder(sym).setLabel(symbol.getLabel()).addConditions(symbol).build();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Symbol visit(Terminal symbol) {
<b class="fc">&nbsp;            return symbol;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Symbol visit(While symbol) {
<b class="nc">&nbsp;            Symbol body = symbol.getBody().accept(this);</b>
<b class="nc">&nbsp;            if (body == symbol.getBody())</b>
<b class="nc">&nbsp;                return symbol;</b>
&nbsp;
<b class="nc">&nbsp;            return new While.Builder(symbol.getExpression(), body).setLabel(symbol.getLabel()).addConditions(symbol)</b>
<b class="nc">&nbsp;                                                                  .build();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Symbol visit(Return symbol) {
<b class="fc">&nbsp;            return symbol;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Symbol visit(Alt symbol) {
<b class="nc">&nbsp;            throw new RuntimeException(&quot;TODO: Unsupported EBNF while desugaring &gt; and assoc!&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Symbol visit(Opt symbol) {
<b class="nc">&nbsp;            throw new RuntimeException(&quot;TODO: Unsupported EBNF while desugaring &gt; and assoc!&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Symbol visit(Plus symbol) {
<b class="nc">&nbsp;            throw new RuntimeException(&quot;TODO: Unsupported EBNF while desugaring &gt; and assoc!&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Symbol visit(Group symbol) {
<b class="nc">&nbsp;            throw new RuntimeException(&quot;TODO: Unsupported EBNF while desugaring &gt; and assoc!&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Symbol visit(Star symbol) {
<b class="nc">&nbsp;            throw new RuntimeException(&quot;TODO: Unsupported EBNF while desugaring &gt; and assoc!&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Symbol visit(Start start) {
<b class="nc">&nbsp;            return start;</b>
&nbsp;//            return start.getNonterminal().accept(this);
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 17:08</div>
</div>
</body>
</html>
