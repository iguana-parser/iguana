


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > GenerateJFlex</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.iguana.traversal.idea</a>
</div>

<h1>Coverage Summary for Class: GenerateJFlex (org.iguana.traversal.idea)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">GenerateJFlex</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/26)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/202)
  </span>
</td>
</tr>
  <tr>
    <td class="name">GenerateJFlex$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/27)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/203)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright (c) 2015, Ali Afroozeh and Anastasia Izmaylova, Centrum Wiskunde &amp; Informatica (CWI)
&nbsp; * All rights reserved.
&nbsp; *
&nbsp; * Redistribution and use in source and binary forms, with or without
&nbsp; * modification, are permitted provided that the following conditions are met:
&nbsp; *
&nbsp; * 1. Redistributions of source code must retain the above copyright notice, this
&nbsp; *    list of conditions and the following disclaimer.
&nbsp; *
&nbsp; * 2. Redistributions in binary form must reproduce the above copyright notice, this
&nbsp; *    list of conditions and the following disclaimer in the documentation and/or
&nbsp; *    other materials provided with the distribution.
&nbsp; *
&nbsp; * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
&nbsp; * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
&nbsp; * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
&nbsp; * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
&nbsp; * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
&nbsp; * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
&nbsp; * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
&nbsp; * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
&nbsp; * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
&nbsp; * OF SUCH DAMAGE.
&nbsp; *
&nbsp; */
&nbsp;
&nbsp;package org.iguana.traversal.idea;
&nbsp;
&nbsp;import org.iguana.grammar.condition.Condition;
&nbsp;import org.iguana.grammar.condition.RegularExpressionCondition;
&nbsp;import org.iguana.regex.Char;
&nbsp;import org.iguana.regex.EOF;
&nbsp;import org.iguana.regex.RegularExpression;
&nbsp;import org.iguana.regex.visitor.RegularExpressionVisitor;
&nbsp;
&nbsp;import java.io.File;
&nbsp;import java.io.FileNotFoundException;
&nbsp;import java.io.PrintWriter;
&nbsp;import java.io.UnsupportedEncodingException;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;import java.util.stream.Collectors;
&nbsp;
&nbsp;/**
&nbsp; * Created by Anastasia Izmaylova on 17/12/15.
&nbsp; */
&nbsp;class GenerateJFlex implements RegularExpressionVisitor&lt;String&gt; {
&nbsp;    /*
&nbsp;     * &lt;Lang&gt;TokenTypes.java
&nbsp;     * &lt;Lang&gt;.flex
&nbsp;     * &lt;Lang&gt;Lexer.java
&nbsp;     */
&nbsp;    private final String language;
&nbsp;    private final String path;
&nbsp;
&nbsp;    private final Map&lt;String, RegularExpression&gt; regularExpressions;
&nbsp;
&nbsp;    private final Set&lt;String&gt; seenTokenTypes;
&nbsp;
&nbsp;    private final StringBuffer header;
&nbsp;    private final StringBuffer macros;
&nbsp;    private final StringBuffer rules;
&nbsp;    private final StringBuffer tokens;
&nbsp;
&nbsp;    GenerateJFlex(
&nbsp;            String language,
&nbsp;            String path,
&nbsp;            Map&lt;String, RegularExpression&gt; regularExpressions,
<b class="nc">&nbsp;            Set&lt;String&gt; seenTokenTypes) {</b>
<b class="nc">&nbsp;        this.language = language;</b>
<b class="nc">&nbsp;        this.path = path;</b>
<b class="nc">&nbsp;        this.regularExpressions = regularExpressions;</b>
<b class="nc">&nbsp;        this.seenTokenTypes = seenTokenTypes;</b>
<b class="nc">&nbsp;        this.header = new StringBuffer();</b>
<b class="nc">&nbsp;        this.macros = new StringBuffer();</b>
<b class="nc">&nbsp;        this.rules = new StringBuffer();</b>
<b class="nc">&nbsp;        this.tokens = new StringBuffer();</b>
&nbsp;    }
&nbsp;
&nbsp;    public void generate() {
&nbsp;
<b class="nc">&nbsp;        header.append(&quot;package &quot; + language.toLowerCase() + &quot;.gen.lexer;\n\n&quot;);</b>
<b class="nc">&nbsp;        header.append(&quot;import com.intellij.lexer.FlexLexer;\n&quot;);</b>
<b class="nc">&nbsp;        header.append(&quot;import com.intellij.psi.tree.IElementType;\n&quot;);</b>
<b class="nc">&nbsp;        header.append(&quot;import &quot; + language.toLowerCase() + &quot;.gen.psi.&quot; + language + &quot;TokenTypes;\n\n&quot;);</b>
<b class="nc">&nbsp;        header.append(&quot;%%\n\n&quot;);</b>
<b class="nc">&nbsp;        header.append(&quot;%public&quot;).append(&quot;\n&quot;);</b>
<b class="nc">&nbsp;        header.append(&quot;%class &quot; + &quot;_&quot; + language + &quot;Lexer&quot;).append(&quot;\n&quot;);</b>
<b class="nc">&nbsp;        header.append(&quot;%implements FlexLexer&quot;).append(&quot;\n&quot;);</b>
<b class="nc">&nbsp;        header.append(&quot;%function advance&quot;).append(&quot;\n&quot;);</b>
<b class="nc">&nbsp;        header.append(&quot;%type IElementType&quot;).append(&quot;\n&quot;);</b>
<b class="nc">&nbsp;        header.append(&quot;%unicode&quot;).append(&quot;\n&quot;);</b>
<b class="nc">&nbsp;        header.append(&quot;%eof{&quot;).append(&quot;\n&quot;);</b>
<b class="nc">&nbsp;        header.append(&quot;  return;&quot;).append(&quot;\n&quot;);</b>
<b class="nc">&nbsp;        header.append(&quot;%eof}&quot;).append(&quot;\n\n&quot;);</b>
&nbsp;
<b class="nc">&nbsp;        rules.append(&quot;%%&quot;).append(&quot;\n&quot;).append(&quot;\n&quot;);</b>
<b class="nc">&nbsp;        rules.append(&quot;&lt;YYINITIAL&gt; {&quot;).append(&quot;\n&quot;);</b>
&nbsp;
<b class="nc">&nbsp;        seenTokenTypes.add(&quot;Keyword&quot;);</b>
<b class="nc">&nbsp;        tokens.append(&quot;    IElementType Keyword = new &quot; + language + &quot;TokenType(\&quot;Keyword\&quot;);&quot;)</b>
<b class="nc">&nbsp;                .append(&quot;\n&quot;);</b>
<b class="nc">&nbsp;        regularExpressions.entrySet().stream()</b>
<b class="nc">&nbsp;                .filter(entry -&gt; entry.getKey().startsWith(&quot;|keyword|:&quot;))</b>
<b class="nc">&nbsp;                .forEach(entry -&gt; {</b>
<b class="nc">&nbsp;                    String regex = entry.getValue().accept(this);</b>
<b class="nc">&nbsp;                    rules.append(regex + getLookaheads(entry.getValue().getLookaheads()))</b>
<b class="nc">&nbsp;                            .append(&quot;\t{ return &quot; + language + &quot;TokenTypes.Keyword; }&quot;).append(&quot;\n&quot;);</b>
&nbsp;                });
&nbsp;
<b class="nc">&nbsp;        regularExpressions.entrySet().stream()</b>
<b class="nc">&nbsp;                .filter(entry -&gt; entry.getKey().startsWith(&quot;|regex|:&quot;))</b>
<b class="nc">&nbsp;                .forEach(entry -&gt; {</b>
<b class="nc">&nbsp;                    String tokenType = entry.getKey().replaceFirst(&quot;\\|regex\\|:&quot;, &quot;&quot;).toUpperCase();</b>
&nbsp;
<b class="nc">&nbsp;                    if (!seenTokenTypes.contains(tokenType)) {</b>
<b class="nc">&nbsp;                        seenTokenTypes.add(tokenType);</b>
<b class="nc">&nbsp;                        tokens.append(</b>
&nbsp;                                        &quot;    IElementType &quot; + tokenType + &quot; = new &quot; + language + &quot;TokenType(\&quot;&quot;
&nbsp;                                        + tokenType
&nbsp;                                        + &quot;\&quot;);&quot;)
<b class="nc">&nbsp;                                .append(&quot;\n&quot;);</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    macros.append(tokenType + &quot;=&quot; + entry.getValue().accept(this)).append(&quot;\n&quot;);</b>
<b class="nc">&nbsp;                    rules.append(&quot;{&quot; + tokenType + &quot;} &quot; + getLookaheads(entry.getValue().getLookaheads()))</b>
<b class="nc">&nbsp;                            .append(&quot;\t{ return &quot; + language + &quot;TokenTypes.&quot; + tokenType + &quot;; }&quot;).append(&quot;\n&quot;);</b>
&nbsp;                });
&nbsp;
<b class="nc">&nbsp;        regularExpressions.entrySet().stream()</b>
<b class="nc">&nbsp;                .filter(entry -&gt; !(entry.getKey().startsWith(&quot;|regex|:&quot;) || entry.getKey().startsWith(&quot;|keyword|:&quot;)))</b>
<b class="nc">&nbsp;                .forEach(entry -&gt; {</b>
<b class="nc">&nbsp;                    String regex = entry.getValue().accept(this);</b>
<b class="nc">&nbsp;                    String tokenType = getTokenType(regex);</b>
&nbsp;
<b class="nc">&nbsp;                    if (!seenTokenTypes.contains(tokenType)) {</b>
<b class="nc">&nbsp;                        seenTokenTypes.add(tokenType);</b>
<b class="nc">&nbsp;                        tokens.append(</b>
&nbsp;                                        &quot;    IElementType &quot; + tokenType + &quot; = new &quot; + language + &quot;TokenType(\&quot;&quot;
&nbsp;                                        + tokenType
&nbsp;                                        + &quot;\&quot;);&quot;)
<b class="nc">&nbsp;                                .append(&quot;\n&quot;);</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    rules.append(regex + getLookaheads(entry.getValue().getLookaheads()))</b>
<b class="nc">&nbsp;                            .append(&quot;\t{ return &quot; + language + &quot;TokenTypes.&quot; + tokenType + &quot;; }&quot;).append(&quot;\n&quot;);</b>
&nbsp;                });
&nbsp;
<b class="nc">&nbsp;        rules.append(&quot;[^]&quot;).append(&quot;\t { return &quot; + language + &quot;TokenTypes.BAD_CHARACTER; }\n&quot;);</b>
<b class="nc">&nbsp;        rules.append(&quot;}&quot;).append(&quot;\n&quot;);</b>
&nbsp;
<b class="nc">&nbsp;        seenTokenTypes.add(&quot;BAD_CHARACTER&quot;);</b>
&nbsp;
<b class="nc">&nbsp;        File file = new File(path + language.toLowerCase() + &quot;/gen/psi/&quot; + language + &quot;TokenTypes.java&quot;);</b>
&nbsp;        try {
<b class="nc">&nbsp;            PrintWriter writer = new PrintWriter(file.getAbsolutePath(), &quot;UTF-8&quot;);</b>
<b class="nc">&nbsp;            writer.println(&quot;package &quot; + language.toLowerCase() + &quot;.gen.psi;&quot;);</b>
<b class="nc">&nbsp;            writer.println();</b>
<b class="nc">&nbsp;            writer.println(&quot;/** This file has been generated. */&quot;);</b>
<b class="nc">&nbsp;            writer.println();</b>
<b class="nc">&nbsp;            writer.println(&quot;import com.intellij.psi.tree.IElementType;&quot;);</b>
<b class="nc">&nbsp;            writer.println(&quot;import &quot; + language.toLowerCase() + &quot;.gen.psi.&quot; + language + &quot;TokenType;&quot;);</b>
<b class="nc">&nbsp;            writer.println();</b>
<b class="nc">&nbsp;            writer.println(&quot;public interface &quot; + language + &quot;TokenTypes {&quot;);</b>
<b class="nc">&nbsp;            writer.println();</b>
<b class="nc">&nbsp;            writer.print(tokens.toString());</b>
<b class="nc">&nbsp;            if (!seenTokenTypes.contains(&quot;TERMINAL&quot;))</b>
<b class="nc">&nbsp;                writer.println(&quot;    IElementType TERMINAL = new &quot; + language + &quot;TokenType(\&quot;TERMINAL\&quot;);&quot;);</b>
<b class="nc">&nbsp;            writer.println(&quot;    IElementType BAD_CHARACTER = new &quot; + language + &quot;TokenType(\&quot;BAD_CHARACTER\&quot;);&quot;);</b>
<b class="nc">&nbsp;            writer.println();</b>
<b class="nc">&nbsp;            writer.println(&quot;    static IElementType get(String name) {&quot;);</b>
<b class="nc">&nbsp;            writer.println(&quot;        switch (name) {&quot;);</b>
<b class="nc">&nbsp;            for (String tokenType : seenTokenTypes)</b>
<b class="nc">&nbsp;                writer.println(&quot;            case \&quot;&quot; + tokenType + &quot;\&quot;: return &quot; + tokenType + &quot;;&quot;);</b>
<b class="nc">&nbsp;            writer.println(&quot;            default: return TERMINAL;&quot;);</b>
<b class="nc">&nbsp;            writer.println(&quot;        }&quot;);</b>
<b class="nc">&nbsp;            writer.println(&quot;    }&quot;);</b>
<b class="nc">&nbsp;            writer.println(&quot;}&quot;);</b>
<b class="nc">&nbsp;            writer.println();</b>
<b class="nc">&nbsp;            writer.close();</b>
<b class="nc">&nbsp;        } catch (FileNotFoundException e) {</b>
<b class="nc">&nbsp;            e.printStackTrace();</b>
<b class="nc">&nbsp;        } catch (UnsupportedEncodingException e) {</b>
<b class="nc">&nbsp;            e.printStackTrace();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        new File(path + language.toLowerCase() + &quot;/gen/lexer&quot;).mkdir();</b>
<b class="nc">&nbsp;        file = new File(path + language.toLowerCase() + &quot;/gen/lexer/&quot; + language + &quot;.flex&quot;);</b>
&nbsp;        try {
<b class="nc">&nbsp;            PrintWriter writer = new PrintWriter(file.getAbsolutePath(), &quot;UTF-8&quot;);</b>
<b class="nc">&nbsp;            writer.println(header.toString());</b>
<b class="nc">&nbsp;            writer.println(macros.toString());</b>
<b class="nc">&nbsp;            writer.println(rules.toString());</b>
<b class="nc">&nbsp;            writer.println();</b>
<b class="nc">&nbsp;            writer.close();</b>
<b class="nc">&nbsp;        } catch (FileNotFoundException e) {</b>
<b class="nc">&nbsp;            e.printStackTrace();</b>
<b class="nc">&nbsp;        } catch (UnsupportedEncodingException e) {</b>
<b class="nc">&nbsp;            e.printStackTrace();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        file = new File(path + language.toLowerCase() + &quot;/gen/lexer/&quot; + language + &quot;Lexer.java&quot;);</b>
&nbsp;        try {
<b class="nc">&nbsp;            PrintWriter writer = new PrintWriter(file.getAbsolutePath(), &quot;UTF-8&quot;);</b>
<b class="nc">&nbsp;            writer.println(&quot;package &quot; + language.toLowerCase() + &quot;.gen.lexer;&quot;);</b>
<b class="nc">&nbsp;            writer.println();</b>
<b class="nc">&nbsp;            writer.println(&quot;/** This file has been generated. */&quot;);</b>
<b class="nc">&nbsp;            writer.println();</b>
<b class="nc">&nbsp;            writer.println(&quot;import com.intellij.lexer.FlexAdapter;&quot;);</b>
<b class="nc">&nbsp;            writer.println(&quot;import java.io.Reader;&quot;);</b>
<b class="nc">&nbsp;            writer.println();</b>
<b class="nc">&nbsp;            writer.println(&quot;public class &quot; + language + &quot;Lexer extends FlexAdapter {&quot;);</b>
<b class="nc">&nbsp;            writer.println(&quot;    public &quot; + language + &quot;Lexer() { super(new _&quot; + language + &quot;Lexer((Reader) null)); }&quot;);</b>
<b class="nc">&nbsp;            writer.println(&quot;}&quot;);</b>
<b class="nc">&nbsp;            writer.println();</b>
<b class="nc">&nbsp;            writer.close();</b>
<b class="nc">&nbsp;        } catch (FileNotFoundException e) {</b>
<b class="nc">&nbsp;            e.printStackTrace();</b>
<b class="nc">&nbsp;        } catch (UnsupportedEncodingException e) {</b>
<b class="nc">&nbsp;            e.printStackTrace();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String visit(EOF eof) {
<b class="nc">&nbsp;        throw new UnsupportedOperationException();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String visit(org.iguana.regex.Epsilon e) {
<b class="nc">&nbsp;        return &quot;&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String visit(Char c) {
<b class="nc">&nbsp;        return getChar(c.getValue());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String visit(org.iguana.regex.CharRange r) {
<b class="nc">&nbsp;        return &quot;[&quot; + getRange(r) + &quot;]&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String visit(org.iguana.regex.Star s) {
<b class="nc">&nbsp;        return s.getSymbol().accept(this) + &quot;*&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String visit(org.iguana.regex.Plus p) {
<b class="nc">&nbsp;        return p.getSymbol().accept(this) + &quot;+&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String visit(org.iguana.regex.Opt o) {
<b class="nc">&nbsp;        return o.getSymbol().accept(this) + &quot;?&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public &lt;E extends RegularExpression&gt; String visit(org.iguana.regex.Alt&lt;E&gt; symbol) {
<b class="nc">&nbsp;        Map&lt;Boolean, List&lt;E&gt;&gt; partition = symbol.getSymbols().stream().collect(</b>
<b class="nc">&nbsp;                Collectors.partitioningBy(s -&gt; isCharClass(s)));</b>
<b class="nc">&nbsp;        List&lt;E&gt; charClasses = partition.get(true);</b>
<b class="nc">&nbsp;        List&lt;E&gt; other = partition.get(false);</b>
&nbsp;
<b class="nc">&nbsp;        StringBuilder sb = new StringBuilder();</b>
&nbsp;
<b class="nc">&nbsp;        if (!charClasses.isEmpty() &amp;&amp; !other.isEmpty()) {</b>
<b class="nc">&nbsp;            int left = charClasses.size();</b>
<b class="nc">&nbsp;            int right = other.stream().map(s -&gt; (RegularExpression) s).mapToInt(r -&gt; r.length()).max().getAsInt();</b>
&nbsp;
<b class="nc">&nbsp;            sb.append(&quot;(&quot;);</b>
<b class="nc">&nbsp;            if (left &gt; right) {</b>
<b class="nc">&nbsp;                sb.append(&quot;[&quot; + charClasses.stream().map(s -&gt; asCharClass(s)).collect(Collectors.joining()) + &quot;]&quot;);</b>
<b class="nc">&nbsp;                sb.append(&quot;|&quot;);</b>
<b class="nc">&nbsp;                sb.append(other.stream().map(s -&gt; s.accept(this)).collect(Collectors.joining(&quot;|&quot;)));</b>
&nbsp;            } else {
<b class="nc">&nbsp;                sb.append(other.stream().sorted(RegularExpression.lengthComparator()).map(s -&gt; s.accept(this))</b>
<b class="nc">&nbsp;                        .collect(Collectors.joining(&quot;|&quot;)));</b>
<b class="nc">&nbsp;                sb.append(&quot;|&quot;);</b>
<b class="nc">&nbsp;                sb.append(&quot;[&quot; + charClasses.stream().map(s -&gt; asCharClass(s)).collect(Collectors.joining()) + &quot;]&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            sb.append(&quot;)&quot;);</b>
<b class="nc">&nbsp;        } else if (!charClasses.isEmpty()) {</b>
<b class="nc">&nbsp;            sb.append(&quot;[&quot; + charClasses.stream().map(s -&gt; asCharClass(s)).collect(Collectors.joining()) + &quot;]&quot;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            sb.append(&quot;(&quot; + other.stream().sorted(RegularExpression.lengthComparator()).map(s -&gt; s.accept(this))</b>
<b class="nc">&nbsp;                    .collect(Collectors.joining(&quot;|&quot;)) + &quot;)&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return sb.toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public &lt;E extends RegularExpression&gt; String visit(org.iguana.regex.Seq&lt;E&gt; symbol) {
&nbsp;
<b class="nc">&nbsp;        List&lt;E&gt; symbols = symbol.getSymbols();</b>
&nbsp;
<b class="nc">&nbsp;        if (symbols.size() == 1)</b>
<b class="nc">&nbsp;            return &quot;[&quot; + symbols.get(0).accept(this) + &quot;]&quot;;</b>
&nbsp;
<b class="nc">&nbsp;        return &quot;(&quot; + symbols.stream().map(s -&gt; s.accept(this)).collect(Collectors.joining()) + &quot;)&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String visit(org.iguana.regex.Reference reference) {
<b class="nc">&nbsp;        throw new RuntimeException();</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean isCharClass(RegularExpression s) {
<b class="nc">&nbsp;        if (!s.getLookaheads().isEmpty()) return false;</b>
<b class="nc">&nbsp;        return s instanceof Char || s instanceof org.iguana.regex.CharRange;</b>
&nbsp;    }
&nbsp;
&nbsp;    private String asCharClass(RegularExpression s) {
<b class="nc">&nbsp;        if (s instanceof Char) {</b>
<b class="nc">&nbsp;            Char c = (Char) s;</b>
<b class="nc">&nbsp;            return getChar(c.getValue());</b>
<b class="nc">&nbsp;        } else if (s instanceof org.iguana.regex.CharRange) {</b>
<b class="nc">&nbsp;            org.iguana.regex.CharRange r = (org.iguana.regex.CharRange) s;</b>
<b class="nc">&nbsp;            return getRange(r);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        throw new RuntimeException(s + &quot; is not a character or character class.&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    private String getTokenType(String terminal) {
<b class="nc">&nbsp;        switch (terminal) {</b>
&nbsp;            case &quot;[\\(]&quot;:
<b class="nc">&nbsp;                return &quot;OPEN_PARENTHESIS&quot;;</b>
&nbsp;            case &quot;[\\)]&quot;:
<b class="nc">&nbsp;                return &quot;CLOSE_PARENTHESIS&quot;;</b>
&nbsp;            case &quot;[\\[]&quot;:
<b class="nc">&nbsp;                return &quot;OPEN_BRACKET&quot;;</b>
&nbsp;            case &quot;[\\]]&quot;:
<b class="nc">&nbsp;                return &quot;CLOSE_BRACKET&quot;;</b>
&nbsp;            case &quot;[\\{]&quot;:
<b class="nc">&nbsp;                return &quot;OPEN_BRACE&quot;;</b>
&nbsp;            case &quot;[\\}]&quot;:
<b class="nc">&nbsp;                return &quot;CLOSE_BRACE&quot;;</b>
&nbsp;            case &quot;\\*]&quot;:
<b class="nc">&nbsp;                return &quot;OPERATOR&quot;;</b>
&nbsp;            case &quot;[/]&quot;:
<b class="nc">&nbsp;                return &quot;OPERATOR&quot;;</b>
&nbsp;            case &quot;[\\+]&quot;:
<b class="nc">&nbsp;                return &quot;OPERATOR&quot;;</b>
&nbsp;            case &quot;[\\-]&quot;:
<b class="nc">&nbsp;                return &quot;OPERATOR&quot;;</b>
&nbsp;            case &quot;[&amp;]&quot;:
<b class="nc">&nbsp;                return &quot;OPERATOR&quot;;</b>
&nbsp;            case &quot;[\\|]&quot;:
<b class="nc">&nbsp;                return &quot;OPERATOR&quot;;</b>
&nbsp;            case &quot;[=]&quot;:
<b class="nc">&nbsp;                return &quot;OPERATOR&quot;;</b>
&nbsp;            default:
<b class="nc">&nbsp;                return &quot;TERMINAL&quot;;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private String getConditions(Set&lt;Condition&gt; conditions) {
<b class="nc">&nbsp;        StringBuffer code = new StringBuffer();</b>
<b class="nc">&nbsp;        for (Condition condition : conditions)</b>
<b class="nc">&nbsp;            code.append(getCondition(condition));</b>
&nbsp;
<b class="nc">&nbsp;        return code.toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    private String getLookaheads(Set&lt;org.iguana.regex.CharRange&gt; lookaheads) {
<b class="nc">&nbsp;        return &quot;&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    private String getLookbehinds(Set&lt;org.iguana.regex.CharRange&gt; lookbehinds) {
<b class="nc">&nbsp;        return &quot;&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    private String getCondition(Condition condition) {
<b class="nc">&nbsp;        switch (condition.getType()) {</b>
&nbsp;            case NOT_FOLLOW:
<b class="nc">&nbsp;                return &quot;/!(&quot; + getRegularExpression(condition).accept(this) + &quot;)&quot;;</b>
&nbsp;            case FOLLOW:
<b class="nc">&nbsp;                return &quot;/(&quot; + getRegularExpression(condition).accept(this) + &quot;)&quot;;</b>
&nbsp;            default:
<b class="nc">&nbsp;                return &quot;&quot;;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static RegularExpression getRegularExpression(Condition condition) {
<b class="nc">&nbsp;        if (condition instanceof RegularExpressionCondition) {</b>
<b class="nc">&nbsp;            return ((RegularExpressionCondition) condition).getRegularExpression();</b>
&nbsp;        }
<b class="nc">&nbsp;        throw new UnsupportedOperationException();</b>
&nbsp;    }
&nbsp;
&nbsp;    private String getChar(int c) {
<b class="nc">&nbsp;        if (org.iguana.regex.CharacterRanges.isPrintableAscii(c))</b>
<b class="nc">&nbsp;            return escape((char) c + &quot;&quot;);</b>
&nbsp;        else
<b class="nc">&nbsp;            return escape(String.format(&quot;\\u%04X&quot;, c));</b>
&nbsp;    }
&nbsp;
&nbsp;    private String getRange(org.iguana.regex.CharRange r) {
<b class="nc">&nbsp;        return getChar(r.getStart()) + &quot;-&quot; + getChar(r.getEnd());</b>
&nbsp;    }
&nbsp;
&nbsp;    private String escape(String s) {
<b class="nc">&nbsp;        String backslash = &quot;\\&quot;;</b>
<b class="nc">&nbsp;        switch (s) {</b>
&nbsp;            case &quot;(&quot;:
&nbsp;            case &quot;)&quot;:
&nbsp;            case &quot;[&quot;:
&nbsp;            case &quot;]&quot;:
&nbsp;            case &quot;{&quot;:
&nbsp;            case &quot;}&quot;:
&nbsp;            case &quot;\\&quot;:
&nbsp;            case &quot;\&quot;&quot;:
&nbsp;            case &quot;^&quot;:
&nbsp;            case &quot;-&quot;:
&nbsp;            case &quot;=&quot;:
&nbsp;            case &quot;$&quot;:
&nbsp;            case &quot;!&quot;:
&nbsp;            case &quot;|&quot;:
&nbsp;            case &quot;?&quot;:
&nbsp;            case &quot;*&quot;:
&nbsp;            case &quot;+&quot;:
&nbsp;            case &quot;.&quot;:
<b class="nc">&nbsp;                return backslash + s;</b>
&nbsp;            default:
<b class="nc">&nbsp;                return s;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 17:08</div>
</div>
</body>
</html>
