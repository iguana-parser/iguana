


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > AST</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.iguana.datadependent.ast</a>
</div>

<h1>Coverage Summary for Class: AST (org.iguana.datadependent.ast)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">AST</td>
<td class="coverageStat">
  <span class="percent">
    50.7%
  </span>
  <span class="absValue">
    (37/73)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    54.4%
  </span>
  <span class="absValue">
    (43/79)
  </span>
</td>
</tr>
  <tr>
    <td class="name">AST$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AST$Assert</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (6/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AST$Contains</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AST$EndsWith</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AST$Find</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AST$Get</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    52.9%
  </span>
  <span class="absValue">
    (9/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AST$Get2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/20)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AST$Indent</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AST$Len</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AST$Map</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AST$Min</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AST$Neg</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AST$Pop</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AST$PPDeclare</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AST$PPLookup</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AST$Pr1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AST$Pr2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/24)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AST$Pr3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AST$Println</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AST$Push</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AST$Put</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (9/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AST$Put3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AST$Set</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AST$Shift</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    57.1%
  </span>
  <span class="absValue">
    (4/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AST$StartsWith</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AST$Top</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AST$Undef</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    44.9%
  </span>
  <span class="absValue">
    (62/138)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    30.5%
  </span>
  <span class="absValue">
    (100/328)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright (c) 2015, Ali Afroozeh and Anastasia Izmaylova, Centrum Wiskunde &amp; Informatica (CWI)
&nbsp; * All rights reserved.
&nbsp; *
&nbsp; * Redistribution and use in source and binary forms, with or without
&nbsp; * modification, are permitted provided that the following conditions are met:
&nbsp; *
&nbsp; * 1. Redistributions of source code must retain the above copyright notice, this
&nbsp; *    list of conditions and the following disclaimer.
&nbsp; *
&nbsp; * 2. Redistributions in binary form must reproduce the above copyright notice, this
&nbsp; *    list of conditions and the following disclaimer in the documentation and/or
&nbsp; *    other materials provided with the distribution.
&nbsp; *
&nbsp; * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
&nbsp; * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
&nbsp; * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
&nbsp; * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
&nbsp; * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
&nbsp; * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
&nbsp; * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
&nbsp; * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
&nbsp; * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
&nbsp; * OF SUCH DAMAGE.
&nbsp; *
&nbsp; */
&nbsp;
&nbsp;package org.iguana.datadependent.ast;
&nbsp;
&nbsp;import org.iguana.datadependent.env.IEvaluatorContext;
&nbsp;import org.iguana.datadependent.env.intarray.MutableLong;
&nbsp;import org.iguana.datadependent.values.Stack;
&nbsp;import org.iguana.grammar.exception.AssertionFailedException;
&nbsp;import org.iguana.grammar.exception.UnexpectedTypeOfArgumentException;
&nbsp;import org.iguana.sppf.NonPackedNode;
&nbsp;import org.iguana.utils.input.Input;
&nbsp;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.List;
&nbsp;
&nbsp;import static org.iguana.utils.string.StringUtil.listToString;
&nbsp;
<b class="nc">&nbsp;public class AST {</b>
&nbsp;
<b class="fc">&nbsp;    public static final Object UNDEF = new Object() {</b>
&nbsp;        public String toString() {
<b class="fc">&nbsp;            return &quot;UNDEF&quot;;</b>
&nbsp;        }
&nbsp;    };
&nbsp;
&nbsp;    /**
&nbsp;     * Expressions
&nbsp;     */
<b class="fc">&nbsp;    public static final Expression TRUE = Expression.Boolean.TRUE;</b>
<b class="fc">&nbsp;    public static final Expression FALSE = Expression.Boolean.FALSE;</b>
&nbsp;
&nbsp;    public static Expression.Integer integer(java.lang.Integer value) {
<b class="fc">&nbsp;        return new Expression.Integer(value);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Expression real(java.lang.Float value) {
<b class="nc">&nbsp;        return new Expression.Real(value);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Expression string(java.lang.String value) {
<b class="nc">&nbsp;        return new Expression.String(value);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Expression.Not not(Expression exp) {
<b class="fc">&nbsp;        return new Expression.Not(exp);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Expression tuple(Expression... args) {
<b class="fc">&nbsp;        return new Expression.Tuple(args);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Expression intTuple2(Expression.Integer element1, Expression.Integer element2) {
<b class="nc">&nbsp;        return new Expression.IntTuple2(element1, element2);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Expression.Name var(java.lang.String name) {
<b class="fc">&nbsp;        return new Expression.Name(name);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Expression var(java.lang.String name, int i) {
<b class="nc">&nbsp;        return new Expression.Name(name, i);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static class Println extends Expression.Call {
&nbsp;        Println(Expression... arguments) {
<b class="nc">&nbsp;            super(&quot;println&quot;, arguments);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Object interpret(IEvaluatorContext ctx, Input input) {
<b class="nc">&nbsp;            List&lt;Object&gt; arguments = interpretArguments(ctx, input);</b>
<b class="nc">&nbsp;            for (Object argument : arguments) {</b>
<b class="nc">&nbsp;                System.out.print(argument);</b>
<b class="nc">&nbsp;                System.out.print(&quot;; &quot;);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            System.out.println();</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static Println println(Expression... args) {
<b class="nc">&nbsp;        return new Println(args);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static class Assert extends Expression.Call {
&nbsp;
&nbsp;        Assert(Expression... arguments) {
<b class="fc">&nbsp;            super(&quot;assert&quot;, arguments);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Object interpret(IEvaluatorContext ctx, Input input) {
<b class="fc">&nbsp;            for (Expression argument : arguments) {</b>
<b class="fc">&nbsp;                Object value = argument.interpret(ctx, input);</b>
<b class="fc">&nbsp;                if (!(value instanceof java.lang.Boolean)) {</b>
<b class="nc">&nbsp;                    throw new UnexpectedTypeOfArgumentException(this);</b>
&nbsp;                }
<b class="fc">&nbsp;                if (!((java.lang.Boolean) value)) {</b>
<b class="nc">&nbsp;                    throw new AssertionFailedException(argument);</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static Assert assertion(Expression... args) {
<b class="fc">&nbsp;        return new Assert(args);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static class Set extends Expression.Call {
&nbsp;
&nbsp;        Set(Expression... arguments) {
<b class="fc">&nbsp;            super(&quot;set&quot;, arguments);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Object interpret(IEvaluatorContext ctx, Input input) {
<b class="fc">&nbsp;            List&lt;Object&gt; objects = interpretArguments(ctx, input);</b>
<b class="fc">&nbsp;            return new HashSet&lt;&gt;(objects);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static Set set(Expression... args) {
<b class="fc">&nbsp;        return new Set(args);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static class Indent extends Expression.Call {
&nbsp;
&nbsp;        Indent(Expression arg) {
<b class="fc">&nbsp;            super(&quot;indent&quot;, arg);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Object interpret(IEvaluatorContext ctx, Input input) {
<b class="fc">&nbsp;            Expression arg = arguments[0];</b>
<b class="fc">&nbsp;            Object value = arg.interpret(ctx, input);</b>
<b class="fc">&nbsp;            if (!(value instanceof java.lang.Integer)) {</b>
<b class="nc">&nbsp;                throw new UnexpectedTypeOfArgumentException(this);</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            return input.getColumnNumber((java.lang.Integer) value);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static Indent indent(Expression... args) {
<b class="fc">&nbsp;        if (args.length != 1) throw new RuntimeException(&quot;args size should be one&quot;);</b>
<b class="fc">&nbsp;        return indent(args[0]);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Indent indent(Expression arg) {
<b class="fc">&nbsp;        return new Indent(arg);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static class PPDeclare extends Expression.Call {
&nbsp;        public PPDeclare(Expression variable, Expression value) {
<b class="nc">&nbsp;            super(&quot;ppDeclare&quot;, variable, value);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Object interpret(IEvaluatorContext ctx, Input input) {
<b class="nc">&nbsp;            Expression variable = arguments[0];</b>
<b class="nc">&nbsp;            Expression value = arguments[1];</b>
&nbsp;
<b class="nc">&nbsp;            Object var = variable.interpret(ctx, input);</b>
&nbsp;
<b class="nc">&nbsp;            if (!(var instanceof NonPackedNode))</b>
<b class="nc">&nbsp;                throw new UnexpectedTypeOfArgumentException(this);</b>
&nbsp;
<b class="nc">&nbsp;            NonPackedNode node = (NonPackedNode) var;</b>
&nbsp;
<b class="nc">&nbsp;            ctx.declareGlobalVariable(input.subString(node.getLeftExtent(), node.getRightExtent()),</b>
<b class="nc">&nbsp;                value.interpret(ctx, input));</b>
&nbsp;
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static PPDeclare ppDeclare(Expression variable, Expression value) {
<b class="nc">&nbsp;        return new PPDeclare(variable, value);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static class PPLookup extends Expression.Call {
&nbsp;
&nbsp;        PPLookup(Expression... arguments) {
<b class="nc">&nbsp;            super(&quot;ppLookup&quot;, arguments);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Object interpret(IEvaluatorContext ctx, Input input) {
<b class="nc">&nbsp;            Object value = arguments[0].interpret(ctx, input);</b>
<b class="nc">&nbsp;            if (!(value instanceof NonPackedNode)) {</b>
<b class="nc">&nbsp;                throw new UnexpectedTypeOfArgumentException(this);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            NonPackedNode node = (NonPackedNode) value;</b>
&nbsp;
<b class="nc">&nbsp;            java.lang.String subString = input.subString(node.getLeftExtent(), node.getRightExtent());</b>
&nbsp;
<b class="nc">&nbsp;            if (subString.equals(&quot;true&quot;))</b>
<b class="nc">&nbsp;                return true;</b>
<b class="nc">&nbsp;            else if (subString.equals(&quot;false&quot;))</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;
<b class="nc">&nbsp;            Object obj = ctx.lookupGlobalVariable(subString);</b>
<b class="nc">&nbsp;            return obj != null ? obj : false;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static PPLookup ppLookup(Expression arg) {
<b class="nc">&nbsp;        return new PPLookup(arg);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static class EndsWith extends Expression.Call {
&nbsp;
&nbsp;        EndsWith(Expression... arguments) {
<b class="nc">&nbsp;            super(&quot;endsWith&quot;, arguments);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Object interpret(IEvaluatorContext ctx, Input input) {
<b class="nc">&nbsp;            Expression index = arguments[0];</b>
<b class="nc">&nbsp;            Expression character = arguments[1];</b>
&nbsp;
<b class="nc">&nbsp;            Object i = index.interpret(ctx, input);</b>
<b class="nc">&nbsp;            if (!(i instanceof java.lang.Integer)) {</b>
<b class="nc">&nbsp;                throw new UnexpectedTypeOfArgumentException(this);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            int j = (java.lang.Integer) i;</b>
&nbsp;
<b class="nc">&nbsp;            Object c = character.interpret(ctx, input);</b>
&nbsp;
<b class="nc">&nbsp;            if (!(c instanceof java.lang.String)) {</b>
<b class="nc">&nbsp;                throw new UnexpectedTypeOfArgumentException(this);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            Object obj = input.subString(j - 1, j);</b>
<b class="nc">&nbsp;            return obj.equals(c);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public java.lang.String toString() {
<b class="nc">&nbsp;            return java.lang.String.format(&quot;endsWith(%s,\&quot;%s\&quot;)&quot;, arguments[0], arguments[1]);</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    public static EndsWith endsWith(Expression index, Expression character) {
<b class="nc">&nbsp;        return new EndsWith(index, character);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static class StartsWith extends Expression.Call {
&nbsp;
&nbsp;        StartsWith(Expression... arguments) {
<b class="nc">&nbsp;            super(&quot;startsWith&quot;, arguments);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Object interpret(IEvaluatorContext ctx, Input input) {
<b class="nc">&nbsp;            Object i = arguments[0].interpret(ctx, input);</b>
<b class="nc">&nbsp;            if (!(i instanceof java.lang.Integer)) {</b>
<b class="nc">&nbsp;                throw new UnexpectedTypeOfArgumentException(this);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            int j = (java.lang.Integer) i;</b>
&nbsp;
<b class="nc">&nbsp;            for (int k = 1; k &lt; arguments.length; k++) {</b>
<b class="nc">&nbsp;                Object str = arguments[k].interpret(ctx, input);</b>
&nbsp;
<b class="nc">&nbsp;                if (!(str instanceof java.lang.String)) {</b>
<b class="nc">&nbsp;                    throw new UnexpectedTypeOfArgumentException(this);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                int len = j + ((java.lang.String) str).length();</b>
<b class="nc">&nbsp;                if (len &lt; input.length()) {</b>
<b class="nc">&nbsp;                    Object obj = input.subString(j, len);</b>
<b class="nc">&nbsp;                    if (obj.equals(str))</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static StartsWith startsWith(Expression... args) {
<b class="nc">&nbsp;        return new StartsWith(args);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static class Neg extends Expression.Call {
&nbsp;        Neg(Expression... arguments) {
<b class="fc">&nbsp;            super(&quot;neg&quot;, arguments);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Object interpret(IEvaluatorContext ctx, Input input) {
<b class="fc">&nbsp;            Object value = arguments[0].interpret(ctx, input);</b>
<b class="fc">&nbsp;            if (!(value instanceof java.lang.Integer)) {</b>
<b class="nc">&nbsp;                throw new UnexpectedTypeOfArgumentException(this);</b>
&nbsp;            }
<b class="fc">&nbsp;            int v = (java.lang.Integer) value;</b>
<b class="fc">&nbsp;            return -v;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public java.lang.String toString() {
<b class="fc">&nbsp;            return java.lang.String.format(&quot;-(%s)&quot;, arguments[0]);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static Neg neg(Expression arg) {
<b class="fc">&nbsp;        return new Neg(arg);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static class Len extends Expression.Call {
&nbsp;        Len(Expression... arguments) {
<b class="nc">&nbsp;            super(&quot;len&quot;, arguments);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Object interpret(IEvaluatorContext ctx, Input input) {
<b class="nc">&nbsp;            Object value = arguments[0].interpret(ctx, input);</b>
<b class="nc">&nbsp;            if (!(value instanceof NonPackedNode)) {</b>
<b class="nc">&nbsp;                throw new UnexpectedTypeOfArgumentException(this);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            NonPackedNode node = (NonPackedNode) value;</b>
&nbsp;
<b class="nc">&nbsp;            return node.getRightExtent() - node.getLeftExtent();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static Len len(Expression arg) {
<b class="nc">&nbsp;        return new Len(arg);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static class Pr1 extends Expression.Call {
&nbsp;        Pr1(Expression... arguments) {
<b class="nc">&nbsp;            super(&quot;pr1&quot;, arguments);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Object interpret(IEvaluatorContext ctx, Input input) {
<b class="nc">&nbsp;            Expression arg1 = arguments[0];</b>
<b class="nc">&nbsp;            Expression arg2 = arguments[0];</b>
<b class="nc">&nbsp;            Expression arg3 = arguments[0];</b>
<b class="nc">&nbsp;            int v = (java.lang.Integer) arg1.interpret(ctx, input);</b>
<b class="nc">&nbsp;            int curr = (java.lang.Integer) arg2.interpret(ctx, input);</b>
&nbsp;
<b class="nc">&nbsp;            if (v &gt;= curr)</b>
<b class="nc">&nbsp;                return v;</b>
&nbsp;
<b class="nc">&nbsp;            int prev = (java.lang.Integer) arg3.interpret(ctx, input); // prev is actually previous plus one</b>
&nbsp;
<b class="nc">&nbsp;            if (v &gt;= prev)</b>
<b class="nc">&nbsp;                return curr;</b>
&nbsp;
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static Pr1 pr1(Expression arg1, Expression arg2, Expression arg3) {
<b class="nc">&nbsp;        return new Pr1(arg1, arg2, arg3);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static class Pr2 extends Expression.Call {
&nbsp;        private final Expression arg1;
&nbsp;        private final Expression arg2;
&nbsp;        private final Expression[] arg3;
&nbsp;
&nbsp;        Pr2(Expression arg1, Expression arg2, Expression[] arg3) {
<b class="nc">&nbsp;            super(&quot;pr2&quot;, getArgs(arg1, arg2, arg3));</b>
<b class="nc">&nbsp;            this.arg1 = arg1;</b>
<b class="nc">&nbsp;            this.arg2 = arg2;</b>
<b class="nc">&nbsp;            this.arg3 = arg3;</b>
&nbsp;        }
&nbsp;
&nbsp;        private static Expression[] getArgs(Expression arg1, Expression arg2, Expression[] arg3) {
<b class="nc">&nbsp;            Expression[] args = new Expression[arg3.length + 2];</b>
<b class="nc">&nbsp;            args[0] = arg1;</b>
<b class="nc">&nbsp;            args[1] = arg2;</b>
<b class="nc">&nbsp;            int i = 2;</b>
<b class="nc">&nbsp;            for (Expression arg : arg3)</b>
<b class="nc">&nbsp;                args[i++] = arg;</b>
&nbsp;
<b class="nc">&nbsp;            return args;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Object interpret(IEvaluatorContext ctx, Input input) {
<b class="nc">&nbsp;            int v = (java.lang.Integer) arg1.interpret(ctx, input);</b>
<b class="nc">&nbsp;            int curr = (java.lang.Integer) arg2.interpret(ctx, input);</b>
&nbsp;
<b class="nc">&nbsp;            if (v &gt;= curr)</b>
<b class="nc">&nbsp;                return v;</b>
&nbsp;
<b class="nc">&nbsp;            int prev = (java.lang.Integer) arg3[0].interpret(ctx, input);</b>
&nbsp;
<b class="nc">&nbsp;            if (v &gt;= prev)</b>
<b class="nc">&nbsp;                return curr;</b>
&nbsp;
<b class="nc">&nbsp;            for (int i = 1; i &lt; arg3.length; i++) {</b>
<b class="nc">&nbsp;                prev = (java.lang.Integer) arg3[i].interpret(ctx, input);</b>
&nbsp;
<b class="nc">&nbsp;                if (v &gt;= prev)</b>
<b class="nc">&nbsp;                    return prev;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public java.lang.String toString() {
<b class="nc">&nbsp;            return java.lang.String.format(&quot;pr1(%s,%s,%s)&quot;, arg1, arg2, listToString(arg3, &quot;,&quot;));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static Pr2 pr2(Expression arg1, Expression arg2, Expression[] arg3) {
<b class="nc">&nbsp;        return new Pr2(arg1, arg2, arg3);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static class Pr3 extends Expression.Call {
&nbsp;        Pr3(Expression... arguments) {
<b class="nc">&nbsp;            super(&quot;pr3&quot;, arguments);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Object interpret(IEvaluatorContext ctx, Input input) {
&nbsp;
<b class="nc">&nbsp;            int v1 = (java.lang.Integer) arguments[0].interpret(ctx, input);</b>
<b class="nc">&nbsp;            int v2 = (java.lang.Integer) arguments[1].interpret(ctx, input);</b>
&nbsp;
<b class="nc">&nbsp;            if (v1 == 0)</b>
<b class="nc">&nbsp;                return v2;</b>
&nbsp;
<b class="nc">&nbsp;            if (v2 == 0)</b>
<b class="nc">&nbsp;                return v1;</b>
&nbsp;
<b class="nc">&nbsp;            return java.lang.Integer.min(v1, v2);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static Pr3 pr3(Expression arg1, Expression arg2) {
<b class="nc">&nbsp;        return new Pr3(arg1, arg2);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static class Min extends Expression.Call {
&nbsp;        Min(Expression... arguments) {
<b class="fc">&nbsp;            super(&quot;min&quot;, arguments);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Object interpret(IEvaluatorContext ctx, Input input) {
<b class="fc">&nbsp;            int v1 = (java.lang.Integer) arguments[0].interpret(ctx, input);</b>
<b class="fc">&nbsp;            int v2 = (java.lang.Integer) arguments[1].interpret(ctx, input);</b>
<b class="fc">&nbsp;            return java.lang.Integer.min(v1, v2);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static Min min(Expression arg1, Expression arg2) {
<b class="fc">&nbsp;        return new Min(arg1, arg2);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static class Map extends Expression.Call {
&nbsp;        Map(Expression... arguments) {
<b class="nc">&nbsp;            super(&quot;map&quot;, arguments);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Object interpret(IEvaluatorContext ctx, Input input) {
<b class="nc">&nbsp;            return new HashMap&lt;&gt;();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static Map map() {
<b class="nc">&nbsp;        return new Map();</b>
&nbsp;    }
&nbsp;
&nbsp;    public static class Put extends Expression.Call {
&nbsp;
&nbsp;        Put(Expression... arguments) {
<b class="fc">&nbsp;            super(&quot;put&quot;, arguments);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Object interpret(IEvaluatorContext ctx, Input input) {
<b class="fc">&nbsp;            Object value = arguments[0].interpret(ctx, input);</b>
<b class="fc">&nbsp;            if (!(value instanceof java.util.Set&lt;?&gt;))</b>
<b class="nc">&nbsp;                throw new UnexpectedTypeOfArgumentException(this);</b>
&nbsp;
&nbsp;            @SuppressWarnings(&quot;unchecked&quot;)
<b class="fc">&nbsp;            java.util.Set&lt;Object&gt; s = (java.util.Set&lt;Object&gt;) value;</b>
&nbsp;
<b class="fc">&nbsp;            value = arguments[1].interpret(ctx, input);</b>
<b class="fc">&nbsp;            if (!s.contains(value)) {</b>
<b class="fc">&nbsp;                s = new HashSet&lt;&gt;(s);</b>
<b class="fc">&nbsp;                s.add(value);</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            return s;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static Put put(Expression... args) {
<b class="fc">&nbsp;        if (args.length != 2) throw new RuntimeException(&quot;args size should be two&quot;);</b>
<b class="fc">&nbsp;        return put(args[0], args[1]);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Put put(Expression arg1, Expression arg2) {
<b class="fc">&nbsp;        return new Put(arg1, arg2);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static class Put3 extends Expression.Call {
&nbsp;        Put3(Expression... arguments) {
<b class="nc">&nbsp;            super(&quot;put&quot;, arguments);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Object interpret(IEvaluatorContext ctx, Input input) {
<b class="nc">&nbsp;            Object value = arguments[0].interpret(ctx, input);</b>
<b class="nc">&nbsp;            if (!(value instanceof java.util.Map&lt;?, ?&gt;))</b>
<b class="nc">&nbsp;                throw new UnexpectedTypeOfArgumentException(this);</b>
&nbsp;
&nbsp;            @SuppressWarnings(&quot;unchecked&quot;)
<b class="nc">&nbsp;            java.util.Map&lt;Object, Object&gt; m = (java.util.Map&lt;Object, Object&gt;) value;</b>
&nbsp;
<b class="nc">&nbsp;            m = new HashMap&lt;&gt;(m);</b>
<b class="nc">&nbsp;            m.put(arguments[1].interpret(ctx, input), arguments[2].interpret(ctx, input));</b>
&nbsp;
<b class="nc">&nbsp;            return m;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static Put3 put(Expression arg1, Expression arg2, Expression arg3) {
<b class="nc">&nbsp;        return new Put3(arg1, arg2, arg3);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static class Contains extends Expression.Call {
&nbsp;
&nbsp;        Contains(Expression... arguments) {
<b class="fc">&nbsp;            super(&quot;contains&quot;, arguments);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Object interpret(IEvaluatorContext ctx, Input input) {
<b class="fc">&nbsp;            Object value = arguments[0].interpret(ctx, input);</b>
<b class="fc">&nbsp;            if (!(value instanceof java.util.Set&lt;?&gt;))</b>
<b class="nc">&nbsp;                throw new UnexpectedTypeOfArgumentException(this);</b>
&nbsp;
&nbsp;            @SuppressWarnings(&quot;unchecked&quot;)
<b class="fc">&nbsp;            java.util.Set&lt;Object&gt; s = (java.util.Set&lt;Object&gt;) value;</b>
&nbsp;
<b class="fc">&nbsp;            value = arguments[1].interpret(ctx, input);</b>
&nbsp;
<b class="fc">&nbsp;            return s.contains(value);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static Contains contains(Expression... args) {
<b class="fc">&nbsp;        if (args.length != 2) throw new RuntimeException(&quot;args size should be two&quot;);</b>
<b class="fc">&nbsp;        return contains(args[0], args[1]);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Contains contains(Expression arg1, Expression arg2) {
<b class="fc">&nbsp;        return new Contains(arg1, arg2);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static class Push extends Expression.Call {
&nbsp;
&nbsp;        Push(Expression... arguments) {
<b class="nc">&nbsp;            super(&quot;push&quot;, arguments);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Object interpret(IEvaluatorContext ctx, Input input) {
<b class="nc">&nbsp;            Expression arg1 = arguments[0];</b>
<b class="nc">&nbsp;            Expression arg2 = arguments[1];</b>
<b class="nc">&nbsp;            Object value = arg1.interpret(ctx, input);</b>
&nbsp;
<b class="nc">&nbsp;            if (value == null)</b>
<b class="nc">&nbsp;                return Stack.from(arg2.interpret(ctx, input));</b>
&nbsp;
<b class="nc">&nbsp;            if (!(value instanceof Stack&lt;?&gt;))</b>
<b class="nc">&nbsp;                throw new UnexpectedTypeOfArgumentException(this);</b>
&nbsp;
&nbsp;            @SuppressWarnings(&quot;unchecked&quot;)
<b class="nc">&nbsp;            Stack&lt;Object&gt; s = (Stack&lt;Object&gt;) value;</b>
&nbsp;
<b class="nc">&nbsp;            return s.push(arg2.interpret(ctx, input));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public java.lang.String toString() {
<b class="nc">&nbsp;            return java.lang.String.format(&quot;push(%s,%s)&quot;, arguments[0], arguments[1]);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static Push push(Expression arg1, Expression arg2) {
<b class="nc">&nbsp;        return new Push(arg1, arg2);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static class Pop extends Expression.Call {
&nbsp;        Pop(Expression... arguments) {
<b class="nc">&nbsp;            super(&quot;pop&quot;, arguments);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Object interpret(IEvaluatorContext ctx, Input input) {
<b class="nc">&nbsp;            Object value = arguments[0].interpret(ctx, input);</b>
<b class="nc">&nbsp;            if (!(value instanceof Stack&lt;?&gt;))</b>
<b class="nc">&nbsp;                throw new UnexpectedTypeOfArgumentException(this);</b>
&nbsp;
&nbsp;            @SuppressWarnings(&quot;unchecked&quot;)
<b class="nc">&nbsp;            Stack&lt;Object&gt; s = (Stack&lt;Object&gt;) value;</b>
&nbsp;
<b class="nc">&nbsp;            return s.pop();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public java.lang.String toString() {
<b class="nc">&nbsp;            return java.lang.String.format(&quot;pop(%s)&quot;, arguments[0]);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static Pop pop(Expression arg) {
<b class="nc">&nbsp;        return new Pop(arg);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static class Top extends Expression.Call {
&nbsp;        Top(Expression... arguments) {
<b class="nc">&nbsp;            super(&quot;top&quot;, arguments);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Object interpret(IEvaluatorContext ctx, Input input) {
<b class="nc">&nbsp;            Object value = arguments[0].interpret(ctx, input);</b>
<b class="nc">&nbsp;            if (!(value instanceof Stack&lt;?&gt;))</b>
<b class="nc">&nbsp;                throw new UnexpectedTypeOfArgumentException(this);</b>
&nbsp;
&nbsp;            @SuppressWarnings(&quot;unchecked&quot;)
<b class="nc">&nbsp;            Stack&lt;Object&gt; s = (Stack&lt;Object&gt;) value;</b>
&nbsp;
<b class="nc">&nbsp;            return s.top();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public java.lang.String toString() {
<b class="nc">&nbsp;            return java.lang.String.format(&quot;top(%s)&quot;, arguments[0]);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static Top top(Expression arg) {
<b class="nc">&nbsp;        return new Top(arg);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static class Find extends Expression.Call {
&nbsp;        Find(Expression... arguments) {
<b class="nc">&nbsp;            super(&quot;find&quot;, arguments);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Object interpret(IEvaluatorContext ctx, Input input) {
<b class="nc">&nbsp;            Object value = arguments[0].interpret(ctx, input);</b>
<b class="nc">&nbsp;            if (!(value instanceof Stack&lt;?&gt;))</b>
<b class="nc">&nbsp;                throw new UnexpectedTypeOfArgumentException(this);</b>
&nbsp;
&nbsp;            @SuppressWarnings(&quot;unchecked&quot;)
<b class="nc">&nbsp;            Stack&lt;java.util.Map&lt;java.lang.String, java.lang.Boolean&gt;&gt; s =</b>
&nbsp;                (Stack&lt;java.util.Map&lt;java.lang.String, java.lang.Boolean&gt;&gt;) value;
&nbsp;
<b class="nc">&nbsp;            java.lang.String key = (java.lang.String) arguments[0].interpret(ctx, input);</b>
&nbsp;
&nbsp;            java.lang.Boolean hit;
<b class="nc">&nbsp;            while (s != null) {</b>
<b class="nc">&nbsp;                hit = s.top().get(key);</b>
<b class="nc">&nbsp;                if (hit != null)</b>
<b class="nc">&nbsp;                    return hit;</b>
<b class="nc">&nbsp;                s = s.pop();</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static Find find(Expression arg1, Expression arg2) {
<b class="nc">&nbsp;        return new Find(arg1, arg2);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static class Get extends Expression.Call {
&nbsp;        private final Expression arg1;
&nbsp;        private final int arg2;
&nbsp;
&nbsp;        Get(Expression arg1, int arg2) {
<b class="fc">&nbsp;            super(&quot;get&quot;, arg1, AST.integer(arg2));</b>
<b class="fc">&nbsp;            this.arg1 = arg1;</b>
<b class="fc">&nbsp;            this.arg2 = arg2;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Object interpret(IEvaluatorContext ctx, Input input) {
<b class="fc">&nbsp;            Object result = arg1.interpret(ctx, input);</b>
<b class="fc">&nbsp;            if (result instanceof MutableLong) {</b>
<b class="nc">&nbsp;                MutableLong value = (MutableLong) result;</b>
<b class="nc">&nbsp;                if (arg2 == 0) {</b>
<b class="nc">&nbsp;                    return value.getHigherOrderInt();</b>
&nbsp;                }
<b class="nc">&nbsp;                return value.getLowerOrderInt();</b>
&nbsp;            }
<b class="fc">&nbsp;            if (result instanceof Long) {</b>
<b class="nc">&nbsp;                long value = (Long) result;</b>
<b class="nc">&nbsp;                if (arg2 == 0) {</b>
<b class="nc">&nbsp;                    return (int) (value &gt;&gt; 32);</b>
&nbsp;                }
<b class="nc">&nbsp;                return (int) (value &amp; 0xffffffffL);</b>
&nbsp;            }
<b class="fc">&nbsp;            Object[] value = (Object[]) result;</b>
<b class="fc">&nbsp;            return value[arg2];</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public java.lang.String toString() {
<b class="fc">&nbsp;            return java.lang.String.format(&quot;%s.%s&quot;, arg1, arg2);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static Get get(Expression arg1, int arg2) {
<b class="fc">&nbsp;        return new Get(arg1, arg2);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static class Get2 extends Expression.Call {
&nbsp;
&nbsp;        Get2(Expression... arguments) {
<b class="nc">&nbsp;            super(&quot;get&quot;, arguments);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Object interpret(IEvaluatorContext ctx, Input input) {
<b class="nc">&nbsp;            Expression arg1 = arguments[0];</b>
<b class="nc">&nbsp;            Expression arg2 = arguments[1];</b>
<b class="nc">&nbsp;            Object result = arg1.interpret(ctx, input);</b>
<b class="nc">&nbsp;            if (result instanceof MutableLong) {</b>
<b class="nc">&nbsp;                MutableLong value = (MutableLong) result;</b>
<b class="nc">&nbsp;                int i = (java.lang.Integer) arg2.interpret(ctx, input);</b>
<b class="nc">&nbsp;                if (i == 0) {</b>
<b class="nc">&nbsp;                    return value.getHigherOrderInt();</b>
&nbsp;                }
<b class="nc">&nbsp;                return value.getLowerOrderInt();</b>
&nbsp;            }
<b class="nc">&nbsp;            if (result instanceof Long) {</b>
<b class="nc">&nbsp;                long value = (Long) result;</b>
<b class="nc">&nbsp;                int i = (java.lang.Integer) arg2.interpret(ctx, input);</b>
<b class="nc">&nbsp;                if (i == 0) {</b>
<b class="nc">&nbsp;                    return (int) (value &gt;&gt; 32);</b>
&nbsp;                }
<b class="nc">&nbsp;                return (int) (value &amp; 0xffffffffL);</b>
&nbsp;            }
<b class="nc">&nbsp;            Object[] value = (Object[]) result;</b>
<b class="nc">&nbsp;            int i = (java.lang.Integer) arg2.interpret(ctx, input);</b>
<b class="nc">&nbsp;            return value[i];</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public java.lang.String toString() {
<b class="nc">&nbsp;            return java.lang.String.format(&quot;%s.%s&quot;, arguments[0], arguments[1]);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static Get2 get(Expression arg1, Expression arg2) {
<b class="nc">&nbsp;        return new Get2(arg1, arg2);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static class Shift extends Expression.Call {
&nbsp;
&nbsp;        Shift(Expression... arguments) {
<b class="fc">&nbsp;            super(&quot;shift&quot;, arguments);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Object interpret(IEvaluatorContext ctx, Input input) {
<b class="fc">&nbsp;            int i = (java.lang.Integer) arguments[0].interpret(ctx, input);</b>
<b class="fc">&nbsp;            if (i == 0)</b>
<b class="fc">&nbsp;                return 0;</b>
&nbsp;
<b class="nc">&nbsp;            int j = (java.lang.Integer) arguments[1].interpret(ctx, input);</b>
<b class="nc">&nbsp;            return i &amp; j;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public java.lang.String toString() {
<b class="nc">&nbsp;            return java.lang.String.format(&quot;%s&lt;&lt;%s&quot;, arguments[0], arguments[1]);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static Shift shift(Expression arg1, Expression arg2) {
<b class="fc">&nbsp;        return new Shift(arg1, arg2);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static class Undef extends Expression.Call {
&nbsp;        Undef(Expression... arguments) {
<b class="fc">&nbsp;            super(&quot;undef&quot;, arguments);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Object interpret(IEvaluatorContext ctx, Input input) {
<b class="fc">&nbsp;            return UNDEF;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public java.lang.String toString() {
<b class="fc">&nbsp;            return UNDEF.toString();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static Undef undef() {
<b class="fc">&nbsp;        return new Undef();</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Expression lShiftANDEqZero(Expression lhs, Expression rhs) {
<b class="fc">&nbsp;        return new Expression.LShiftANDEqZero(lhs, rhs);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Expression orIndent(Expression index, Expression ind, Expression first, Expression lExt) {
<b class="fc">&nbsp;        return new Expression.OrIndent(index, ind, first, lExt);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Expression andIndent(Expression index, Expression first, Expression lExt) {
<b class="fc">&nbsp;        return new Expression.AndIndent(index, first, lExt);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Expression andIndent(Expression index, Expression first, Expression lExt, boolean returnIndex) {
<b class="fc">&nbsp;        return new Expression.AndIndent(index, first, lExt, returnIndex);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Expression.Or or(Expression lhs, Expression rhs) {
<b class="fc">&nbsp;        return new Expression.Or(lhs, rhs);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Expression.And and(Expression lhs, Expression rhs) {
<b class="fc">&nbsp;        return new Expression.And(lhs, rhs);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Expression.Less less(Expression lhs, Expression rhs) {
<b class="nc">&nbsp;        return new Expression.Less(lhs, rhs);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Expression.LessThanEqual lessEq(Expression lhs, Expression rhs) {
<b class="fc">&nbsp;        return new Expression.LessThanEqual(lhs, rhs);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Expression.Greater greater(Expression lhs, Expression rhs) {
<b class="fc">&nbsp;        return new Expression.Greater(lhs, rhs);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Expression.GreaterThanEqual greaterEq(Expression lhs, Expression rhs) {
<b class="fc">&nbsp;        return new Expression.GreaterThanEqual(lhs, rhs);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Expression.Equal equal(Expression lhs, Expression rhs) {
<b class="fc">&nbsp;        return new Expression.Equal(lhs, rhs);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Expression.NotEqual notEqual(Expression lhs, Expression rhs) {
<b class="fc">&nbsp;        return new Expression.NotEqual(lhs, rhs);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Expression.LeftExtent lExt(String label) {
<b class="fc">&nbsp;        return new Expression.LeftExtent(label);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Expression.RightExtent rExt(String label) {
<b class="fc">&nbsp;        return new Expression.RightExtent(label);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Expression.Yield yield(String label) {
<b class="fc">&nbsp;        return new Expression.Yield(label);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Expression.Yield yield(String label, int i) {
<b class="nc">&nbsp;        return new Expression.Yield(label, i);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Expression.Val val(String label) {
<b class="fc">&nbsp;        return new Expression.Val(label);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Expression.EndOfFile endOfFile(Expression index) {
<b class="nc">&nbsp;        return new Expression.EndOfFile(index);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Expression ifThenElse(Expression condition, Expression thenPart, Expression elsePart) {
<b class="fc">&nbsp;        return new Expression.IfThenElse(condition, thenPart, elsePart);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Expression.Assignment assign(java.lang.String id, Expression exp) {
<b class="fc">&nbsp;        return new Expression.Assignment(id, exp);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Expression.Assignment assign(java.lang.String id, int i, Expression exp) {
<b class="nc">&nbsp;        return new Expression.Assignment(id, i, exp);</b>
&nbsp;    }
&nbsp;
&nbsp;    //
&nbsp;    // Statements
&nbsp;    //
&nbsp;    public static Statement stat(Expression exp) {
<b class="fc">&nbsp;        return new Statement.Expression(exp);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Statement varDeclStat(String name) {
<b class="nc">&nbsp;        return new Statement.VariableDeclaration(new VariableDeclaration(name));</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Statement varDeclStat(String name, Expression exp) {
<b class="fc">&nbsp;        return new Statement.VariableDeclaration(new VariableDeclaration(name, exp));</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Statement varDeclStat(String name, int i) {
<b class="nc">&nbsp;        return new Statement.VariableDeclaration(new VariableDeclaration(name, i));</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Statement varDeclStat(String name, int i, Expression exp) {
<b class="nc">&nbsp;        return new Statement.VariableDeclaration(new VariableDeclaration(name, i, exp));</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Statement varDeclStat(VariableDeclaration varDecl) {
<b class="nc">&nbsp;        return new Statement.VariableDeclaration(varDecl);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static VariableDeclaration varDecl(String name) {
<b class="nc">&nbsp;        return new VariableDeclaration(name);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static VariableDeclaration varDecl(String name, Expression exp) {
<b class="nc">&nbsp;        return new VariableDeclaration(name, exp);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static VariableDeclaration varDecl(String name, int i) {
<b class="nc">&nbsp;        return new VariableDeclaration(name, i);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static VariableDeclaration varDecl(String name, int i, Expression exp) {
<b class="nc">&nbsp;        return new VariableDeclaration(name, i, exp);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Expression.Add add(Expression lhs, Expression rhs) {
<b class="fc">&nbsp;        return new Expression.Add(lhs, rhs);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Expression.Subtract subtract(Expression lhs, Expression rhs) {
<b class="nc">&nbsp;        return new Expression.Subtract(lhs, rhs);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Expression.Multiply multiply(Expression lhs, Expression rhs) {
<b class="nc">&nbsp;        return new Expression.Multiply(lhs, rhs);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Expression.Divide divide(Expression lhs, Expression rhs) {
<b class="nc">&nbsp;        return new Expression.Divide(lhs, rhs);</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 17:08</div>
</div>
</body>
</html>
