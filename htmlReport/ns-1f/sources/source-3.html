


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > AutomatonOperations</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.iguana.regex.automaton</a>
</div>

<h1>Coverage Summary for Class: AutomatonOperations (org.iguana.regex.automaton)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">AutomatonOperations</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (15/18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    58.2%
  </span>
  <span class="absValue">
    (131/225)
  </span>
</td>
</tr>
  <tr>
    <td class="name">AutomatonOperations$Op</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (15/18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    58.2%
  </span>
  <span class="absValue">
    (131/225)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright (c) 2015, Ali Afroozeh and Anastasia Izmaylova, Centrum Wiskunde &amp; Informatica (CWI)
&nbsp; * All rights reserved.
&nbsp; *
&nbsp; * Redistribution and use in source and binary forms, with or without 
&nbsp; * modification, are permitted provided that the following conditions are met:
&nbsp; *
&nbsp; * 1. Redistributions of source code must retain the above copyright notice, this 
&nbsp; *    list of conditions and the following disclaimer.
&nbsp; *
&nbsp; * 2. Redistributions in binary form must reproduce the above copyright notice, this 
&nbsp; *    list of conditions and the following disclaimer in the documentation and/or 
&nbsp; *    other materials provided with the distribution.
&nbsp; *
&nbsp; * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND 
&nbsp; * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
&nbsp; * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
&nbsp; * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
&nbsp; * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
&nbsp; * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
&nbsp; * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
&nbsp; * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
&nbsp; * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
&nbsp; * OF SUCH DAMAGE.
&nbsp; *
&nbsp; */
&nbsp;
&nbsp;package org.iguana.regex.automaton;
&nbsp;
&nbsp;import org.iguana.regex.CharRange;
&nbsp;import org.iguana.regex.CharacterRanges;
&nbsp;
&nbsp;import java.util.ArrayDeque;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Deque;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Map.Entry;
&nbsp;import java.util.Set;
&nbsp;import java.util.stream.Collectors;
&nbsp;
<b class="nc">&nbsp;public class AutomatonOperations {</b>
&nbsp;
&nbsp;    public static Automaton makeDeterministic(Automaton automaton) {
<b class="fc">&nbsp;        if (automaton.isDeterministic())</b>
<b class="fc">&nbsp;            return automaton;</b>
&nbsp;
<b class="fc">&nbsp;        return makeDeterministic(automaton.getStartState(), automaton.getAlphabet());</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Automaton makeDeterministic(State start, CharRange[] alphabet) {
&nbsp;
<b class="fc">&nbsp;        Set&lt;Set&lt;State&gt;&gt; visitedStates = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;        Deque&lt;Set&lt;State&gt;&gt; processList = new ArrayDeque&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;        Set&lt;State&gt; initialState = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;        initialState.add(start);</b>
<b class="fc">&nbsp;        initialState = epsilonClosure(initialState);</b>
<b class="fc">&nbsp;        visitedStates.add(initialState);</b>
<b class="fc">&nbsp;        processList.add(initialState);</b>
&nbsp;
&nbsp;        /*
&nbsp;         * A map from the set of NFA states to the new state in the produced DFA.
&nbsp;         * This map is used for sharing DFA states.
&nbsp;         */
<b class="fc">&nbsp;        Map&lt;Set&lt;State&gt;, State&gt; newStatesMap = new HashMap&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;        State startState = new State();</b>
&nbsp;
<b class="fc">&nbsp;        newStatesMap.put(initialState, startState);</b>
&nbsp;
<b class="fc">&nbsp;        while (!processList.isEmpty()) {</b>
<b class="fc">&nbsp;            Set&lt;State&gt; stateSet = processList.poll();</b>
&nbsp;
<b class="fc">&nbsp;            for (CharRange r : alphabet) {</b>
<b class="fc">&nbsp;                Set&lt;State&gt; destState = move(stateSet, r);</b>
&nbsp;
<b class="fc">&nbsp;                if (destState.isEmpty())</b>
<b class="fc">&nbsp;                    continue;</b>
&nbsp;
<b class="fc">&nbsp;                State source = newStatesMap.get(stateSet);</b>
<b class="fc">&nbsp;                State dest = newStatesMap.computeIfAbsent(destState, s -&gt; {</b>
<b class="fc">&nbsp;                    State state = new State();</b>
<b class="fc">&nbsp;                    for (State ds : destState) {</b>
<b class="fc">&nbsp;                        state.addRegularExpressions(ds.getRegularExpressions());</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    return state;</b>
&nbsp;                });
<b class="fc">&nbsp;                source.addTransition(new Transition(r, dest));</b>
&nbsp;
<b class="fc">&nbsp;                if (!visitedStates.contains(destState)) {</b>
<b class="fc">&nbsp;                    visitedStates.add(destState);</b>
<b class="fc">&nbsp;                    processList.add(destState);</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Setting the final states.
&nbsp;        outer:
<b class="fc">&nbsp;        for (Entry&lt;Set&lt;State&gt;, State&gt; e : newStatesMap.entrySet()) {</b>
<b class="fc">&nbsp;            for (State s : e.getKey()) {</b>
<b class="fc">&nbsp;                if (s.getStateType() == StateType.FINAL) {</b>
<b class="fc">&nbsp;                    e.getValue().setStateType(StateType.FINAL);</b>
<b class="fc">&nbsp;                    continue outer;</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        return Automaton.builder(startState).setDeterministic(true).build();</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Automaton union(Automaton a1, Automaton a2) {
<b class="fc">&nbsp;        return op(a1, a2, (s1, s2) -&gt; s1.isFinalState() || s2.isFinalState());</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Automaton intersect(Automaton a1, Automaton a2) {
<b class="fc">&nbsp;        return op(a1, a2, (s1, s2) -&gt; s1.isFinalState() &amp;&amp; s2.isFinalState());</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Automaton difference(Automaton a1, Automaton a2) {
<b class="fc">&nbsp;        return op(a1, a2, (s1, s2) -&gt; s1.isFinalState() &amp;&amp; !s2.isFinalState());</b>
&nbsp;    }
&nbsp;
&nbsp;    private static Automaton op(Automaton a1, Automaton a2, Op op) {
<b class="fc">&nbsp;        a1 = makeDeterministic(a1);</b>
<b class="fc">&nbsp;        a2 = makeDeterministic(a2);</b>
&nbsp;
<b class="fc">&nbsp;        Map&lt;CharRange, List&lt;CharRange&gt;&gt; rangeMap = merge(a1.getAlphabet(), a2.getAlphabet());</b>
<b class="fc">&nbsp;        convertToNonOverlapping(a1, rangeMap);</b>
<b class="fc">&nbsp;        convertToNonOverlapping(a2, rangeMap);</b>
&nbsp;
<b class="fc">&nbsp;        Set&lt;CharRange&gt; values = rangeMap.values().stream()</b>
<b class="fc">&nbsp;                                                      .flatMap(List::stream)</b>
<b class="fc">&nbsp;                                                      .collect(Collectors.toSet());</b>
&nbsp;
<b class="fc">&nbsp;        a1 = makeComplete(a1, values);</b>
<b class="fc">&nbsp;        a2 = makeComplete(a2, values);</b>
&nbsp;
<b class="fc">&nbsp;        return product(a1, a2, values, op);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Produces the Cartesian product of the states of an automata.
&nbsp;     */
&nbsp;    private static Automaton product(Automaton a1, Automaton a2, Set&lt;CharRange&gt; values, Op op) {
&nbsp;
<b class="fc">&nbsp;        State[] states1 = a1.getStates();</b>
<b class="fc">&nbsp;        State[] states2 = a2.getStates();</b>
&nbsp;
<b class="fc">&nbsp;        State[][] newStates = new State[states1.length][states2.length];</b>
&nbsp;
<b class="fc">&nbsp;        State startState = null;</b>
&nbsp;
<b class="fc">&nbsp;        for (int i = 0; i &lt; states1.length; i++) {</b>
<b class="fc">&nbsp;            for (int j = 0; j &lt; states2.length; j++) {</b>
&nbsp;
<b class="fc">&nbsp;                State state = getState(newStates, i, j);</b>
<b class="fc">&nbsp;                State state1 = states1[i];</b>
<b class="fc">&nbsp;                State state2 = states2[j];</b>
&nbsp;
<b class="fc">&nbsp;                for (CharRange r : values) {</b>
<b class="fc">&nbsp;                    State dest1 = state1.getState(r);</b>
<b class="fc">&nbsp;                    State dest2 = state2.getState(r);</b>
<b class="fc">&nbsp;                    if (dest1 != null &amp;&amp; dest2 != null) {</b>
<b class="fc">&nbsp;                        State dest = getState(newStates, dest1.getId(), dest2.getId());</b>
<b class="fc">&nbsp;                        state.addTransition(new Transition(r, dest));</b>
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
&nbsp;
<b class="fc">&nbsp;                if (op.execute(state1, state2)) {</b>
<b class="fc">&nbsp;                    state.setStateType(StateType.FINAL);</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (state1 == a1.getStartState() &amp;&amp; state2 == a2.getStartState()) {</b>
<b class="fc">&nbsp;                    startState = state;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return Automaton.builder(startState).build();</b>
&nbsp;    }
&nbsp;
&nbsp;    private static State getState(State[][] newStates, int i, int j) {
<b class="fc">&nbsp;        State state = newStates[i][j];</b>
<b class="fc">&nbsp;        if (state == null) {</b>
<b class="fc">&nbsp;            state = new State();</b>
<b class="fc">&nbsp;            newStates[i][j] = state;</b>
&nbsp;        }
<b class="fc">&nbsp;        return state;</b>
&nbsp;    }
&nbsp;
&nbsp;    public static void convertToNonOverlapping(Automaton a, Map&lt;CharRange, List&lt;CharRange&gt;&gt; rangeMap) {
<b class="fc">&nbsp;        for (State state : a.getStates()) {</b>
<b class="fc">&nbsp;            List&lt;Transition&gt; removeList = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;            List&lt;Transition&gt; addList = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;            for (Transition transition : state.getTransitions()) {</b>
<b class="fc">&nbsp;                if (!transition.isEpsilonTransition()) {</b>
<b class="fc">&nbsp;                    removeList.add(transition);</b>
<b class="fc">&nbsp;                    for (CharRange range : rangeMap.get(transition.getRange())) {</b>
<b class="fc">&nbsp;                        addList.add(new Transition(range, transition.getDestination()));</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            state.removeTransitions(removeList);</b>
<b class="fc">&nbsp;            state.addTransitions(addList);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    public static Automaton makeComplete(Automaton automaton, Iterable&lt;CharRange&gt; alphabet) {
&nbsp;
<b class="fc">&nbsp;        State dummyState = new State();</b>
<b class="fc">&nbsp;        alphabet.forEach(r -&gt; dummyState.addTransition(new Transition(r, dummyState)));</b>
&nbsp;
<b class="fc">&nbsp;        for (State state : automaton.getStates()) {</b>
<b class="fc">&nbsp;            for (CharRange r : alphabet) {</b>
<b class="fc">&nbsp;                if (!state.hasTransition(r)) {</b>
<b class="fc">&nbsp;                    state.addTransition(new Transition(r, dummyState));</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return Automaton.builder(automaton.getStartState()).build();</b>
&nbsp;    }
&nbsp;
&nbsp;    private static Map&lt;CharRange, List&lt;CharRange&gt;&gt; merge(CharRange[] alphabet1, CharRange[] alphabet2) {
<b class="fc">&nbsp;        List&lt;CharRange&gt; alphabets = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;        for (CharRange r : alphabet1) { alphabets.add(r); }</b>
<b class="fc">&nbsp;        for (CharRange r : alphabet2) { alphabets.add(r); }</b>
&nbsp;
<b class="fc">&nbsp;        return CharacterRanges.toNonOverlapping(alphabets);</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    public static Automaton minimize(Automaton automaton) {
<b class="nc">&nbsp;        if (automaton.isMinimized())</b>
<b class="nc">&nbsp;            return automaton;</b>
&nbsp;
<b class="nc">&nbsp;        return minimize(automaton.getAlphabet(), automaton.getStates(), automaton.getStartState());</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Creates the reverse of the given automaton. A reverse automaton
&nbsp;     * accept the reverse language accepted by the original automaton. To construct
&nbsp;     * a reverse automaton, all final states of the original automaton are becoming
&nbsp;     * start states, transitions are reversed and the start state becomes the
&nbsp;     * only final state.
&nbsp;     *
&nbsp;     */
&nbsp;    public static Automaton reverse(Automaton automaton) {
&nbsp;
&nbsp;        // 1. Creating new states for each state of the original automaton
<b class="fc">&nbsp;        final Map&lt;State, State&gt; newStates = new HashMap&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;        for (State s : automaton.getStates()) {</b>
<b class="fc">&nbsp;            newStates.put(s, new State());</b>
&nbsp;        }
&nbsp;
&nbsp;        // 2. Creating a new start state and adding epsilon transitions to the final
&nbsp;        // states of the original automata
<b class="fc">&nbsp;        State startState = new State();</b>
&nbsp;
<b class="fc">&nbsp;        for (State finalState : automaton.getFinalStates()) {</b>
<b class="fc">&nbsp;            startState.addEpsilonTransition(newStates.get(finalState));</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        // 3. Reversing the transitions
<b class="fc">&nbsp;        for (State state : automaton.getStates()) {</b>
<b class="fc">&nbsp;            for (Transition t : state.getTransitions()) {</b>
<b class="fc">&nbsp;                newStates.get(t.getDestination()).addTransition(new Transition(t.getRange(), newStates.get(state)));</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        // 4. Making the start state final
<b class="fc">&nbsp;        newStates.get(automaton.getStartState()).setStateType(StateType.FINAL);</b>
&nbsp;
<b class="fc">&nbsp;        return Automaton.builder(startState).build();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     *
&nbsp;     * Note: unreachable states are already removed as we gather the states
&nbsp;     * reachable from the start state of the given NFA.
&nbsp;     *
&nbsp;     */
&nbsp;    public static Automaton minimize(CharRange[] alphabet, State[] states, State startState) {
&nbsp;
<b class="nc">&nbsp;        int size = states.length;</b>
<b class="nc">&nbsp;        int[][] table = new int[size][size];</b>
&nbsp;
<b class="nc">&nbsp;        final int EMPTY = -2;</b>
<b class="nc">&nbsp;        final int EPSILON = -1;</b>
&nbsp;
<b class="nc">&nbsp;        for (int i = 0; i &lt; table.length; i++) {</b>
<b class="nc">&nbsp;            for (int j = 0; j &lt; i; j++) {</b>
<b class="nc">&nbsp;                table[i][j] = EMPTY;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (int i = 0; i &lt; table.length; i++) {</b>
<b class="nc">&nbsp;            for (int j = 0; j &lt; i; j++) {</b>
<b class="nc">&nbsp;                if (states[i].isFinalState() &amp;&amp; !states[j].isFinalState()) {</b>
<b class="nc">&nbsp;                    table[i][j] = EPSILON;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (states[j].isFinalState() &amp;&amp; !states[i].isFinalState()) {</b>
<b class="nc">&nbsp;                    table[i][j] = EPSILON;</b>
&nbsp;                }
&nbsp;
&nbsp;                // Differentiate between final states
<b class="nc">&nbsp;                if (states[i].isFinalState()</b>
<b class="nc">&nbsp;                    &amp;&amp; states[j].isFinalState()) {</b>
<b class="nc">&nbsp;                    table[i][j] = EPSILON;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        boolean changed = true;</b>
&nbsp;
<b class="nc">&nbsp;        while (changed) {</b>
<b class="nc">&nbsp;            changed = false;</b>
&nbsp;
<b class="nc">&nbsp;                for (int i = 0; i &lt; table.length; i++) {</b>
<b class="nc">&nbsp;                    for (int j = 0; j &lt; i; j++) {</b>
&nbsp;
&nbsp;                        // If two states i and j are distinct
<b class="nc">&nbsp;                        if (table[i][j] == EMPTY) {</b>
<b class="nc">&nbsp;                            for (int t = 0; t &lt; alphabet.length; t++) {</b>
<b class="nc">&nbsp;                                State q1 = states[i].getState(alphabet[t]);</b>
<b class="nc">&nbsp;                                State q2 = states[j].getState(alphabet[t]);</b>
&nbsp;
&nbsp;                                // If both states i and j have no outgoing transitions on the interval t, continue with
&nbsp;                                // the next transition.
<b class="nc">&nbsp;                                if (q1 == null &amp;&amp; q2 == null) {</b>
<b class="nc">&nbsp;                                    continue;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                // If the transition t can be applied on state i but not on state j, two states are
&nbsp;                                // disjoint. Continue with the next pair of states.
<b class="nc">&nbsp;                                if ((q1 == null &amp;&amp; q2 != null) || (q2 == null &amp;&amp; q1 != null)) {</b>
<b class="nc">&nbsp;                                    table[i][j] = t;</b>
<b class="nc">&nbsp;                                    changed = true;</b>
<b class="nc">&nbsp;                                    break;</b>
&nbsp;                                }
&nbsp;
<b class="nc">&nbsp;                                if (q1.getId() == q2.getId()) {</b>
<b class="nc">&nbsp;                                    continue;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                int a;
&nbsp;                                int b;
<b class="nc">&nbsp;                                if (q1.getId() &gt; q2.getId()) {</b>
<b class="nc">&nbsp;                                    a = q1.getId();</b>
<b class="nc">&nbsp;                                    b = q2.getId();</b>
&nbsp;                                } else {
<b class="nc">&nbsp;                                    a = q2.getId();</b>
<b class="nc">&nbsp;                                    b = q1.getId();</b>
&nbsp;                                }
&nbsp;
<b class="nc">&nbsp;                                if (table[a][b] != EMPTY) {</b>
<b class="nc">&nbsp;                                    table[i][j] = t;</b>
<b class="nc">&nbsp;                                    changed = true;</b>
<b class="nc">&nbsp;                                    break;</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Map&lt;State, Set&lt;State&gt;&gt; partitionsMap = new HashMap&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        for (int i = 0; i &lt; table.length; i++) {</b>
<b class="nc">&nbsp;            for (int j = 0; j &lt; i; j++) {</b>
<b class="nc">&nbsp;                if (table[i][j] == EMPTY) {</b>
<b class="nc">&nbsp;                    State stateI = states[i];</b>
<b class="nc">&nbsp;                    State stateJ = states[j];</b>
&nbsp;
<b class="nc">&nbsp;                    Set&lt;State&gt; partitionI = partitionsMap.get(stateI);</b>
<b class="nc">&nbsp;                    Set&lt;State&gt; partitionJ = partitionsMap.get(stateJ);</b>
&nbsp;
<b class="nc">&nbsp;                    if (partitionI == null &amp;&amp; partitionJ == null) {</b>
<b class="nc">&nbsp;                        Set&lt;State&gt; set = new HashSet&lt;&gt;();</b>
<b class="nc">&nbsp;                        set.add(stateI);</b>
<b class="nc">&nbsp;                        set.add(stateJ);</b>
<b class="nc">&nbsp;                        partitionsMap.put(stateI, set);</b>
<b class="nc">&nbsp;                        partitionsMap.put(stateJ, set);</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    else if (partitionI == null &amp;&amp; partitionJ != null) {</b>
<b class="nc">&nbsp;                        partitionJ.add(stateI);</b>
<b class="nc">&nbsp;                        partitionsMap.put(stateI, partitionJ);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    else if (partitionJ == null &amp;&amp; partitionI != null) {</b>
<b class="nc">&nbsp;                        partitionI.add(stateJ);</b>
<b class="nc">&nbsp;                        partitionsMap.put(stateJ, partitionI);</b>
&nbsp;                    }
&nbsp;                    else {
<b class="nc">&nbsp;                        partitionJ.addAll(partitionI);</b>
<b class="nc">&nbsp;                        partitionI.addAll(partitionJ);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        HashSet&lt;Set&lt;State&gt;&gt; partitions = new HashSet&lt;&gt;(partitionsMap.values());</b>
&nbsp;
<b class="nc">&nbsp;        State newStartState = null;</b>
&nbsp;
<b class="nc">&nbsp;        for (State state : states) {</b>
<b class="nc">&nbsp;            if (partitionsMap.get(state) == null) {</b>
<b class="nc">&nbsp;                Set&lt;State&gt; set = new HashSet&lt;&gt;();</b>
<b class="nc">&nbsp;                set.add(state);</b>
<b class="nc">&nbsp;                partitions.add(set);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Map&lt;State, State&gt; newStates = new HashMap&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        for (Set&lt;State&gt; set : partitions) {</b>
<b class="nc">&nbsp;            State newState = new State();</b>
<b class="nc">&nbsp;            for (State state : set) {</b>
&nbsp;
<b class="nc">&nbsp;                newState.addRegularExpressions(state.getRegularExpressions());</b>
&nbsp;
<b class="nc">&nbsp;                if (set.contains(startState)) {</b>
<b class="nc">&nbsp;                    newStartState = newState;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (state.isFinalState()) {</b>
<b class="nc">&nbsp;                    newState.setStateType(StateType.FINAL);</b>
&nbsp;                }
<b class="nc">&nbsp;                newStates.put(state, newState);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        for (State state : states) {</b>
<b class="nc">&nbsp;            for (Transition t : state.getTransitions()) {</b>
<b class="nc">&nbsp;                newStates.get(state).addTransition(new Transition(t.getStart(), t.getEnd(),</b>
<b class="nc">&nbsp;                    newStates.get(t.getDestination())));</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return Automaton.builder(newStartState).build();</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    private static Set&lt;State&gt; epsilonClosure(Set&lt;State&gt; states) {
<b class="fc">&nbsp;        Set&lt;State&gt; newStates = new HashSet&lt;&gt;(states);</b>
&nbsp;
<b class="fc">&nbsp;        for (State state : states) {</b>
<b class="fc">&nbsp;            Set&lt;State&gt; s = state.getEpsilonSates();</b>
<b class="fc">&nbsp;            if (!s.isEmpty()) {</b>
<b class="fc">&nbsp;                newStates.addAll(s);</b>
<b class="fc">&nbsp;                newStates.addAll(epsilonClosure(s));</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        return newStates;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static Set&lt;State&gt; move(Set&lt;State&gt; state, CharRange r) {
<b class="fc">&nbsp;        Set&lt;State&gt; result = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;        for (State s : state) {</b>
<b class="fc">&nbsp;            State dest = s.getState(r);</b>
<b class="fc">&nbsp;            if (dest != null) {</b>
<b class="fc">&nbsp;                result.add(dest);</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        return epsilonClosure(result);</b>
&nbsp;    }
&nbsp;
&nbsp;    @FunctionalInterface
&nbsp;    private interface Op {
&nbsp;        boolean execute(State s1, State s2);
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 17:08</div>
</div>
</body>
</html>
