/**
 * This code is automatically generated.
 * Changes to this file may cause incorrect behavior and will be lost when the code is regenerated.
 */
 
package ${packageName};

import org.jgll.parser.Descriptor;
import org.jgll.parser.GLLParser;
import org.jgll.parser.GSSNode;
import org.jgll.exception.ParsingFailedException;
import org.jgll.grammar.Grammar;
import org.jgll.grammar.Nonterminal;
import org.jgll.sppf.NonterminalSymbolNode;
import org.jgll.sppf.DummyNode;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class ${className}Parser extends GLLParser {
	
	private static final Logger log = LoggerFactory.getLogger(${className}Parser.class);
	
	private static final int L0 = -1; 
	
	/**
	 * The current grammar label
	 */
	private int label;
		
	@Override
	public void init() {
			
		lookup = new org.jgll.lookup.MapLevelledLookup(grammar, I.length);
		descriptorSet =  new org.jgll.parser.LevelledDescritorSet(I.length, (org.jgll.lookup.LevelledLookup) lookup);
			
		ci = 0;
		cu = u0 = GSSNode.DUMMY;
		cn = DummyNode.getInstance();

		errorIndex = -1;
		errorNonterminal = null;
	}
	
	private void log(long start, long end) {
		log.info("Parsing Time: {} ms", (end - start)/1000000);
		
		int mb = 1024 * 1024;
		Runtime runtime = Runtime.getRuntime();
		log.info("Memory used: {} mb", (runtime.totalMemory() - runtime.freeMemory()) / mb);
		log.info("Descriptors: {}", descriptorSet.sizeAll());
		log.info("Non-packed nodes: {}", lookup.sizeNonPackedNodes());
	}
	
		
	@Override
	public NonterminalSymbolNode parse(int[] input, Grammar grammar, Nonterminal startSymbol) throws ParsingFailedException {
	
		this.grammar = grammar;

		I = input;

		log.info("Input size: {}", input.length);
		
		long start = System.nanoTime();
		
		init();
	
		label = startSymbol.getId();
		
		long end = System.nanoTime();
		log.info("Initialization time: {} ms", (end - start) / 1000000);		

		start = System.nanoTime();

		while (true) {
			switch (label) {
			
// The generated code will come here!