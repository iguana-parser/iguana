
global env = set()

start Definition
  = defs:(Rule | Global)+

Global
 = "global" id:Identifier "=" exp:Expression env=put(env,id.yield)

Rule
  = modifier: ("start" | "layout")? name:Name params:Parameters? "=" body:Body      %ContextFree
  | modifier: "layout"? "regex" name:Name "=" body:RegexBody                        %Regex

Parameters
  = "(" {id:Identifier env=put(env, id.yield) ","}* ")"

RegexBody
  = { Regex+ "|" }*

Body
  = {PriorityLevels ">"}+

PriorityLevels
  = {Alternative "|"}+

Alternative
  = seq:Sequence                                        %Sequence
  | assoc:Associativity "(" seqs: {Sequence "|"}+ ")"   %Associativity
  | label:Label?                                        %Empty

Sequence
  = assoc:Associativity? cond:Condition? first:Symbol rest:Symbol+ ret:ReturnExpression? label:Label?   %MoreThanOneElem
  | cond:Condition? sym:Symbol ret:ReturnExpression? label:Label?                                       %SingleElem

Condition
  = "[" {Expression ","}* "]"

Symbol
  = id:Identifier args:Arguments                                 %Call
  > "offside" sym:Symbol                                         %Offside
  > sym:Symbol "*"                                               %Star
  | sym:Symbol "+"                                               %Plus
  | sym:Symbol "?"                                               %Option
  | "(" syms:Symbol+ ")"                                         %Sequence
  | "(" first:Symbol+ rest:("|" Symbol+)+ ")"                    %Alternation
  > "align" sym:Symbol                                           %Align
  | "ignore" sym:Symbol                                          %Ignore
  > id:Identifier ":" sym:Symbol                                 %Labeled
  > sym:Symbol !Statement stmts:Statement+                       %Statement
  | sym:Symbol cond:Condition                                    %PostCondition
  > reg:Regex "<<" sym:Symbol                                    %Precede
  | reg:Regex "!<<" sym:Symbol                                   %NotPrecede
  > sym:Symbol ">>" reg:Regex                                    %Follow
  | sym:Symbol "!>>" reg:Regex                                   %NotFollow
  | sym:Symbol "\\" reg:Regex                                    %Exclude
  | sym:Symbol "!" id:Identifier                                 %Except
  | "if" exp:Expression ifPart:Symbol "else" elsePart:Symbol     %IfThenElse
  | id:Identifier                                                %Identifier
  | string:String                                                %String
  | "{" sym:Symbol sep:Symbol+ "}" "*"                           %StarSep
  | "{" sym:Symbol sep:Symbol+ "}" "+"                           %PlusSep

Arguments
  = "(" {Expression ","}* ")"

Statement
  = fun:FunName args:Arguments ";"?    %Call
  | bindings:Binding ";"?              %Binding

Binding
  = varName:VarName "=" exp:Expression                                      %Assign
  | "var" decls:{(id:Name env=put(env, id.yield) "=" Expression) ","}+      %Declare

Regex
  = reg:Regex "*"                     %Star
  | reg:Regex "+"                     %Plus
  | reg:Regex "?"                     %Option
  | "(" reg:Regex ")"                 %Bracket
  | "(" first:Regex rest:Regex+ ")"   %Sequence
  | "(" regs:{ Regex+ "|" }+ ")"      %Alternation
  | name:Name                         %Nont
  | charClass:CharClass               %CharClass
  | string:String                     %String

CharClass
  = "[" ranges:Range* "]"      %Chars
  | "!" "[" ranges:Range* "]"  %NotChars

Range
  = first:RangeChar "-" second:RangeChar   %Range
  | range:RangeChar                        %Character

Expression
  =           FunName Arguments            %Call
  |           "!" Expression               %Not
  > left      (Expression "*" Expression   %Multiplication
  |            Expression "/" Expression   %Division)
  > left      (Expression "+" Expression   %Addition
  |            Expression "-" Expression   %Subtraction)
  > non-assoc (Expression ">=" Expression  %GreaterEq
  |            Expression "<=" Expression  %LessEq
  |            Expression ">" Expression   %Greater
  |            Expression "<" Expression   %Less)
  > non-assoc (Expression "==" Expression  %Equal
  |            Expression "!=" Expression  %NotEqual)
  > left      (Expression "&&" Expression  %And
  |            Expression "||" Expression  %Or)
  |           Identifier ".l"              %LExtent
  |           Identifier ".r"              %RExtent
  |           Identifier ".yield"          %Yield
  |           Identifier ".val"            %Val
  |           VarName                      %Name
  |           Number                       %Number
  |           "(" Expression ")"           %Bracket

ReturnExpression
  = "{" Expression "}"

VarName
  = id:Identifier   [contains(env,id.yield)]

Label
  = '%' Identifier

Name
  = id:Identifier   [!contains(env,id.yield)]

Identifier
  = [A-Z_a-z] !<< LetterOrDigits \ Keywords

regex LetterOrDigits
  = Letter (Letter | LetterOrDigit)*

regex LetterOrDigit
  = [A-Za-z_0-9]

regex Letter
  = [A-Za-z_]

regex Number
  = [0]
  | [1-9][0-9]*

regex Character
  = "\\" [' " \\ t f r n]
  | ![' " \\]

regex RangeChar
  = "\\" [\\ \[ \] \- t f r n \ ]
  | ![\\ \[ \] \- \t \f \r \n \ ]

regex String
  = "\"" Character* "\""
  | "\'" Character* "\'"

layout regex Layout
  = WhiteSpaceOrComment*

regex WhiteSpaceOrComment
  = WhiteSpace
  | Comment

regex WhiteSpace
  = [\ \t \f \r \n]+

regex Comment
  = SingleLineComment
  | MultiLineComment

regex SingleLineComment
  = "//" ![\r \n]* [\r\n]

regex MultiLineComment
  = "/*" CommentChar* [*]+  "/"

regex CommentChar
  = [/]
  | [*]* ![/ *]

regex Associativity
  = "left"
  | "right"
  | "non-assoc"

regex Keywords
  = "start"
  | "regex"
  | "layout"
  | "var"
  | "left"
  | "right"
  | "non-assoc"
  | "align"
  | "offside"
  | "ignore"
  | "println"
  | "indent"
  | "if"
  | "else"
  | "assert"
  | "set"
  | "contains"
  | "put"

regex FunName
  = "println"
  | "indent"
  | "assert"
  | "set"
  | "contains"
  | "put"
